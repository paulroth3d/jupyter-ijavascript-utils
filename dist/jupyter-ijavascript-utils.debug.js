/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/SourceMap.js":
/*!**************************!*\
  !*** ./src/SourceMap.js ***!
  \**************************/
/***/ ((module) => {

eval("const addObjectProperty = (obj, property, value) => {\n  // eslint-disable-next-line no-param-reassign\n  obj[property] = value;\n  return obj;\n};\n\n/**\n * Simple class that extends Map - to include a source and toString fixes.\n * \n * Specifically generated from {@link module:group.by|group.by(collection, ...)}\n * \n * * Reduce Group Magic\n *   * {@link SourceMap#reduce|SourceMap.reduce(fn)} - Reduce the groups held within to objects - for reports\n *   * {@link SourceMap#reduceSeparate|SourceMap.reduceSeparate(fn)} - Reduce the groups to objects - for charts\n *   * {@link SourceMap#map|SourceMap.map(fn)} - Map the leaf (array) collection to allow for sorting, filtering, reducing, etc.\n * * Source functionality\n *   * {@link SourceMap#getSource|SourceMap.getSource} - specify the source of how the group was made\n *   * {@link SourceMap#setSource|SourceMap.setSource} - get the source of how the group was made\n * * Fixing Map toString / JSON.Stringify common issues\n *   * {@link SourceMap.stringifyReducer|SourceMap.stringifyReducer} - JSON.stringify(map, reducer) - to allow maps to convert\n *   * {@link SourceMap#toJSON|SourceMap.toJSON} - Corrected toJSON functionality, so it works as expected\n *   * {@link SourceMap#toString|SourceMap.toString} - Corrected toString functionality, so it works as expected\n */\nclass SourceMap extends Map {\n  /**\n   * The property the map was sourced from\n   * @type {String}\n   */\n  source;\n\n  /**\n   * Specify the source\n   * @param {Strinng} source -\n   */\n  setSource(source) {\n    this.source = source;\n  }\n\n  /**\n   * Getter for the source\n   * @returns {String}\n   */\n  getSource() {\n    return this.source;\n  }\n\n  /**\n   * Use this for a reducer for Maps if ever needed.\n   * \n   * (NOTE: SourceMap already uses this where needed, you only would use this for normal maps)\n   * \n   * `JSON.stringify(new Map())` doesn't work well, it just returns `Map()`\n   * - regardless of what it contains\n   * \n   * instead use something like this:\n   * \n   * ```\n   * //-- can be a map, or any object, even one including a map\n   * const toBeStringified = { value: 'a', map: new Map() };\n   * \n   * //-- simple destructure to make it easier to access\n   * const stringifyReducer = utils.SourceMap.stringifyReducer;\n   * \n   * //-- pass it in as the second argument\n   * JSON.stringify(toBeStringified, stringifyReducer);\n   * \n   * // returns\n   * {\"value\":\"a\",\"map\":{\"dataType\":\"Map\",\"value\":[[\"A\",1],[\"B\",2]]}}\n   * \n   * //-- or on a traditional map\n   * const standardMap = new Map([['a', 1], ['b', 2]]);\n   * \n   * JSON.stringify(standardMap, stringifyReducer);\n   * \n   * // returns\n   * {\"dataType\":\"Map\",\"value\":[[\"a\",1],[\"b\",2]]}\n   * ```\n   * \n   * @param {String} key - the name of the property\n   * @param {any} value -\n   * @returns {Object}\n   */\n  static stringifyReducer(key, value) {\n    if (value instanceof SourceMap) {\n      return {\n        dataType: 'SourceMap',\n        source: value.source,\n        data: Array.from(value.entries())\n      };\n    } else if (value instanceof Map) {\n      return {\n        dataType: 'Map',\n        value: Array.from(value.entries()) // or with spread: value: [...value]\n      };\n    }\n    return value;\n  }\n\n  /**\n   * toString() override to use the stringify reducer.\n   * \n   * Now you can use `String(sourceMapInstance)` and it will work correctly.\n   * \n   * ```\n   * //-- for instance\n   * String(sourceMapInstance)\n   * ```\n   * \n   * provides\n   * \n   * ```\n   * {\"dataType\":\"SourceMap\",\"source\":\"city\",\"data\":\n   * [[\"Seattle\",{\"dataType\":\"SourceMap\",\"source\":\"month\",\"data\":\n   * [[\"Aug\",[{\"id\":1,\"city\":\"Seattle\",\"month\":\"Aug\",\"precip\":0.87}]],\n   * [\"Apr\",[{\"id\":0,\"city\":\"Seattle\",\"month\":\"Apr\",\"precip\":2.68}]],\n   * [\"Dec\",[{\"id\":2,\"city\":\"Seattle\",\"month\":\"Dec\",\"precip\":5.31}]]]}],\n   * [\"New York\",{\"dataType\":\"SourceMap\",\"source\":\"month\",\"data\":\n   * [[\"Apr\",[{\"id\":3,\"city\":\"New York\",\"month\":\"Apr\",\"precip\":3.94}]],\n   * [\"Aug\",[{\"id\":4,\"city\":\"New York\",\"month\":\"Aug\",\"precip\":4.13}]],\n   * [\"Dec\",[{\"id\":5,\"city\":\"New York\",\"month\":\"Dec\",\"precip\":3.58}]]]}],\n   * [\"Chicago\",{\"dataType\":\"SourceMap\",\"source\":\"month\",\"data\":\n   * [[\"Apr\",[{\"id\":6,\"city\":\"Chicago\",\"month\":\"Apr\",\"precip\":3.62}]],\n   * [\"Dec\",[{\"id\":8,\"city\":\"Chicago\",\"month\":\"Dec\",\"precip\":2.56}]],\n   * [\"Aug\",[{\"id\":7,\"city\":\"Chicago\",\"month\":\"Aug\",\"precip\":3.98}]]]}]]}\n   * ```\n   * \n   * @returns {String}\n   */\n  toString() {\n    return JSON.stringify(this, SourceMap.stringifyReducer);\n  }\n\n  /**\n   * `toJSON()` override.\n   * \n   * Now you can use `JSON.stringify(sourceMapInstance)` and it will work correctly\n   * \n   * or within Jupyter / iJavaScript:\n   * \n   * ```\n   * $$.json(sourceMapInstance)\n   * ```\n   * \n   * and you can explore the values in collapsing folders\n   * \n   * ![Screenshot using $$.json](img/SourceMap_jsonExplore.png)\n   * \n   * @returns {Object}\n   */\n  toJSON() {\n    return {\n      dataType: 'SourceMap',\n      source: this.source,\n      data: Array.from(this.entries())\n    };\n  }\n\n  /**\n   * Reduces a SourceMap by groups, to a collection of objects that can be printed.\n   * \n   * Note that the ReduceFn is called at the grouped collection of records level,\n   * not the entire collection.\n   * \n   * This can be very helpful when working with tables.\n   * \n   * ```\n   * new utils.TableGenerator(\n   *   utils.group.by(weather, 'city')\n   *     .reduce((group) => ({\n   *       min: utils.agg.min(group, 'precip'),\n   *       max: utils.agg.max(group, 'precip'),\n   *       avg: utils.agg.avgMean(group, 'precip')\n   *     }))\n   * )\n   *   .render()\n   * ```\n   * \n   * ![Screenshot of reduce with table](img/aggregateReduceTable.png)\n   * \n   * @param {Function} reduceFn - (collection, props) => {Object} - Function that reduces the collection to an object\n   * @param {Array} reduceFn.collection - the collection of records in the group\n   * @param {Object} reduceFn.collectionProps - the properties and values the collection was grouped by\n   * @returns {Array} - Array of objects merged with the parent group attributes and reduceFn result\n   * @see {@link SourceMap#reduceSeparate|reduceSeparate()} - for separate objects - useful for vega charts\n   * @example\n   * collection = [\n   *   { id: 1, city: 'Seattle',  month: 'Aug', precip: 0.87 },\n   *   { id: 0, city: 'Seattle',  month: 'Apr', precip: 2.68 },\n   *   { id: 3, city: 'New York', month: 'Apr', precip: 3.94 },\n   *   { id: 4, city: 'New York', month: 'Aug', precip: 4.13 }\n   * ];\n   * utils.group.by(collection, 'city')\n   *    .reduce((records) => {\n   *      min: utils.aggregate.min('precip'),\n   *      max: utils.aggregate.min('precip'),\n   *      avg: utils.aggregate.avgMean('precip')\n   *    });\n   * //-- results\n   * [{ city: 'Seattle', min: 0.87, max: 2.68, avg: 1.78 },\n   *  { city: 'New York', min: 3.94, max: 4.13, avg: 4.06 }];\n   */\n  reduce(reduceFn) {\n    return SourceMap.reduceGroup(this, reduceFn, {});\n  }\n\n  /**\n   * Reduces a SourceMap by groups, to a collection of objects that can be printed.\n   * \n   * **This can be very helpful when working with tables.**\n   * \n   * ```\n   * new utils.TableGenerator(\n   *   utils.group.by(weather, 'city')\n   *     .reduce((group) => ({\n   *       min: utils.agg.min(group, 'precip'),\n   *       max: utils.agg.max(group, 'precip'),\n   *       avg: utils.agg.avgMean(group, 'precip')\n   *     }))\n   * )\n   *   .render()\n   * ```\n   * \n   * ![Screenshot of reduce with table](img/aggregateReduceTable.png)\n   * \n   * @param {Function} reduceFn - (collection, props) => {Object} - Function that reduces the collection to an object\n   * @param {Array} reduceFn.collection - the collection of records in the group\n   * @param {Object} reduceFn.collectionProps - the properties and values the collection was grouped by\n   * @returns {Array} - Array of objects merged with the parent group attributes and reduceFn result\n   * @see {@link SourceMap#reduce|reduce()} - to call this method from an instance\n   * @private\n   * @example\n   * collection = [\n   *   { id: 1, city: 'Seattle',  month: 'Aug', precip: 0.87 },\n   *   { id: 0, city: 'Seattle',  month: 'Apr', precip: 2.68 },\n   *   { id: 3, city: 'New York', month: 'Apr', precip: 3.94 },\n   *   { id: 4, city: 'New York', month: 'Aug', precip: 4.13 }\n   * ];\n   * utils.group.by(collection, 'city')\n   *    .reduce((records) => ({\n   *      min: utils.aggregate.min('precip'),\n   *      max: utils.aggregate.min('precip'),\n   *      avg: utils.aggregate.avgMean('precip')\n   *    }));\n   * //-- results\n   * [{ city: 'Seattle', min: 0.87, max: 2.68, avg: 1.78 },\n   *  { city: 'New York', min: 3.94, max: 4.13, avg: 4.06 }];\n   */\n  static reduceGroup(sourceMap, reduceFn, currentObj = {}) {\n    if (sourceMap instanceof SourceMap) {\n      // console.log('found sourceMap');\n      const results = Array.from(sourceMap.entries()).flatMap(([key, values]) => SourceMap.reduceGroup(values, reduceFn, addObjectProperty(currentObj, sourceMap.source, key)));\n      // console.log('sourceMapResults: ' + JSON.stringify(results));\n      return results;\n    } else if (!Array.isArray(sourceMap)) {\n      throw Error('reduceGroups only works on arrays or sourceMaps');\n    }\n\n    //-- collection should either be SourceMap or Array\n    const results = [{\n      ...currentObj,\n      ...reduceFn(sourceMap, currentObj)\n    }];\n    // console.log('array results: ' + JSON.stringify(results));\n    return results;\n  }\n\n  /**\n   * Reduces, but puts each aggregate value on a separate record.\n   * \n   * **This is particularly useful for charting vega, as series must be on separate objects.**\n   * \n   * Each object then made per group leaf collection, preserving the groups used to make it.\n   * \n   * The object generated by the function is then merged.\n   * \n   * ```\n   * utils.vega.svg((vl) => vl.markLine()\n   *     .data(\n   *         utils.group.by(weather, 'city')\n   *             .reduceSeparate((group) => ({\n   *                 min: utils.agg.min(group, 'precip'),\n   *                 max: utils.agg.max(group, 'precip'),\n   *                 avg: utils.agg.avgMean(group, 'precip')\n   *             }))\n   *     )\n   *     .width(200)\n   *     .encode(\n   *         vl.x().fieldN('city'),\n   *         vl.y().fieldQ('_aggregateValue'),\n   *         vl.color().fieldN('_aggregateKey')\n   * ));\n   * ```\n   * \n   * ![Screenshot of reduce with chart](img/aggregateReduceSeparateChart.png)\n   * \n   * @param {Function} reduceFn - (collection, props) => {Object} - Function that reduces the collection to an object\n   * @param {Array} reduceFn.collection - the collection of records in the group\n   * @param {Object} reduceFn.collectionProps - the properties and values the collection was grouped by\n   * @returns {Array}\n   * @see {@link SourceMap#reduce|reduce()} - for a compact object with multiple aggregate values, useful for tables\n   * @example\n   * utils.group.by(weather, 'city')\n   *   .reduceSeparate((group) => ({\n   *     min: utils.agg.min(group, 'precip'),\n   *     max: utils.agg.max(group, 'precip'),\n   *     avg: utils.agg.avgMean(group, 'precip')\n   *   }));\n   * \n   * //-- results\n   * [\n   *   { city: 'Seattle', _aggregateKey: 'min', _aggregateValue: 0.87 },\n   *   { city: 'Seattle', _aggregateKey: 'max', _aggregateValue: 5.31 },\n   *   { city: 'Seattle', _aggregateKey: 'avg', _aggregateValue: 2.953 },\n   *   { city: 'New York', _aggregateKey: 'min', _aggregateValue: 3.58 },\n   *   { city: 'New York', _aggregateKey: 'max', _aggregateValue: 4.13 },\n   *   { city: 'New York', _aggregateKey: 'avg', _aggregateValue: 3.883 },\n   *   { city: 'Chicago', _aggregateKey: 'min', _aggregateValue: 2.56 },\n   *   { city: 'Chicago', _aggregateKey: 'max', _aggregateValue: 3.98 },\n   *   { city: 'Chicago', _aggregateKey: 'avg', _aggregateValue: 3.387 }\n   * ]\n   */\n  reduceSeparate(reduceFn) {\n    return SourceMap.reduceGroupSeparate(this, reduceFn, {});\n  }\n\n  /**\n   * Reduces, but puts each aggregate value on a separate record.\n   * \n   * This is particularly useful for charting vega, as series must be on separate objects.\n   * \n   * ```\n   * utils.vega.svg((vl) => vl.markLine()\n   *     .data(\n   *         utils.group.by(weather, 'city')\n   *             .reduceSeparate((group) => ({\n   *                 min: utils.agg.min(group, 'precip'),\n   *                 max: utils.agg.max(group, 'precip'),\n   *                 avg: utils.agg.avgMean(group, 'precip')\n   *             }))\n   *     )\n   *     .width(200)\n   *     .encode(\n   *         vl.x().fieldN('city'),\n   *         vl.y().fieldQ('_aggregateValue'),\n   *         vl.color().fieldN('_aggregateKey')\n   * ));\n   * ```\n   * \n   * ![Screenshot of reduce with chart](img/aggregateReduceSeparateChart.png)\n   * \n   * @param {SourceMap} sourceMap -\n   * @param {Function} reduceFn - (collection, props) => {Object} - Function that reduces the collection to an object\n   * @param {Array} reduceFn.collection - the collection of records in the group\n   * @param {Object} reduceFn.collectionProps - the properties and values the collection was grouped by\n   * @param {Object} currentObj - values to inject into the results\n   * @returns {Array}\n   * @see {@link SourceMap#reduce|reduceSeparate()} - to call this method from an instance\n   * @private\n   * @example\n   * utils.group.by(weather, 'city')\n   *   .reduceSeparate((group) => ({\n   *     min: utils.agg.min(group, 'precip'),\n   *     max: utils.agg.max(group, 'precip'),\n   *     avg: utils.agg.avgMean(group, 'precip')\n   *   }));\n   * \n   * //-- results\n   * [\n   *   { city: 'Seattle', _aggregateKey: 'min', _aggregateValue: 0.87 },\n   *   { city: 'Seattle', _aggregateKey: 'max', _aggregateValue: 5.31 },\n   *   { city: 'Seattle', _aggregateKey: 'avg', _aggregateValue: 2.953 },\n   *   { city: 'New York', _aggregateKey: 'min', _aggregateValue: 3.58 },\n   *   { city: 'New York', _aggregateKey: 'max', _aggregateValue: 4.13 },\n   *   { city: 'New York', _aggregateKey: 'avg', _aggregateValue: 3.883 },\n   *   { city: 'Chicago', _aggregateKey: 'min', _aggregateValue: 2.56 },\n   *   { city: 'Chicago', _aggregateKey: 'max', _aggregateValue: 3.98 },\n   *   { city: 'Chicago', _aggregateKey: 'avg', _aggregateValue: 3.387 }\n   * ]\n   */\n  static reduceGroupSeparate = (sourceMap, reduceFn, currentObj = {}) => {\n    if (sourceMap instanceof SourceMap) {\n      //console.log('found sourceMap');\n      const results = Array.from(sourceMap.entries()).flatMap(([key, values]) => SourceMap.reduceGroupSeparate(values, reduceFn, addObjectProperty(currentObj, sourceMap.source, key)));\n      // console.log('sourceMapResults: ' + JSON.stringify(results));\n      return results;\n    } else if (!Array.isArray(sourceMap)) {\n      throw Error('reduceGroups only works on arrays or sourceMaps');\n    }\n    const results = Object.entries(reduceFn(sourceMap, currentObj)).map(([_aggregateKey, _aggregateValue]) => ({\n      ...currentObj,\n      _aggregateKey,\n      _aggregateValue\n    }));\n    // console.log('array results: ' + JSON.stringify(results));\n    return results;\n  };\n\n  /**\n   * Convenience function for reduceGroup.\n   * \n   * Instead of providing a function to reduce, provide an object\n   * \n   * @param {SourceMap} sourceMap - source to be reduced by group\n   * @param {Object} obj - each property as {(collection) => result}\n   * @returns {Array} - Array of objects merged with the parent group attributes and reduceFn result\n   * @see SourceMap.reduceGroup\n   * @deprecated - not as much of a convenience, and causes confusion\n   * @private\n   * @example\n   * collection = [\n   *   { id: 1, city: 'Seattle',  month: 'Aug', precip: 0.87 },\n   *   { id: 0, city: 'Seattle',  month: 'Apr', precip: 2.68 },\n   *   { id: 3, city: 'New York', month: 'Apr', precip: 3.94 },\n   *   { id: 4, city: 'New York', month: 'Aug', precip: 4.13 }\n   * ];\n   * \n   * //-- provides\n   * [\n   *   { city: 'Seattle', month: 'Aug', precipitation: 0.87, numReports: 1 },\n   *   { city: 'Seattle', month: 'Apr', precipitation: 2.68, numReports: 1 },\n   *   { city: 'New York', month: 'Apr', precipitation: 3.94, numReports: 1 },\n   *   { city: 'New York', month: 'Aug', precipitation: 4.13, numReports: 1 }\n   * ]\n   */\n  objectReduce(reductionObject) {\n    return SourceMap.objectReduce(this, reductionObject);\n  }\n\n  /**\n   * Convenience function for reduceGroup.\n   * \n   * Instead of providing a function to reduce, provide an object\n   * \n   * @param {SourceMap} sourceMap - source to be reduced by group\n   * @param {Object} obj - each property as {(collection) => result}\n   * @returns {Array} - Array of objects merged with the parent group attributes and reduceFn result\n   * @see SourceMap.reduceGroup\n   * @deprecated - not as much of a convenience, and causes confusion\n   * @private\n   * @example\n   * collection = [\n   *   { id: 1, city: 'Seattle',  month: 'Aug', precip: 0.87 },\n   *   { id: 0, city: 'Seattle',  month: 'Apr', precip: 2.68 },\n   *   { id: 3, city: 'New York', month: 'Apr', precip: 3.94 },\n   *   { id: 4, city: 'New York', month: 'Aug', precip: 4.13 }\n   * ];\n   * \n   * //-- provides\n   * [\n   *   { city: 'Seattle', month: 'Aug', precipitation: 0.87, numReports: 1 },\n   *   { city: 'Seattle', month: 'Apr', precipitation: 2.68, numReports: 1 },\n   *   { city: 'New York', month: 'Apr', precipitation: 3.94, numReports: 1 },\n   *   { city: 'New York', month: 'Aug', precipitation: 4.13, numReports: 1 }\n   * ]\n   */\n  static objectReduce(sourceMap, obj) {\n    if (typeof obj !== 'object') {\n      throw Error('reducerObject: Expecting an object as the argument');\n    }\n    const entities = Object.entries(obj).filter(([key, val]) => {\n      if (typeof val === 'function') {\n        return true;\n      }\n      throw Error('generateObjectFn: all properties should be {(collection) => result}');\n    });\n    const reduceFn = collection => Object.fromEntries(entities.map(([key, fn]) => [key, fn(collection)]));\n    return SourceMap.reduceGroup(sourceMap, reduceFn);\n  }\n\n  /**\n   * Maps a collection within the sourceMap by a function.\n   * \n   * Note that this only maps the leaf collection of values, not the intermediary levels.\n   * \n   * This can be useful from everything from:\n   * * sorting the leaf collections,\n   * * filtering the results to only those that meet certain criteria,\n   * * to an alternative form of reducing the values,\n   * * or even combinations of the three or more:\n   * \n   * @param {Function} mapFn - {(array) => any} Function to apply to the leaf collections (arrays)\n   * @param {Array} mapFn.collection - the collection of records in the group\n   * @param {Object} mapFn.collectionProps - the properties and values the collection was grouped by\n   * @returns {SourceMap} - New SourceMap with the leaf collections updated to the results from mapFn\n   * \n   * @example\n   * const data = [\n   * weather = [\n   *   { id: 1, city: 'Seattle',  month: 'Aug', precip: 0.87, dateTime: new Date(2020, 7, 1)  , year: 2020},\n   *   { id: 2, city: 'Seattle',  month: 'Dec', precip: 5.31, dateTime: new Date(2020, 11, 1) , year: 2020},\n   *   { id: 0, city: 'Seattle',  month: 'Apr', precip: 2.68, dateTime: new Date(2021, 3, 1)  , year: 2021},\n   *   { id: 4, city: 'New York', month: 'Aug', precip: 4.13, dateTime: new Date(2020, 7, 1)  , year: 2020},\n   *   { id: 5, city: 'New York', month: 'Dec', precip: 3.58, dateTime: new Date(2020, 11, 1) , year: 2020},\n   *   { id: 3, city: 'New York', month: 'Apr', precip: 3.94, dateTime: new Date(2021, 3, 1)  , year: 2021},\n   *   { id: 7, city: 'Chicago',  month: 'Aug', precip: 3.98, dateTime: new Date(2020, 7, 1)  , year: 2020},\n   *   { id: 8, city: 'Chicago',  month: 'Dec', precip: 2.56, dateTime: new Date(2020, 11, 1) , year: 2020},\n   *   { id: 6, city: 'Chicago',  month: 'Apr', precip: 3.62, dateTime: new Date(2021, 3, 1)  , year: 2021}\n   * ];\n   * \n   * utils.group.by(weather, 'city')\n   *   .map(collection => collection.length);\n   * \n   * // SourceMap(3) [Map] {\n   * //   'Seattle' => 3,\n   * //   'New York' => 3,\n   * //   'Chicago' => 3,\n   * //   source: 'city'\n   * // }\n   * \n   * utils.group.by(weather, 'city')\n   *     .map(collection => collection.filter(r => r.year === 2020))\n   *     .map(collection => collection.length);\n   * \n   * // SourceMap(3) [Map] {\n   * //   'Seattle' => 2,\n   * //   'New York' => 2,\n   * //   'Chicago' => 2,\n   * //   source: 'city'\n   * // }\n   */\n  map(mapFn) {\n    return SourceMap.mapCollection(this, mapFn);\n  }\n\n  /**\n   * Implementatin for map.\n   * @private\n   */\n  static mapCollection(sourceMap, mapFn, currentObj = {}) {\n    const result = new SourceMap();\n    result.source = sourceMap.source;\n    for (const [key, value] of sourceMap.entries()) {\n      if (value instanceof Map) {\n        result.set(key, SourceMap.mapCollection(value, mapFn, addObjectProperty(currentObj, result.source, key)));\n      } else {\n        result.set(key, mapFn(value, currentObj));\n      }\n    }\n    return result;\n  }\n}\nmodule.exports = SourceMap;\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./src/SourceMap.js?");

/***/ }),

/***/ "./src/TableGenerator.js":
/*!*******************************!*\
  !*** ./src/TableGenerator.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint-disable\n  prefer-template,\n  function-paren-newline,\n  implicit-arrow-linebreak,\n  arrow-body-style\n*/\n\n//-- TODO: review stringbuilder for large datasets\n\n//-- review the api from observable\n//-- https://observablehq.com/@observablehq/input-table\n\nconst {\n  printValue\n} = __webpack_require__(/*! ./format */ \"./src/format.js\");\n\n// const generateRange = (length, defaultValue) => new Array(length).fill(defaultValue);\n\nconst IJSUtils = __webpack_require__(/*! ./ijs */ \"./src/ijs.js\");\nconst ArrayUtils = __webpack_require__(/*! ./array */ \"./src/array.js\");\nconst FormatUtils = __webpack_require__(/*! ./format */ \"./src/format.js\");\nconst ObjectUtils = __webpack_require__(/*! ./object */ \"./src/object.js\");\nconst {\n  createSort\n} = __webpack_require__(/*! ./array */ \"./src/array.js\");\n\n/**\n * Generates and or Renders Tables (Markdown, CSS, HTML, or plain arrays)\n * \n * NOTE: `utils.table(...)` is the same as `new utils.TableGenerator(...)`\n * \n * For example:\n * \n * ```\n * utils.datasets.fetch('cars.json').then(results => cars = results);\n * ```\n * \n * ```\n * utils.table(cars)\n *    .limit(2)\n *    .render();\n * ```\n * \n * ![Screenshot of simple example](img/TableGenerator_simple.png)\n * \n * ```\n * //-- with many options to tailor and format the table\n * \n * utils.table(cars)\n * \n *    //-- sort by year field (descending), Displacement (descending), Name (ascending)\n *    .sort('-Year', '-Displacement', 'Name')\n *    \n *    //-- limit to only the first 10 records\n *    .limit(10)\n *    \n *    //-- add in a new field / column called Kilometer_per_Litre\n *    .augment({\n *         'Kilometer_per_Litre': (row) => row.Miles_per_Gallon * 0.425144\n *    })\n * \n *    //-- specify the columns to show by list of fields\n *    .columns('Name', 'Kilometer_per_Litre', 'Cylinders', 'Displacement', 'Acceleration', 'Year')\n * \n *    //-- format how a field / column is rendered by ({ property: fn })\n *    .format({\n *        Year: (value) => value ? value.slice(0,4) : value\n *    })\n * \n *    //-- make specific column headers more legible with ({ property: header })\n *    .labels({\n *        'Kilometer_per_Litre': 'Km/L'\n *    })\n * \n *    //-- high light rows and cells based on data\n *    .styleColumn({\n *      \"Km/L\": (value) => value > 10 ? 'background-color: #AAFFAA' : ''\n *    })\n *    .styleRow(({record}) => record.Name.includes('diesel')\n *             ? 'color: green;' : ''\n *    )\n * \n *    .render()\n * ```\n * \n * ![Screenshot of complex example](img/TableGenerator_complex.png)\n * \n * Note that sticky headers are available when using the {@link TableGenerator#render|render()} method.\n * By default, it sets the height to `50vh` - but this can be configured through {@link TableGenerator#height|height()}.\n * \n * ```\n * utils.table(cars)\n *   .height('300px')\n *   .render();\n * ```\n * \n * ![Screenshot of sticky headers](img/renderTableFrozenHeaders.jpg)\n * \n * ```\n * //-- note, `utils.table(...)`\n * //-- is the same as `new utils.TableGenerator(...)`\n * //-- and now available as of `1.12.0`\n * ```\n * \n * # Types of calls:\n * \n * * constructor\n *   * {@link TableGenerator#constructor|new TableGenerator(object[])} - create with data\n * * change the columns and headers\n *   * {@link TableGenerator#columns|columns(field, field, ...)} - specify fields and order\n *   * {@link TableGenerator#columnsToExclude|columnsToExclude(field, ...)} - specify fields not to show\n *   * {@link TableGenerator#labels|lables(obj)} - labels for field headers\n * * augment and change the values (non-destructively)\n *   * {@link TableGenerator#format|format(obj)} - adjust values of specific fields\n *   * {@link TableGenerator#formatterFn|formatterFn(fn)} - row, column aware adjustment\n *   * {@link TableGenerator#printOptions|printOptions(object)} - options for value rendering\n *   * {@link TableGenerator#augment|augment(obj)} - add fields to table\n * * sort and limit the output\n *   * {@link TableGenerator#filter|filter(fn)} - determine which rows to include or not\n *   * {@link TableGenerator#limit|limit(number)} - limit only specific # of rows\n *   * {@link TableGenerator#offset|offset(number)} - starts results only after an offset number of rows\n *   * {@link TableGenerator#sortFn|sortFn(fn)} - Standard Array sort function\n *   * {@link TableGenerator#sort|sort(field, field, ...)} - sorts by fields, or descending with '-'\n * * transpose the output\n *   * {@link TableGenerator#transpose|transpose()} - transposes the output prior to rendering\n * * style the table\n *   * {@link TableGenerator#styleTable|styleTable(string)} - css style for the table\n *   * {@link TableGenerator#styleHeader|styleHeader(string)} - css styles for the header row\n *   * {@link TableGenerator#styleColumn|styleColumn(object)} - Function to style cells based on the column\n *   * {@link TableGenerator#styleRow|styleRow(fn)} - Function to style rows\n *   * {@link TableGenerator#styleCell|styleCell(fn)} - Function to style cells\n *   * {@link TableGenerator#border|border(string)} - Apply a border to the table data cells\n *   * {@link TableGenerator#height|height(cssString)} - set the height of the table (defaults to 50vh)\n * * generate output\n *   * {@link TableGenerator#generateHTML|generateHTML()} - returns html table with the results\n *   * {@link TableGenerator#generateMarkdown|generateMarkdown()} - returns markdown with the results\n *   * {@link TableGenerator#generateCSV|generateCSV()} - generates a CSV with the results\n *   * {@link TableGenerator#generateCSV|generateCSV()} - generates a TSV with the results\n *   * {@link TableGenerator#generateArray|generateArray()} - generates an array of headers and data for further process\n *   * {@link TableGenerator#generateArray2|generateArray2()} - generates a single array for further process\n * * render in jupyter\n *   * {@link TableGenerator#render|render()} - renders the results in a table within jupyter\n *   * {@link TableGenerator#renderCSV|renderCSV()} - renders the generateCSV results in a table within jupyter\n *   * {@link TableGenerator#renderTSV|renderTSV()} - renders the generateTSV results in a table within jupyter\n *   * {@link TableGenerator#renderMarkdown|renderMarkdown()} - renders the generateMarkdown results in a table within jupyter\n * \n */\nclass TableGenerator {\n  /**\n   * Collection of data\n   * @type {Array}\n   */\n  #data = [];\n\n  /**\n   * Augment Function to append new fields\n   * @type {Function}\n   */\n  #augmentFn = null;\n\n  /**\n   * Border CSS to also apply to the cells\n   * @type {String}\n   */\n  #borderCSS = ''; // 'solid 1px #AAA';\n\n  /**\n   * Optional array of exclusive columns to show based on the properties of each row\\n\n   * ex: ['Miles_per_Gallon', 'Name', 'Cylinders', etc]\n   * @type {String[]}\n   **/\n  #columns = null;\n\n  /**\n   * Optional array of columns to not show based on the properties of the row\\n\n   * ex: ['Serial_number']\n   * @type {String[]}\n   **/\n  #columnsToExclude = [];\n\n  /**\n   * Map of key:value pairs, where the key is the property and value is dot notation access\n   * (accessing children should use map).\n   * This will always be accessed before any other action.\n   * ex: {parentName:'child.parent.parent.name'}\n   * @type {Object}\n   */\n  #fetch = null;\n\n  /**\n   * Function used to determine which rows to include\n   * @type {Function}\n   */\n  #filterFn = null;\n\n  /**\n   * Function to transform the value for a specific cell\n   * @type {Function}\n   */\n  #formatterFn = null;\n\n  /**\n   * Max height (css) of the table when rendered. (Defaults to 50vh)\n   * @type {String}\n   */\n  #height = '50vh';\n\n  /**\n   * Optional labels for columns by the property Name\n   * ex: {Miles_per_Gallon:'Miles per Gallon'} or {0:'Miles per Gallon'} for arrays\n   * @type {Object}\n   **/\n  #labels = {};\n\n  /**\n   * The number of rows to limit.\n   * \n   * 10 : means ascending 10 records.\n   * \n   * -10 : means descending 10 records\n   * @type {Number}\n   */\n  #limit = 0;\n\n  /**\n   * The number of rows to skip before showing results.\n   * \n   * 10 : means start showing results only after the first 10 records\n   * \n   * -10 : means only show the last 10\n   * \n   * @type {Number}\n   */\n  #offset = 0;\n\n  /**\n   * PrintValue options to use when rendering the table values\n   * @type {PrintOptions}\n   **/\n  #printOptions = null;\n\n  /**\n   * Sorting function\n   * \n   * @example utils.array.createSort('index')\n   * \n   * @type {Function}\n   **/\n  #sortFn = null;\n\n  /**\n   * Style to apply at the table\n   * @type {String}\n   */\n  #styleTable = '';\n\n  /**\n   * Style to apply to all the headers\n   * @type {String}\n   */\n  #styleHeader = '';\n\n  /**\n   * Style to apply at the row\n   * @type {Function}\n   */\n  #styleRow = null;\n\n  /**\n   * Style to apply at the column level\n   * @type {Function}\n   */\n  #styleColumn = null;\n\n  /**\n   * Style to apply at the cell\n   * @type {Function}\n   */\n  #styleCell = null;\n\n  /**\n   * Whether the data should be output transposed\n   * @type {Boolean}\n   */\n  #isTransposed = false;\n\n  /**\n   * Function to format a value for a cell\n   * \n   * @example\n   * \n   * data = [{temp: 37, type: 'C'}, {temp: 310, type: 'K'}, {temp: 98, type: 'F'}];\n   * \n   * //-- simple example where the temp property is converted, and type property overwritten\n   * new TableGenerator(data)\n   *  .generateMarkdown()\n   * \n   * //-- gives\n   * temp | type\n   * ---- | ----\n   * 37   | C   \n   * 310  | K   \n   * 98   | F   \n   * \n   * @param {Object[]} - collection of objects\n   */\n  constructor(data) {\n    this.reset();\n    if (data) {\n      this.data(data);\n    }\n  }\n\n  /**\n   * Resets the generator\n   */\n  reset() {\n    this.#data = [];\n    this.#augmentFn = null;\n    this.#borderCSS = '';\n    this.#columns = null;\n    this.#columnsToExclude = [];\n    this.#fetch = null;\n    this.#filterFn = null;\n    this.#formatterFn = null;\n    this.#height = '50vh';\n    this.#labels = {};\n    this.#limit = 0;\n    this.#offset = 0;\n    this.#printOptions = null;\n    this.#sortFn = null;\n    this.#styleTable = '';\n    this.#styleHeader = '';\n    this.#styleRow = null;\n    this.#styleColumn = null;\n    this.#styleCell = null;\n    this.#isTransposed = false;\n  }\n\n  //--    GETTER SETTERS\n\n  /**\n   * Assigns the data to be used in generating the table.\n   * @param {Array} collection -\n   * @returns {TableGenerator} - chainable instance\n   * @see #constructor\n   * @example\n   * \n   * dataSet = [{temp: 37, type: 'C'}, {temp: 310, type: 'K'}, {temp: 98, type: 'F'}];\n   * \n   * //-- simple example where the temp property is converted, and type property overwritten\n   * new TableGenerator()\n   *  .data(dataSet)\n   *  .generateMarkdown()\n   * \n   * //-- gives\n   * temp | type\n   * ---- | ----\n   * 37   | C   \n   * 310  | K   \n   * 98   | F   \n   */\n  data(col) {\n    this.#data = col || [];\n    return this;\n  }\n\n  /**\n   * Augments data with additional fields\n   * \n   * (Convenience function to add additional values without augmenting the data.)\n   * \n   * Note that doing a `.map()` on the dataset prior may have better performance\n   * but doing so may modify the dataset - where this would not.\n   * \n   * @example\n   * \n   * sourceData = [{id: 1, temp_F:98}, {id: 2, temp_F:99}, {id: 3, temp_F:100}];\n   * \n   * utils.table(sourceData)\n   *  .augment({\n   *    temp_C: (row) => (row.temp_F - 32) * 0.5556,\n   *    temp_K: (row) => (row.temp_F - 32) * 0.5556 + 1000\n   *  })\n   *  .generateMarkdown()\n   * \n   * //-- provides:\n   * \n   * id | temp_F | temp_C | temp_K\n   * -- | ------ | ------ | ------\n   * 1  | 98     | 36.667 | 309.817\n   * 2  | 99     | 37.222 | 310.372\n   * 3  | 100    | 37.778 | 310.928\n   * \n   * @param {Object} obj - Object with properties to add to the result data\n   * @param {Function} obj.newProperty - Function per property to add\n   * @param {Object} obj.newProperty.record - Each record within data\n   * \n   * @returns {TableGenerator} - chainable instance\n   */\n  augment(obj) {\n    if (!obj) {\n      this.#augmentFn = null;\n      return this;\n    }\n    const augmentKeys = Object.getOwnPropertyNames(obj);\n    augmentKeys.forEach(key => {\n      if (typeof obj[key] !== 'function') {\n        throw Error(`Formatter properties must be functions. [${key}]`);\n      }\n    });\n    this.#augmentFn = record => {\n      const newRecord = {\n        ...record\n      };\n      augmentKeys.forEach(key => {\n        newRecord[key] = obj[key](record);\n      });\n      return newRecord;\n    };\n    return this;\n  }\n\n  /**\n   * Convenience function to set an a border on the Data Cells.\n   * \n   * This only applies when {@link TableGenerator#render|rendering HTML}\n   * or {@link TableGenerator#generateHTML|generating HTML}\n   * \n   * As this adds additional CSS, the styling applied:\n   *   * {@link TableGenerator#styleTable|to the whole table}\n   *   * or {@link TableGenerator#styleRow|to the rows}\n   *   * or {@link TableGenerator#styleColumn|to the column}\n   *   * or {@link TableGenerator#styleCell|to the data cells} will be affected\n   * \n   * For example:\n   * \n   * ```\n   * sourceData = [{id: 1, temp_F:98}, {id: 2, temp_F:99}, {id: 3, temp_F:100}];\n   * \n   * utils.table(sourceData)\n   *    .border('1px solid #aaa')\n   *    .render();\n   * ```\n   * \n   * <table cellspacing=\"0px\" >\n   * <tr >\n   *   <th>id</th>\n   *   <th>temp_F</th>\n   * </tr>\n   * <tr >\n   *   <td style=\" border: 1px solid #aaa\">1</td>\n   *   <td style=\" border: 1px solid #aaa\">98</td>\n   * </tr>\n   * <tr >\n   *   <td style=\" border: 1px solid #aaa\">2</td>\n   *   <td style=\" border: 1px solid #aaa\">99</td>\n   * </tr>\n   * <tr >\n   *   <td style=\" border: 1px solid #aaa\">3</td>\n   *   <td style=\" border: 1px solid #aaa\">100</td>\n   * </tr>\n   * </table>\n   * \n   * @param {String | Boolean} borderCSS - CSS String to additionally apply HTML TD elements\n   */\n  border(borderCSS) {\n    let cleanCSS = '';\n    if (borderCSS === true) {\n      cleanCSS = 'border: 1px solid #aaa';\n    } else if (borderCSS) {\n      cleanCSS = `border: ${borderCSS}`;\n    }\n    this.#borderCSS = cleanCSS;\n    return this;\n  }\n\n  /**\n   * Applies an optional set of columns / properties to render\n   * \n   * @param {String[]} values - Optional array of exclusive fields to render\\n\n   *    If not provided, then all fields are rendered.\\n\n   *    If provided, then only the fields listed will be rendered\\n\n   * @returns {TableGenerator} - chainable instance\n   * @example\n   * \n   * dataSet = [{reg:'z', source: 'A', temp: 99},\n   *    {reg: 'z', source: 'B', temp: 98},\n   *    {reg: 'z', source:'A', temp: 100}\n   * ];\n   * \n   * //-- only show the temp and source columns\n   * new TableGenerator(dataSet)\n   *  .columns('temp', 'source') // or .columns(['temp', 'source'])\n   *  .generateMarkdown();\n   * \n   * //-- provides\n   * \n   * temp | source\n   * ---- | ------\n   * 99   | A\n   * 98   | B\n   * 100  | A\n   **/\n  columns(values, ...rest) {\n    //-- make safer because I keep making this mistake.\n    if (typeof values === 'string') {\n      this.#columns = [values, ...rest];\n    } else if (Array.isArray(values)) {\n      this.#columns = values;\n    } else {\n      throw new Error('columns expects array of strings');\n    }\n    return this;\n  }\n\n  /**\n   * Applies an optional set of columns / properties not to render\n   * \n   * @param {String[]} values - Optional array of columns not to render\\n\n   *    If not provided, then all fields are rendered.\\n\n   *    If provided, then these fields will not be rendered under any circumstance.\\n\n   * @returns {TableGenerator} - chainable instance\n   * @example\n   * \n   * dataSet = [{reg:'z', source: 'A', temp: 99},\n   *    {reg: 'z', source: 'B', temp: 98},\n   *    {reg: 'z', source:'A', temp: 100}\n   * ];\n   * \n   * //-- only show the temp and source columns\n   * new TableGenerator(dataSet)\n   *  .columnsToExclude('reg') // or .columnsToExclude(['reg'])\n   *  .generateMarkdown();\n   * \n   * //-- provides\n   * \n   * temp | source\n   * ---- | ------\n   * 99   | A\n   * 98   | B\n   * 100  | A\n   **/\n  columnsToExclude(values, ...rest) {\n    //-- make safer because I keep making this mistake.\n    if (typeof values === 'string') {\n      this.#columnsToExclude = [values, ...rest];\n    } else if (Array.isArray(values)) {\n      this.#columnsToExclude = values;\n    } else {\n      throw new Error('columns to exclude expects array of strings');\n    }\n    return this;\n  }\n\n  /**\n   * Filter the dataset\n   * \n   * (This is a alternative to calling `.filter()` on the source data)\n   * \n   * For example:\n   * \n   * ```\n   * data = [{temp: 98, type: 'F'}, {temp: 37, type: 'C'}, {temp: 309, type: 'K'}];\n   * \n   * //-- simple example where the temp property is converted, and type property overwritten\n   * new TableGenerator(data)\n   *  .filter((row) => row.type === 'C')\n   *  .generateMarkdown()\n   * \n   * //-- gives\n   * temp | type\n   * ---- | ----\n   * 37   | C   \n   * ```\n   * \n   * @param {Function} filterFn - A function that returns `true` to include the row in output\n   * @param {Object} filterFn.row - a record from within `data`\n   * \n   * @returns {TableGenerator}\n   */\n  filter(filterFn) {\n    this.#filterFn = filterFn;\n    return this;\n  }\n\n  /**\n   * Object that provides translations functions for matching properties.\n   * \n   * (This is an alternate to {@link formatterFn} or simple `.map()` call on the source data)\n   * \n   * **NOTE: Only matching properties on the formatter object are changed - all others are left alone.**\n   * \n   * For example:\n   * \n   * ```\n   * data = [\n   *   {station: 'A', temp: 98, type: 'F', descr: '0123'},\n   *   {station: 'A', temp: 99, type: 'F', descr: '0123456'},\n   *   {station: 'A', temp: 100, type: 'F', descr: '0123456789'}\n   * ];\n   * \n   * //-- simple example where the temp property is converted, and type property overwritten\n   * new TableGenerator(data)\n   *  .format({\n   *    //-- property 'station' not mentioned, so no change\n   *    \n   *    //-- convert temperature to celsius\n   *    temp: (value) => (value - 32) * 0.5556,\n   *    //-- overwrite type from 'F' to 'C'\n   *    type: 'C',\n   *    //-- ellipsify to shorten the description string, if longer than 8 characters\n   *    descr: (str) => utils.format.ellipsify(str, 8)\n   *  }).renderMarkdown()\n   * ```\n   * \n   * station|temp  |type|descr    \n   * --     |--    |--  |--       \n   * A      |36.67 |F   |0123     \n   * A      |37.225|F   |0123456  \n   * A      |37.781|F   |01234567â€¦\n   * \n   * Note, due to frequent requests, simple datatype conversions can be requested.\n   * \n   * Only ('String', 'Number', and 'Boolean') are supported\n   * \n   * ```\n   * data = [\n   *   { propA: ' 8009', propB: 8009, isBoolean: 0},\n   *   { propA: ' 92032', propB: 92032, isBoolean: 1},\n   *   { propA: ' 234234', propB: 234234, isBoolean: 1},\n   * ];\n   * \n   * utils.table(data)\n   *   .format({\n   *     //-- convert Prop A to Number - so render with Locale Number Formatting\n   *     propA: 'number',\n   *     //-- conver PropB to String - so render without Locale Number Formatting\n   *     propB: 'string',\n   *     //-- render 'True' or 'False'\n   *     isBoolean: 'boolean'\n   *   }).renderMarkdown();\n   * ```\n   * \n   * propA|propB|isBoolean\n   * --                  |--                |--       \n   * 8,009               |8009              |false    \n   * 92,032              |92032             |true     \n   * 234,234             |234234            |true \n   * \n   * @param {Object} obj - object with properties storing arrow functions\n   * @param {Function} obj.PropertyToTranslate - (value) => result\n   * \n   * @returns {TableGenerator}\n   */\n  format(obj) {\n    if (!obj) {\n      this.#formatterFn = null;\n      return this;\n    }\n    const cleanedFormatter = FormatUtils.prepareFormatterObject(obj);\n    const fnMap = new Map();\n    Object.getOwnPropertyNames(cleanedFormatter).forEach(key => {\n      fnMap.set(key, cleanedFormatter[key]);\n    });\n    this.#formatterFn = ({\n      value,\n      property\n    }) => fnMap.has(property) ? fnMap.get(property)(value) : value;\n    return this;\n  }\n\n  /**\n   * Legacy version of {@link TableGenerator#format|format}\n   * @private\n   * @param {Object} obj - object with properties storing arrow functions\n   * @param {Function} obj.PropertyToTranslate - (value) => result\n   * \n   * @returns {TableGenerator}\n   */\n  formatter(obj) {\n    return this.format(obj);\n  }\n\n  /**\n   * Function that can format a value for a given row, cell\n   * \n   * (value, cellIndex, header, rowIndex, row, record) => string\n   * \n   * @param {function(*):any} fn - Translation function to apply to all cells.\n   * \n   * When it runs, you will recieve a single parameter representing the current cell and row.\n   * \n   * Return what the new value should be.\n   * @param {any}    fn.value - destructured value of the cell\n   * @param {Number} fn.columnIndex - destructured 0 index column of the cell\n   * @param {String} fn.property - destructured property used for that column\n   * @param {Number} fn.rowIndex - destructured 0 index row of the cell\n   * @param {Array}  fn.record - destructured original record\n   * @see {@link TableGenerator#format|format(obj)} to format per property of the objects\n   * \n   * @returns {TableGenerator}\n   */\n  formatterFn(fn) {\n    this.#formatterFn = fn;\n    return this;\n  }\n\n  /**\n   * Set the css max-height of the table when calling `render`. (Not used in generating html)\n   * \n   * Defaults to '50vh' unless updated here.\n   * \n   * @param {String} maxHeightCSS - css to apply when rendering the table in html\n   * @returns {TableGenerator}\n   */\n  height(maxHeightCSS) {\n    this.#height = maxHeightCSS;\n    return this;\n  }\n\n  /**\n   * The number of rows to limit.\n   * \n   * 10 : means ascending 10 records.\n   * \n   * -10 : means descending 10 records\n   * \n   * @param {Number} limitRecords - 0 for all records, + for ascending, - for descending\n   * @return {TableGenerator} - chainable interface\n   */\n  limit(limitRecords) {\n    this.#limit = limitRecords;\n    return this;\n  }\n\n  /**\n   * The number of rows to skip before showing any records.\n   * \n   * 10 : means start showing results only after the first 10 records\n   * \n   * -10 : means only show the last 10\n   * \n   * @param {Number} offsetRecords - the number of rows to skip \n   * @returns {TableGenerator} - chainable interface\n   */\n  offset(offsetRecords) {\n    this.#offset = offsetRecords;\n    return this;\n  }\n\n  /**\n   * Sets the alternative labels to be used for specific fields.\n   * \n   * single object with properties that should show a different label\\n\n   *  \n   * @example\n   * \n   * dataSet = [{source: 'A', temp: 99},\n   *    {source: 'B', temp: 98},\n   *    {source:'A', temp: 100}\n   * ];\n   * \n   * //-- only show the temp and source columns\n   * new TableGenerator(dataSet)\n   *  .lables({ temp: 'temperature})\n   *  .generateMarkdown();\n   * \n   * //--\n   * \n   * source | temperature\n   * ------ | -----------\n   * A      | 99\n   * B      | 98\n   * C      | 100\n   * \n   * @param {Object} labelsObj -\n   * @returns {TableGenerator} - chainable instance\n   */\n  labels(labelsObj) {\n    this.#labels = labelsObj;\n    return this;\n  }\n\n  /**\n   * Options to give to printOptions\n   * \n   * @example\n   * \n   * dataSet = [\n   *    {id: 1, dateTime:new Date(2022,3,2,9), child: { results: true }},\n   *    {id: 1, dateTime:new Date(2022,3,3,9), child: { results: false }},\n   *    {id: 1, dateTime:new Date(2022,3,4,9), child: { results: true }}\n   * ];\n   * \n   * console.log(utils.table(dataSet)\n   *     .generateMarkdown({align: true})\n   * )\n   * \n   * //--\n   * \n   * id|dateTime            |child            \n   * --|--                  |--               \n   * 1 |4/2/2022, 9:00:00 AM|{\"results\":true} \n   * 1 |4/3/2022, 9:00:00 AM|{\"results\":false}\n   * 1 |4/4/2022, 9:00:00 AM|{\"results\":true} \n   * \n   * dataSet = [\n   *    {id: 1, dateTime:new Date(2022,3,2,9), child: { results: true }},\n   *    {id: 1, dateTime:new Date(2022,3,3,9), child: { results: false }},\n   *    {id: 1, dateTime:new Date(2022,3,4,9), child: { results: true }}\n   * ];\n   * \n   * console.log(utils.table(dataSet)\n   *     .printOptions({ collapseObjects: true, dateFormat: 'toISOString'})\n   *     .generateMarkdown({align: true})\n   * )\n   * \n   * id|dateTime            |child          \n   * --|--                  |--             \n   * 1 |2022-04-02T14:00:00.000Z|[object Object]\n   * 1 |2022-04-03T14:00:00.000Z|[object Object]\n   * 1 |2022-04-04T14:00:00.000Z|[object Object]\n   * \n   * @param {any} value - the value to print\n   * @param {Object} options - collection of options\n   * @param {Boolean} options.collapseObjects - if true, typesof Object values are not expanded\n   * @param {String} options.dateFormat - ('LOCAL'|'LOCAL_DATE','LOCAL_TIME','GMT','ISO','UTC','NONE')\n   * \n   * @see module:format.printValue\n   * @returns {TableGenerator} - chainable instance\n   */\n  printOptions(options) {\n    this.#printOptions = options;\n    return this;\n  }\n\n  /**\n   * Applies a [standard array sort function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)\n   * to the data.\n   * \n   * @param {Function} fn - optional sort function\n   * @returns {TableGenerator} - chainable instance\n   * @see module:array.createSort\n   **/\n  sortFn(fn) {\n    this.#sortFn = fn;\n    return this;\n  }\n\n  /**\n   * Convenience function that creates a sort based on properties.\n   * \n   * Sorting always occurs left to right - sort('First', 'Second', etc.)\n   * \n   * NOTE: prefixing a field with `-` will sort it descending.\n   * \n   * @example\n   * \n   * ```\n   * sampleData = [{val: 3}, {val:1}, {val:2}];\n   * new TableGenerator(sampleData)\n   *  //-- sort ascending by the val property\n   *  .sort('val')\n   *  .render();\n   * ```\n   * \n   * @see module:array.createSort\n   */\n  sort(...rest) {\n    return this.sortFn(createSort.apply(this, rest));\n  }\n\n  /** \n   * Defines the style to render on the table\n   * \n   * **Note: this is only used on render / generateHTML currently**\n   * \n   * ```\n   * dataSet = [{reg:'z', source: 'A', temp: 99},\n   *     {reg: 'z', source: 'B', temp: 98},\n   *     {reg: 'z', source:'A', temp: 100}\n   *  ];\n   *  \n   * //-- only show the temp and source columns\n   * utils.table(dataSet)\n   *   .columns('temp', 'source') // or .columns(['temp', 'source'])\n   *   .styleTable('border:1px solid #000')\n   *   .render();\n   * ```\n   * ![Screenshot of styling the table with a border on the outside](img/Table_StyleTable.png)\n   * \n   * @param {String} value - style to apply to the table\n   *    ex: `border: 1px solid black`\n   * @returns {TableGenerator} - chainable instance\n   **/\n  styleTable(value) {\n    this.#styleTable = value;\n    return this;\n  }\n\n  /** \n   * Override the styles for the the header row\n   * \n   * **Note: this is only used on render / generateHTML currently**\n   * \n   * ```\n   * dataSet = [{reg:'z', source: 'A', temp: 99},\n   *     {reg: 'z', source: 'B', temp: 98},\n   *     {reg: 'z', source:'A', temp: 100}\n   *  ];\n   *  \n   * //-- only show the temp and source columns\n   * utils.table(dataSet)\n   *   .columns('temp', 'source') // or .columns(['temp', 'source'])\n   *   .styleHeader('border: 1px solid #000;')\n   *   .render();\n   * ```\n   * ![Screenshot of styling the table with a border on the header](img/Table_StyleHeader.png)\n   * \n   * @param {String} value - style to apply to the table\n   *    ex: `font-weight: bold`\n   * @returns {TableGenerator} - chainable instance\n   **/\n  styleHeader(value) {\n    this.#styleHeader = value;\n    return this;\n  }\n\n  /**\n   * Function that can apply a style to a given row\n   * \n   * (rowIndex, row, record) => string\n   * \n   * ```\n   * dataSet = [{reg:'z', source: 'A', temp: 10},\n   *   {reg: 'z', source: 'B', temp: 98},\n   *   {reg: 'z', source:'A', temp: 100}\n   * ];\n   * \n   * //-- only show the temp and source columns\n   * utils.table(dataSet)\n   *   .columns('temp', 'source') // or .columns(['temp', 'source'])\n   *   .styleRow(({rowIndex, row, record}) => {\n   *     return (record.source === 'A') ? `color: #0A0;` : `color: #A00`;\n   *   })\n   *   .render();\n   * ```\n   * ![Screenshot of styling a row](img/Table_StyleRow.png)\n   * \n   * @param {function(*):any} styleFn - Translation function to apply to all cells.\n   * \n   * When it runs, you will receive a single parameter representing the current cell and row.\n   * \n   * Return what the new value should be.\n   * @param {Number} styleFn.rowIndex - destructured 0 index row of the cell\n   * @param {Array}  styleFn.row - destructured full row provided\n   * @param {Array}  styleFn.record - destructured original record\n   * @returns {TableGenerator} - chainable instance\n   */\n  styleRow(styleFn) {\n    this.#styleRow = styleFn;\n    return this;\n  }\n\n  /**\n   * Function that can apply a style to a given column\n   * \n   * (rowIndex, ({ columnHeader, columnIndex, record, row, rowIndex, value })) => string\n   * \n   * note: see {@link TableGenerator#styleCell} for another way to do style a cell.\n   * \n   * ```\n   * dataSet = [\n   *   {reg: 'z', source: 'A', temp: 10},\n   *   {reg: 'z', source: 'B', temp: 98},\n   *   {reg: 'z', source: 'A', temp: 100}\n   * ];\n   * \n   * utils.table(dataSet)\n   *   .styleColumn({\n   *     //-- we want to make the background color of the color red, if the temp > 50\n   *     temp: (temp) => temp > 50 ? 'background-color:pink' : '',\n   * \n   *     //-- we want to make the source bold if the source is B\n   *     source: (source) => source === 'B' ? 'font-weight:bold' : ''\n   *   })\n   *   .render();\n   * ```\n   * <table cellspacing=\"0px\" >\n   * <tr ><th>reg</th><th>source</th><th>temp</th></tr>\n   * <tr ><td >z</td><td >A</td><td >10</td></tr>\n   * <tr ><td >z</td><td style=\"font-weight:bold;\">B</td><td style=\"background-color:pink;\">98</td></tr>\n   * <tr ><td >z</td><td >A</td><td style=\"background-color:pink;\">100</td></tr>\n   * </table>\n   * \n   * Or you could style the cell based on information in other columns.\n   * \n   * ```\n   * dataSet = [\n   *   {reg: 'z', source: 'A', tempFormat: 'c', temp: 42},\n   *   {reg: 'z', source: 'B', tempFormat: 'f', temp: 98},\n   *   {reg: 'z', source: 'A', tempFormat: 'f', temp: 100}\n   * ];\n   * \n   * utils.table(dataSet)\n   *   .styleColumn({\n   *     //-- we want to make the background color of the color red, if the temp > 50\n   *     temp: (temp, { record }) => convertToKelvin(temp, record.tempFormat) > 283\n   *       ? 'background-color:pink'\n   *       : ''\n   *   })\n   *   .render();\n   * ```\n   * \n   * <table cellspacing=\"0px\" >\n   * <tr ><th>reg</th><th>source</th><th>tempFormat</th><th>temp</th></tr>\n   * <tr ><td >z</td><td >A</td><td >c</td><td style=\"background-color:pink;\">10</td></tr>\n   * <tr ><td >z</td><td >B</td><td >f</td><td style=\"background-color:pink;\">98</td></tr>\n   * <tr ><td >z</td><td >A</td><td >f</td><td style=\"background-color:pink;\">100</td></tr>\n   * </table>\n   * \n   * @param {object} styleObj - object with properties matching the column header label\n   * @param {function(value, contextObj)} styleObj.property - Function to evaluate for each row returning the inline css styles to apply.\n   * \n   * When it runs it will get passed the value and context,\n   * and should return the css inline styles to apply\n   * \n   * @param {any} styleObj.property.value - the value for a given row for that column\n   * @param {any}    styleObj.property.context.value - destructured value of the cell\n   * @param {Number} styleObj.property.context.columnIndex - destructured 0 index column of the cell\n   * @param {Number} styleObj.property.context.rowIndex - destructured 0 index row of the cell\n   * @param {Array}  styleObj.property.context.row - destructured full row provided\n   * @param {Array}  styleObj.property.context.record - destructured original record\n   * @returns {TableGenerator} - chainable instance\n   */\n  styleColumn(styleObj) {\n    if (!styleObj) {\n      this.#styleColumn = null;\n      return this;\n    }\n    if (typeof styleObj !== 'object') {\n      throw Error('styleColumn(styleObj): expects an object with properties matching the column LABELs');\n    }\n    this.#styleColumn = styleObj;\n    return this;\n  }\n\n  /**\n   * Function that can apply a style to a given cell\n   * \n   * (value, columnIndex, rowIndex, row, record) => string\n   * \n   * Note: see {@link TableGenerator#styleColumn} for another way to do style a cell.\n   * \n   * ```\n   * dataSet = [\n   *  { title:'row 0', a: 0.608, b: 0.351, c: 0.823, d: 0.206, e: 0.539 },\n   *  { title:'row 1', a: 0.599, b: 0.182, c: 0.197, d: 0.352, e: 0.338 },\n   *  { title:'row 2', a: 0.275, b: 0.715, c: 0.304, d: 0.482, e: 0.248 },\n   *  { title:'row 3', a: 0.974, b: 0.287, c: 0.323, d: 0.875, e: 0.017 },\n   *  { title:'row 4', a: 0.491, b: 0.479, c: 0.428, d: 0.252, e: 0.288 }\n   * ];\n   * \n   * // color range from Green to Red\n   * colorRange = new utils.svg.svgJS.Color('#0A0').to('#F00');\n   * \n   * //-- only show the temp and source columns\n   * utils.table(dataSet)\n   *   .styleCell(({value, columnIndex, rowIndex, row, record}) => {\n   *     //-- style the color of the cell from Red:0 to Green:1\n   *     // record is the exact record provided to data / the generator\n   *     // row is the array provided to the renderer (which may be re-arranged)\n   *     //   with rowIndex and Column index also relative to the final array\n   *     if (columnIndex >= 1) {\n   *       return `color: ${colorRange.at(value).toHex()}`;\n   *     }\n   *   })\n   *   .render();\n   * ```\n   * ![Screenshot of styling the cell](img/Table_StyleCell.png)\n   * \n   * \n   * When it runs, you will receive a single parameter representing the current cell and row.\n   * \n   * Return what the new value should be.\n   * @param {function(*):any} formatterFn - Translation function to apply to all cells.\n   * @param {any}    formatterFn.value - destructured value of the cell\n   * @param {Number} formatterFn.columnIndex - destructured 0 index column of the cell\n   * @param {Number} formatterFn.columnHeader - destructured header of the column\n   * @param {Number} formatterFn.rowIndex - destructured 0 index row of the cell\n   * @param {Array}  formatterFn.row - destructured full row provided\n   * @param {Array}  formatterFn.record - destructured original record\n   * @returns {TableGenerator}\n   */\n  styleCell(styleFn) {\n    this.#styleCell = styleFn;\n    return this;\n  }\n\n  /**\n   * Transposes (flips along the diagonal) prior to output.\n   * \n   * This can be very handy for wide, but short, tables.\n   * \n   * For example, given the data:\n   * \n   * ```\n   * const data = [\n   *   { name: 'John', color: 'green', age: 23, hair: 'blond', state: 'IL' },\n   *   { name: 'Jane', color: 'brown', age: 23, hair: 'blonde', state: 'IL' }\n   * ];\n   * ```\n   * \n   * Running normally would give\n   * \n   * ```\n   * utils.table(data)\n   *    .generateMarkdown();\n   * ```\n   * \n   * name|color|age|hair  |state\n   * --  |--   |-- |--    |--\n   * John|green|23 |blond |IL\n   * Jane|brown|23 |blonde|IL\n   * \n   * Running that transposed flips it.\n   * \n   * ```\n   * utils.table(data)\n   *  .transpose()\n   *  .generateMarkdown();\n   * ```\n   * \n   * name |John |Jane\n   * --   |--   |--\n   * color|green|brown\n   * age  |23   |23\n   * hair |blond|blonde\n   * state|IL   |IL\n   * @returns {TableGenerator}\n   */\n  transpose() {\n    this.#isTransposed = true;\n    return this;\n  }\n\n  //-- Table Generation\n\n  /**\n   * Prepares the data prior to any rendering.\n   * @returns {TableData} -\n   * @private\n   */\n  prepare() {\n    //-- data should ALWAYS be set to a valid array, but added in case\n    /* istanbul ignore next */\n    let cleanCollection = this.#data || [];\n    if (this.#sortFn) {\n      cleanCollection = cleanCollection.sort(this.#sortFn);\n    }\n\n    //-- augment\n    if (this.#augmentFn) {\n      cleanCollection = cleanCollection.map(this.#augmentFn);\n    }\n\n    //-- filter\n    if (this.#filterFn) {\n      cleanCollection = cleanCollection.filter(this.#filterFn);\n    }\n\n    //-- determine the columns to use\n    let keys = this.#columns || ObjectUtils.keys(cleanCollection); // Object.keys(firstRow);\n    keys = keys.filter(key => this.#columnsToExclude.indexOf(key) === -1);\n\n    //-- identify the formatter to use\n    const cleanFormatter = this.#formatterFn ? this.#formatterFn : ({\n      value\n    }) => value === undefined ? '' : value;\n    const translateHeader = key => {\n      if (Object.prototype.hasOwnProperty.call(this.#labels, key)) {\n        return this.#labels[key];\n      }\n      return key;\n    };\n    const translateData = (row, rowIndex) => keys.map((property, columnIndex) => cleanFormatter({\n      value: row[keys[columnIndex]],\n      columnIndex,\n      property,\n      rowIndex,\n      record: row\n    }));\n    let headers = keys.map(translateHeader);\n    let data = cleanCollection.map(translateData);\n    if (this.#limit < 0) {\n      data = data.reverse().slice(0, -this.#limit);\n    } else if (this.#offset < 0) {\n      data = data.slice(this.#offset);\n    } else if (this.#limit > 0) {\n      data = data.slice(this.#offset, this.#offset + this.#limit);\n    } else if (this.#offset > 0) {\n      data = data.slice(this.#offset);\n    }\n    if (this.#isTransposed) {\n      let transposedResults = [headers, ...data];\n      transposedResults = ArrayUtils.transpose(transposedResults);\n\n      // eslint-disable-next-line prefer-destructuring\n      headers = transposedResults[0];\n      data = transposedResults.slice(1);\n    }\n    return {\n      headers,\n      data\n    };\n  }\n\n  /**\n   * Generates an html table\n   * @returns {string}\n   * @see {@link TableGenerator#render}\n   */\n  generateHTML() {\n    const results = this.prepare();\n\n    //-- @TODO: review giving a set of columns as objects instead\n\n    const styleTable = this.#styleTable;\n    const styleHeader = this.#styleHeader;\n    const styleRowFn = this.#styleRow;\n    const styleColumnObj = this.#styleColumn;\n    const styleCellFn = this.#styleCell;\n    const printOptions = this.#printOptions;\n    const borderCSS = this.#borderCSS;\n    const cleanFn = printValue;\n    const printHeader = (headers, style) => '\\n<tr ' + (!styleHeader ? '' : `style=\"${styleHeader}\"`) + '>\\n\\t' + headers.map(header => `<th>${header}</th>`).join('\\n\\t') + '\\n</tr>\\n';\n\n    //-- todo - investigate shadow root so css only applies to table\n    const printInlineCSS = (...cssStyles) => {\n      const cleanCSS = cssStyles.filter(style => style ? true : false);\n\n      //-- short circuit if empty\n      if (cleanCSS.length < 1) {\n        return '';\n      }\n      const cssContents = cleanCSS.map(style => style.trim()).map(style => style.endsWith(';') ? style : `${style};`).join(' ');\n      return `style=\"${cssContents}\"`;\n    };\n    const printBody = collection => collection.map((dataRow, rowIndex) => {\n      const record = this.#data[rowIndex];\n      const rowStyle = !styleRowFn ? null : styleRowFn({\n        rowIndex,\n        row: dataRow,\n        record\n      }) || '';\n      return `<tr ${printInlineCSS(rowStyle)}>\\n\\t` + dataRow.map((value, columnIndex) => {\n        const columnHeader = results.headers[columnIndex];\n        //-- style for the cell\n        const cellData = {\n          value,\n          columnIndex,\n          columnHeader,\n          rowIndex,\n          row: dataRow,\n          record\n        };\n        const cellStyle = !styleCellFn ? '' : styleCellFn(cellData);\n        const columnStyle = !styleColumnObj || !styleColumnObj[columnHeader] || !typeof styleColumnObj[columnHeader] === 'function' ? '' : styleColumnObj[columnHeader](value, cellData);\n        return `<td ${printInlineCSS(borderCSS,\n        //-- could be inline, but not as clear\n        cellStyle, columnStyle)}>${cleanFn(value, printOptions)}</td>`;\n      }).join('\\n\\t') + '\\n</tr>';\n    }).join('\\n');\n    const tableResults = `<table cellspacing=\"0px\" ${printInlineCSS(styleTable)}>` + printHeader(results.headers, '') + printBody(results.data) + '\\n</table>';\n    return tableResults;\n  }\n\n  /**\n   * Generates a markdown table\n   * @returns {string}\n   * @see {@link TableGenerator#renderMarkdown}\n   */\n  generateMarkdown(options) {\n    const {\n      align = true\n    } = options || {};\n\n    //-- review style options for markdown\n    // const styleCellFn = this.#styleCell;\n\n    const printOptions = this.#printOptions;\n    const cleanFn = printValue;\n\n    // eslint-disable-next-line prefer-const\n    let {\n      headers,\n      data\n    } = this.prepare();\n\n    //-- add in the --|--|-- lines but in reverse order\n    data.unshift(headers.map(v => '--'));\n    data.unshift(headers);\n    const maxWidths = new Array(data[0].length).fill(0);\n    data = data.map((row, rowIndex) => row.map((value, columnIndex) => {\n      //-- shift down because the headers are added\n      const cleanedValue = cleanFn(value, printOptions);\n\n      //-- @TODO - we want to bold / make italic, but this needs more thought\n      // const record = rowIndex > 0 ? this.#data[rowIndex - 1] : {};\n      // const cellStyle = !styleCellFn\n      //   ? null\n      //   : styleCellFn({ value, columnIndex, rowIndex, row, record });\n\n      if (align) {\n        const valueLen = cleanedValue.length;\n        if (maxWidths[columnIndex] < valueLen) {\n          maxWidths[columnIndex] = valueLen;\n        }\n      }\n      return cleanedValue;\n    }));\n    if (align) {\n      //-- pad now we know how long to pad\n      //-- @TODO - replace inline?\n      data = data.map((row, rowIndex) => row.map((value, columnIndex) => value.padEnd(maxWidths[columnIndex], ' ')));\n    }\n    const tableResults = data.map(row => row.join('|')).join('\\n');\n    return tableResults;\n  }\n\n  /**\n   * Generates a CSV Table\n   * @see {@link TableGenerator#renderCSV}\n   */\n  generateCSV() {\n    const results = this.prepare();\n    const printOptions = this.#printOptions;\n    const cleanFn = printValue;\n    const csvify = a => JSON.stringify(a).slice(1).slice(0, -1);\n    const printHeader = (headers, style) => csvify(headers) + '\\n';\n    const printBody = collection => collection.map((dataRow, rowIndex) => csvify(dataRow.map((value, columnIndex) => csvify(cleanFn(value, printOptions))))).join('\\n');\n    const tableResults = printHeader(results.headers, '') + printBody(results.data);\n    return tableResults;\n  }\n\n  /**\n   * Generates a TSV Table\n   * @see {@link TableGenerator#renderCSV}\n   */\n  generateTSV() {\n    const results = this.prepare();\n    const printOptions = this.#printOptions;\n    const escapeString = val => {\n      //-- always return as string values to preserve formatting\n      return `\"${printValue(val, printOptions).replace(/\"/g, '\"\"')}\"`;\n    };\n    const tsvify = a => a.map(escapeString).join('\\t');\n    const printHeader = (headers, style) => tsvify(headers) + '\\n';\n    const printBody = collection => collection.map(dataRow => tsvify(dataRow)).join('\\n');\n\n    // const cleanFn = printValue;\n    // .map((dataRow) => tsvify(dataRow.map((value) =>\n    //   cleanFn(value, printOptions))\n    // )).join('\\n');\n\n    const tableResults = printHeader(results.headers, '') + printBody(results.data);\n    return tableResults;\n  }\n\n  /**\n   * @typedef {Object} TableArray\n   * @property {String} headers -\n   * @property {any[][]} data -\n   */\n\n  /**\n   * Generates an a result set to allow for further processing\n   * \n   * @see {@link TableGenerator#generateArray2|generateArray2()}\n   * @returns {TableArray}\n   * @example\n   * \n   * dataSet = [{reg:'z', source: 'A', temp: 99},\n   *    {reg: 'z', source: 'B', temp: 98},\n   *    {reg: 'z', source:'A', temp: 100}\n   * ];\n   * \n   * //-- only show the temp and source columns\n   * new TableGenerator(dataSet)\n   *  .columnsToExclude('reg') // or .columnsToExclude(['reg'])\n   *  .generateArray();\n   * \n   * //--\n   * \n   * {\n   *   headers: ['source', 'temp'],\n   *   data: [\n   *     ['A', 99],\n   *     ['B', 98],\n   *     ['A', 100],\n   *   ]\n   * }\n   */\n  generateArray(returnUnifiedArray = false) {\n    const results = this.prepare();\n    return results;\n  }\n\n  /**\n   * Generates an array of objects in a 2d Array\n   * \n   * NOTE: this can be helpful for needing to transpose results\n   * \n   * @returns {any[][]} - 2d array with both headers and data included\n   * @see {@link TableGenerator#generateArray|generateArray()}\n   * @example\n   * \n   * dataSet = [{reg:'z', source: 'A', temp: 99},\n   *    {reg: 'z', source: 'B', temp: 98},\n   *    {reg: 'z', source:'A', temp: 100}\n   * ];\n   * \n   * //-- only show the temp and source columns\n   * new TableGenerator(dataSet)\n   *  .columnsToExclude('reg') // or .columnsToExclude(['reg'])\n   *  .generateArray2();\n   * \n   * //--\n   * [\n   *  ['source', 'temp'],\n   *  ['A', 99],\n   *  ['B', 98],\n   *  ['A', 100],\n   * ];\n   */\n  generateArray2() {\n    const results = this.prepare();\n    return [[...results.headers], ...results.data];\n  }\n  static hasRenderedCSS = false;\n\n  /**\n   * Renders the html table in the cell results.\n   * \n   * ```\n   * weather = [\n   *   { id: 1, city: 'Seattle',  month: 'Aug', precip: 0.87 },\n   *   { id: 0, city: 'Seattle',  month: 'Apr', precip: 2.68 },\n   *   { id: 2, city: 'Seattle',  month: 'Dec', precip: 5.31 },\n   *   { id: 3, city: 'New York', month: 'Apr', precip: 3.94 },\n   *   { id: 4, city: 'New York', month: 'Aug', precip: 4.13 },\n   *   { id: 5, city: 'New York', month: 'Dec', precip: 3.58 },\n   *   { id: 6, city: 'Chicago',  month: 'Apr', precip: 3.62 },\n   *   { id: 8, city: 'Chicago',  month: 'Dec', precip: 2.56 },\n   *   { id: 7, city: 'Chicago',  month: 'Aug', precip: 3.98 }\n   * ];\n   * utils.table(weather)\n   *     .render();\n   * ```\n   * \n   * ![Screenshot of Table](img/tableGeneratorRender.png)\n   * \n   * @see {@link TableGenerator#generateHTML}\n   */\n  render() {\n    const context = IJSUtils.detectContext();\n    if (!context) {\n      throw Error('Not in iJavaScript, no $$ variable available');\n    }\n    const stickyCss = `<span class=\"sticky-table-marker\" ></span>\n<style type='text/css'>\n.sticky-table table { text-align: left; position: relative; border-collapse: collapse; }\n.sticky-table td { border: 1px solid #cccccc; }\n.sticky-table th { background: #676c87; color: white; position: sticky; top: 0; box-shadow: 0 2px 2px -1px rgba(0, 0, 0, 0.4); }\n</style>\n`;\n    let inlineCss = '';\n    //-- @TODO: figure out alternative option than to continually redefine the styles\n    //-- we cannot do something like below, as it will fail as soon as that one cell is re-rendered\n    //-- we don't want to link to an external css page (on some 3rd party server)\n    //-- and unfortunately, it seems any css provided in the libary would be unaccessible\n    //-- the only other option is to place it in the jupyter custom folder, for everyone using it.\n\n    // if (!TableGenerator.hasRenderedCSS) {\n    inlineCss = stickyCss;\n    TableGenerator.hasRenderedCSS = true;\n    context.$$.html(`${inlineCss}<div class=\"sticky-table\" style=\"max-height: ${this.#height}\">\\n${this.generateHTML()}\\n</div>`);\n  }\n\n  /**\n   * Renders Markdown in the cell results.\n   * \n   * Used quite frequently in making the documentation used here.\n   * \n   * @see {@link TableGenerator#generateMarkdown}\n   * @example\n   * weather = [\n   *   { id: 1, city: 'Seattle',  month: 'Aug', precip: 0.87 },\n   *   { id: 0, city: 'Seattle',  month: 'Apr', precip: 2.68 },\n   *   { id: 2, city: 'Seattle',  month: 'Dec', precip: 5.31 },\n   *   { id: 3, city: 'New York', month: 'Apr', precip: 3.94 },\n   *   { id: 4, city: 'New York', month: 'Aug', precip: 4.13 },\n   *   { id: 5, city: 'New York', month: 'Dec', precip: 3.58 },\n   *   { id: 6, city: 'Chicago',  month: 'Apr', precip: 3.62 },\n   *   { id: 8, city: 'Chicago',  month: 'Dec', precip: 2.56 },\n   *   { id: 7, city: 'Chicago',  month: 'Aug', precip: 3.98 }\n   * ];\n   * utils.table(weather)\n   *     .renderMarkdown();\n   * \n   * // id|city    |month|precip\n   * // --|--      |--   |--    \n   * // 1 |Seattle |Aug  |0.87  \n   * // 0 |Seattle |Apr  |2.68  \n   * // 2 |Seattle |Dec  |5.31  \n   * // 3 |New York|Apr  |3.94  \n   * // 4 |New York|Aug  |4.13  \n   * // 5 |New York|Dec  |3.58  \n   * // 6 |Chicago |Apr  |3.62  \n   * // 8 |Chicago |Dec  |2.56  \n   * // 7 |Chicago |Aug  |3.98\n   */\n  renderMarkdown() {\n    const context = IJSUtils.detectContext();\n    if (!context) {\n      throw Error('Not in iJavaScript, no $$ variable available');\n    }\n    context.console.log(this.generateMarkdown());\n  }\n\n  /**\n   * Renders Markdown in the cell results\n   * @see {@link TableGenerator#generateCSV}\n   * @example\n   * weather = [\n   *   { id: 1, city: 'Seattle',  month: 'Aug', precip: 0.87 },\n   *   { id: 0, city: 'Seattle',  month: 'Apr', precip: 2.68 },\n   *   { id: 2, city: 'Seattle',  month: 'Dec', precip: 5.31 },\n   *   { id: 3, city: 'New York', month: 'Apr', precip: 3.94 },\n   *   { id: 4, city: 'New York', month: 'Aug', precip: 4.13 },\n   *   { id: 5, city: 'New York', month: 'Dec', precip: 3.58 },\n   *   { id: 6, city: 'Chicago',  month: 'Apr', precip: 3.62 },\n   *   { id: 8, city: 'Chicago',  month: 'Dec', precip: 2.56 },\n   *   { id: 7, city: 'Chicago',  month: 'Aug', precip: 3.98 }\n   * ];\n   * utils.table(weather)\n   *     .renderCSV();\n   * \n   * // \"id\",\"city\",\"month\",\"precip\"\n   * // \"1\",\"Seattle\",\"Aug\",\"0.87\"\n   * // \"0\",\"Seattle\",\"Apr\",\"2.68\"\n   * // \"2\",\"Seattle\",\"Dec\",\"5.31\"\n   * // \"3\",\"New York\",\"Apr\",\"3.94\"\n   * // \"4\",\"New York\",\"Aug\",\"4.13\"\n   * // \"5\",\"New York\",\"Dec\",\"3.58\"\n   * // \"6\",\"Chicago\",\"Apr\",\"3.62\"\n   * // \"8\",\"Chicago\",\"Dec\",\"2.56\"\n   * // \"7\",\"Chicago\",\"Aug\",\"3.98\"\n   */\n  renderCSV() {\n    const context = IJSUtils.detectContext();\n    if (!context) {\n      throw Error('Not in iJavaScript, no $$ variable available');\n    }\n    context.console.log(this.generateCSV());\n  }\n\n  /**\n   * Renders Markdown in the cell results\n   * @see {@link TableGenerator#generateTSV}\n   * @example\n   * weather = [\n   *   { id: 1, city: 'Seattle',  month: 'Aug', precip: 0.87 },\n   *   { id: 0, city: 'Seattle',  month: 'Apr', precip: 2.68 },\n   *   { id: 2, city: 'Seattle',  month: 'Dec', precip: 5.31 },\n   *   { id: 3, city: 'New York', month: 'Apr', precip: 3.94 },\n   *   { id: 4, city: 'New York', month: 'Aug', precip: 4.13 },\n   *   { id: 5, city: 'New York', month: 'Dec', precip: 3.58 },\n   *   { id: 6, city: 'Chicago',  month: 'Apr', precip: 3.62 },\n   *   { id: 8, city: 'Chicago',  month: 'Dec', precip: 2.56 },\n   *   { id: 7, city: 'Chicago',  month: 'Aug', precip: 3.98 }\n   * ];\n   * utils.table(weather)\n   *     .renderTSV();\n   * \n   * // \"id\",\"city\",\"month\",\"precip\"\n   * // \"1\",\"Seattle\",\"Aug\",\"0.87\"\n   * // \"0\",\"Seattle\",\"Apr\",\"2.68\"\n   * // \"2\",\"Seattle\",\"Dec\",\"5.31\"\n   * // \"3\",\"New York\",\"Apr\",\"3.94\"\n   * // \"4\",\"New York\",\"Aug\",\"4.13\"\n   * // \"5\",\"New York\",\"Dec\",\"3.58\"\n   * // \"6\",\"Chicago\",\"Apr\",\"3.62\"\n   * // \"8\",\"Chicago\",\"Dec\",\"2.56\"\n   * // \"7\",\"Chicago\",\"Aug\",\"3.98\"\n   */\n  renderTSV() {\n    const context = IJSUtils.detectContext();\n    if (!context) {\n      throw Error('Not in iJavaScript, no $$ variable available');\n    }\n    context.console.log(this.generateTSV());\n  }\n}\nmodule.exports = TableGenerator;\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./src/TableGenerator.js?");

/***/ }),

/***/ "./src/_types/global.js":
/*!******************************!*\
  !*** ./src/_types/global.js ***!
  \******************************/
/***/ (() => {

eval("/**\n * Set of all the types we use in the JupyterJSUtils that there aren't classes for\n */\n\n/**\n * Description\n * @callback displayStrFn\n * @param {String} str - Description\n * @returns {void} - string description\n */\n\n/**\n * @callback displayB64Fn\n * @param {String} b64 -\n * @returns {void}\n */\n\n/**\n * @callback displayMimeFn\n * @param {Object} obj - each property key is the mime type\n * @returns {void}\n */\n\n/**\n * @callback displayJSON\n * @param {any} value - values to be printed\n */\n\n/**\n * @callback emptyFn\n * @returns {void}\n */\n\n/**\n * @typedef {Object} JupyterDisplay\n * @property {displayStrFn} text -\n * @property {displayStrFn} html -\n * @property {displayStrFn} svg -\n * @property {displayB64Fn} png -\n * @property {displayB64Fn} jpeg -\n * @property {displayMimeFn} mime Displays with mime type via ({ mimeType: value })\n * @property {displayJSON} json -\n * @property {Function} close -\n */\n\n//-- console\n\n/**\n * @typedef {Object} Console\n * @property {Function} log - logs a message to the console\n * @property {Function} warn -\n * @property {Function} error -\n */\n\n//-- jupyter $$\n\n/**\n * Sends the result to a jupyter cell\n * @callback JupyterSendResult\n * @param {any} value -\n * @returns {void}\n */\n\n/**\n * Creates a display\n * @callback JupyterCreateDisplay\n * @returns {JupyterDisplay}\n */\n\n/**\n * @typedef {Object} Jupyter$$\n * @property {JupyterSendResult} sendResult -\n * @property {JupyterCreateDisplay} display -\n * @property {Function} async - tells jupyter to run asynchronously\n */\n\n/**\n * @typedef {Object} IJavaScriptContext\n * @property {Jupyter$$} $$ - current display\n * @property {Jupyter$$} display - (alias for $$) - current display\n * @property {Console} console - current console\n */\n\n/**\n * @typedef {Object} StaticMember\n * @property {Boolean} isMethod -\n * @property {String} type - the typeof for the member\n * @property {String} constructor - the type of constructor for the class\n * @property {String} name - the name of the member\n */\n\n/**\n * @typedef {Object} FieldPath\n * @property {String} newFieldName - Dot notation path to value\n */\n\n/**\n * @typedef {Object} FieldLabel\n * @property {String} newFieldName - value as the Label to be printed for that field\n */\n\n/**\n * @typedef {Object} LabelValue\n * @property {String} label -\n * @property {String} value -\n */\n\n/**\n * @typedef {Object} DateFormat\n * @property {String} LOCAL - local datetime\n * @property {String} LOCAL_DATE - local date\n * @property {String} LOCAL_TIME - local time\n * @property {String} GMT - toGMTString() format\n * @property {String} ISO - toISOString() format\n * @property {String} UTC - toUTCString() format\n * @property {String} NONE - toString() format\n */\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./src/_types/global.js?");

/***/ }),

/***/ "./src/aggregate.js":
/*!**************************!*\
  !*** ./src/aggregate.js ***!
  \**************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* eslint-disable implicit-arrow-linebreak */\n\nconst Percentile = __webpack_require__(/*! percentile */ \"./node_modules/percentile/lib/index.js\");\nconst ArrayUtils = __webpack_require__(/*! ./array */ \"./src/array.js\");\nconst ObjectUtils = __webpack_require__(/*! ./object */ \"./src/object.js\");\nconst FormatUtils = __webpack_require__(/*! ./format */ \"./src/format.js\");\n\n/**\n * Utilities that provide a reduced value from a collection.\n * \n * (Note that this can also map the collection down first)\n * \n * This can be very helpful with {@link SourceMap#reduce|SourceMap.reduce()}\n * or {@link module:group.by|group.by()} in aggregating a series.\n * \n * Types of methods:\n * \n * * Select a single property\n *   * {@link module:aggregate.property|property()} - maps to a single property (often used with other libraries)\n * * Ranges of values\n *   * {@link module:aggregate.extent|extent()} - returns the min and max of range\n *   * {@link module:aggregate.min|min()} - returns the minimum value of the range\n *   * {@link module:aggregate.max|max()} - returns the maximum value of the range\n *   * {@link module:aggregate.difference|difference()} - returns the difference between max and min values\n * * Average values\n *   * {@link module:aggregate.avgMedian|avgMedian()} - finds the median (halfway number in a sorted series)\n *   * {@link module:aggregate.avgMean|avgMean()} - Finds the mean value (sum of all values / # of values)\n * * Unique / Duplicate values\n *   * {@link module:aggregate.duplicates|duplicates()} - returns values found more than once\n *   * {@link module:aggregate.count|count()} - returns count of values in ways easily convertable to string\n *   * {@link module:aggregate.countMap|countMap()} - return count of values in a map\n *   * {@link module:aggregate.unique|unique()} - returns values found only once\n *   * {@link module:aggregate.distinct|distinct()} - returns the number of unique values found (unique.length)\n *   * {@link module:aggregate.notIn|notIn()} - returns which values are not in a superset\n *   * {@link module:aggregate.isUnique|isUnique()} - returns whether the values in the list are unique\n * * Meta / Coalesce\n *   * {@link module:aggregate.length|length()} - Number of records found in the collection\n *   * {@link module:aggregate.first|first()} - returns first non-null/undefined in list\n *   * {@link module:aggregate.sum|sum()} - sum of a collection\n *   * {@link module:aggregate.coalesce|coalesce()} - given a list of objects, creates a single object with first non-null value of all properties\n * * Functional\n *   * {@link module:aggregate.deferCollection|deferCollection(function, bindArg, bindArg, ...)} - bind a function with arguments\n * * Percentile\n *   * {@link module:aggregate.percentile|percentile()} - determines the Nth percentile of a field or value\n *   * {@link module:aggregate.percentile_01|percentile_01()} - 1th percentile\n *   * {@link module:aggregate.percentile_05|percentile_05()} - 5th percentile\n *   * {@link module:aggregate.percentile_10|percentile_10()} - 10th percentile\n *   * {@link module:aggregate.percentile_25|percentile_25()} - 25th percentile\n *   * {@link module:aggregate.percentile_50|percentile_50()} - 50th percentile\n *   * {@link module:aggregate.percentile_75|percentile_75()} - 75th percentile\n *   * {@link module:aggregate.percentile_90|percentile_90()} - 90th percentile\n *   * {@link module:aggregate.percentile_95|percentile_95()} - 95th percentile\n *   * {@link module:aggregate.percentile_99|percentile_99()} - 99th percentile\n * * Top Values\n *   * {@link module:aggregate.topValues|topValues} - top (or bottom) values from a list of objects or literals\n * \n * Please note, there is nothing special for these functions, such as working with {@link SourceMap#reduce|SourceMap.reduce()}\n * \n * They simply accept a collection and provide a result,\n * often using the {@link module:aggregate.evaluateFunctionOrProperty|aggregate.evaluateFunctionOrProperty()}\n * with the second argument.\n * \n * ## Overall Example\n * \n * Assume we have two tyeps of values:\n * \n * ```\n * collection = [\n *   { id: 1, city: 'Seattle',  month: 'Aug', precip: 0.87 },\n *   { id: 0, city: 'Seattle',  month: 'Apr', precip: 2.68 },\n *   { id: 2, city: 'Seattle',  month: 'Dec', precip: 5.31 },\n *   { id: 3, city: 'New York', month: 'Apr', precip: 3.94 },\n *   { id: 4, city: 'New York', month: 'Aug', precip: 4.13 },\n *   { id: 5, city: 'New York', month: 'Dec', precip: 3.58 },\n *   { id: 6, city: 'Chicago',  month: 'Apr', precip: 3.62 },\n *   { id: 8, city: 'Chicago',  month: 'Dec', precip: 2.56 },\n *   { id: 7, city: 'Chicago',  month: 'Aug', precip: 3.98 }\n * ];\n * ```\n * \n * ```\n * // collection.map(r => r.precip);\n * series = [0.87, 2.68, 5.31, 3.94, 4.13, 3.58, 3.62, 2.56, 3.98];\n * ```\n * \n * ## Working with Groups\n * \n * The expected way this will be used most is with the {@link module:group|group.by(collection, field, ...)} call.\n * \n * (See also {@link https://observablehq.com/@d3/d3-group|d3-group functionality})\n * \n * ```\n * utils.group.by(collection, 'city')\n *   .reduce((collection) => ({\n *     monthsReporting: utils.aggregate.unique(collection, 'month'),\n *     avgPrecipitation: utils.aggregate.sum(collection, 'precip'),\n *     numReports: utils.aggregate.length(collection),\n *     minPrecip: utils.aggregate.min(collection, 'precip'),\n *     maxPrecip: utils.aggregate.min(collection, 'precip'),\n *     variancePrecip: utils.aggregate.difference(collection, 'precip'),\n *   }))\n * \n * providing\n * [\n *   {\n *     city: 'Seattle',\n *     monthsReporting: [ 'Aug', 'Apr', 'Dec' ],\n *     avgPrecipitation: 8.86,\n *     numReports: 3,\n *     minPrecip: 0.87,\n *     maxPrecip: 0.87,\n *     variancePrecip: 4.43999\n *   },\n *   {\n *     city: 'New York',\n *     monthsReporting: [ 'Apr', 'Aug', 'Dec' ],\n *     avgPrecipitation: 11.65,\n *     numReports: 3,\n *     minPrecip: 3.58,\n *     maxPrecip: 3.58,\n *     variancePrecip: 0.54999\n *   },\n *   ...\n * ]\n * ```\n * \n * ## Using in Tables\n * \n * ({@link TableGenerator|see TableGenerator})\n * \n * ```\n * new utils.TableGenerator()\n *     .data(\n *       utils.group.by(collection, 'city')\n *        .reduce((collection) => ({\n *          monthsReporting: utils.aggregate.unique(collection, 'month'),\n *          avgPrecipitation: utils.aggregate.sum(collection, 'precip'),\n *          numReports: utils.aggregate.length(collection),\n *          minPrecip: utils.aggregate.min(collection, 'precip'),\n *          maxPrecip: utils.aggregate.min(collection, 'precip'),\n *          variancePrecip: utils.aggregate.difference(collection, 'precip'),\n *        }))\n *     )\n *     .labels({ monthsReporting: 'Months',\n *              avgPrecipitation: 'Avg. Precip.',\n *              numReports: '# Reports'\n *     })\n *     .render()\n * ```\n * \n * ![Screenshot](img/PrecipitationAvgTable.png)\n * \n * ## Using in Vega Charts\n * \n * ({@link module:vega|see vega module})\n * \n * ```\n * utils.vega.svg((vl) => vl.markLine()\n *    .data(\n *       utils.group.by(collection, 'city')\n *        .reduceSeparate((collection) => ({\n *          minPrecip: utils.aggregate.min(collection, 'precip'),\n *          maxPrecip: utils.aggregate.max(collection, 'precip'),\n *          avgPrecip: utils.aggregate.avgMean(collection, 'precip'),\n *        }))\n *    )\n *    .title('Precipitation by City')\n *    .width(400)\n *    .encode(\n *         vl.x().fieldN('city'),\n *         vl.y().fieldQ('_aggregateValue').title('Precipitation'),\n *         vl.color().fieldN('_aggregateKey').title('Calculation')\n *    )\n * );\n * ```\n * \n * ![Screenshot](img/PrecipitationAvgChart.png)\n * \n * ## Working with Simple Arrays\n * \n * Simple arrays do not need a mapping function or property,\n * we can simply pass null (or no second argument at all).\n * \n * ```\n * series = [0.87, 2.68, 5.31, 3.94, 4.13, 3.58, 3.62, 2.56, 3.98];\n * utils.aggregate.min(series, null);\n * // provides 0.87\n * ```\n * \n * This is the same as `series.sort(utils.array.SORT_ASCENDING)[0]`\n * \n * ## Working with Mapping Functions\n * \n * If we want a specific value, we can pass a mapping function first.\n * \n * ```\n * collection = [\n *   { id: 1, city: 'Seattle',  month: 'Aug', precip: 0.87 },\n *   { id: 0, city: 'Seattle',  month: 'Apr', precip: 2.68 },\n *   ...\n * ];\n * \n * utils.aggregate.min(collection, (r) => r.precip);\n * // provides 0.87\n * ```\n * \n * This is the same as:\n * \n * ```\n * collection.map(r => r precip)\n *    .sort(utils.array.SORT_ASCENDING)[0]\n * ```\n * \n * ## Working with Object Properties\n * \n * If we have a specific property (or key) in our 2d collection,\n * then we can just pass that instead.\n * \n * ```\n * collection = [\n *   { id: 1, city: 'Seattle',  month: 'Aug', precip: 0.87 },\n *   { id: 0, city: 'Seattle',  month: 'Apr', precip: 2.68 },\n *   ...\n * ];\n * \n * utils.aggregate.min(collection, 'precip');\n * // provides 0.87\n * ```\n * \n * This is the same as:\n * \n * ```\n * collection.map(r => r precip)\n *    .sort(utils.array.SORT_ASCENDING)[0]\n * ```\n * \n * @namespace aggregate\n * @module aggregate\n * @exports aggregate\n */\nmodule.exports = {};\n\n// eslint-disable-next-line no-unused-vars\nconst AggregateUtils = module.exports;\n\n/**\n * Maps an array of values to a single property.\n * \n * For example:\n * \n * ```\n * const data = [{ record: 'jobA', val: 1 }, { record: 'jobA', val: 2 },\n *  { record: 'jobA', val: 3 }, { record: 'jobA', val: 4 },\n *  { record: 'jobA', val: 5 }, { record: 'jobA', val: 6 },\n *  { record: 'jobA', val: 7 }, { record: 'jobA', val: 8 },\n *  { record: 'jobA', val: 9 }, { record: 'jobA', val: 10 }\n * ];\n * \n * utils.object.propertyFromList(data, 'val')\n * //-- [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n * \n * utils.object.propertyFromList(data, (r) => r.val);\n * //-- [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n * ```\n * \n * @param {Object[]} objectArray - Array of Objects to be mapped to a single property / value\n * @param {Function | String} propertyOrFn - Name of the property or Function to return a value\n * @returns {Array} - Array of values\n */\nmodule.exports.property = function propertyFromList(objectArray, propertyOrFn) {\n  return ObjectUtils.propertyFromList(objectArray, propertyOrFn);\n};\n\n/**\n * Converts an aggregate function to two functions -\n * one that takes all arguments except the collection\n * and one that takes only the collection.\n * \n * For example:\n * \n * ```\n * utils.aggregate.unique(collection, (r) => r.city))\n * //-- all unique city values in the collection\n * // ['Chicago', 'New York', 'Seattle', 'Amsterdam']\n * ```\n * \n * but what if we know we want the city properties,\n * but don't have the collection yet?\n * \n * ```\n * const uniqueCity = utils.aggregate.deferCollection(utils.aggregate.unique, (r) => r.city);\n * ...\n * uniqueCity(collection)\n * //-- all the unique city values in the collection\n * // ['Chicago', 'New York', 'Seattle', 'Amsterdam']\n * ```\n * \n * note that this is also available under an alias `defer`\n * \n * ```\n * const uniqueCity = utils.agg.defer(utils.agg.unique, 'city');\n * ...\n * uniqueCity(collection)\n * //-- all the unique city values in the collection\n * // ['Chicago', 'New York', 'Seattle', 'Amsterdam']\n * ```\n * \n * @param {Function} aggregateFn\n * @param {...any} [rest] - any arguments past the collection argument\n * @returns {Function} - (collection) => aggregateFn.apply(this, [collection, ...rest])\n */\nmodule.exports.deferCollection = (aggregateFn, ...rest) => {\n  if (typeof aggregateFn !== 'function') {\n    throw Error('deferCollection:aggregateFn should be a function');\n  }\n  return collection => aggregateFn.apply(this, [collection, ...rest]);\n};\nmodule.exports.defer = module.exports.deferCollection;\n\n/**\n * Identifies the min and max of values of a collection\n * @param {Array} collection - \n * @param {Function|String} accessor - function to identify the property, string property name or null\n * @returns {Object}- structure of ({ min, max })\n * @example \n * utils.aggregate.extent([0.87, 2.68, 5.31, 3.94, 4.13, 3.58, 3.62, 2.56]);\n * // { min: 0.87, max: 5.31 }\n */\nmodule.exports.extent = function extent(collection, accessor) {\n  return {\n    min: AggregateUtils.min(collection, accessor),\n    max: AggregateUtils.max(collection, accessor)\n  };\n};\n\n/**\n * Identifies the smallest value in a collection of values.\n * \n * (Note that this works with anything comparable with <)\n * @param {Array} collection -\n * @param {Function|String} accessor - function to identify the property, string property name or null\n * @returns {any} - smallest value where result < any other value in collection\n * @example \n * utils.aggregate.min([0.87, 2.68, 5.31, 3.94, 4.13, 3.58, 3.62, 2.56]);\n * // 0.87\n */\nmodule.exports.min = function min(collection, accessor) {\n  const cleanedFunc = ObjectUtils.evaluateFunctionOrProperty(accessor);\n  return collection.reduce((current, val) => {\n    const valEval = cleanedFunc(val);\n    return valEval < current ? valEval : current;\n  }, cleanedFunc(collection[0]));\n};\n\n/**\n * Identifies the largest value in a collection of values.\n * \n * (Note that this works with anything comparable with > )\n * \n * @param {Array} collection -\n * @param {Function|String} accessor - function to identify the property, string property name or null\n * @returns {any} - largest value where result > any other value in collection\n * @example \n * utils.aggregate.max([0.87, 2.68, 5.31, 3.94, 4.13, 3.58, 3.62, 2.56]);\n * // 5.31\n */\nmodule.exports.max = function max(collection, accessor) {\n  const cleanedFunc = ObjectUtils.evaluateFunctionOrProperty(accessor);\n  return collection.reduce((current, val) => {\n    const valEval = cleanedFunc(val);\n    return valEval > current ? valEval : current;\n  }, cleanedFunc(collection[0]));\n};\n\n/**\n * Sum of the values.\n * \n * @param {Array} collection -\n * @param {Function|String} accessor - function to identify the property, string property name or null\n * @returns {any} - largest value where result > any other value in collection\n * @example \n * utils.aggregate.sum([0.87, 2.68, 5.31, 3.94, 4.13, 3.58, 3.62, 2.56]);\n * // 26.69\n */\nmodule.exports.sum = function sum(collection, accessor) {\n  const cleanedFunc = ObjectUtils.evaluateFunctionOrProperty(accessor);\n  return collection.reduce((current, val) => current + cleanedFunc(val), 0);\n};\nmodule.exports.coalesceDefaultEvaluationFn = function coalesceDefaultEvaluationFn(entryValue, currentCoalescedValue, entryPropName, entry) {\n  if (currentCoalescedValue) return false;\n  if (entryValue == null) return false;\n  if (entryValue === 0) return false;\n  if (Array.isArray(entryValue) && entryValue.length === 0) return false;\n  if (entryValue instanceof Date && entryValue.getTime() === 0) return false;\n  return true;\n};\n\n/**\n * Coalesces a collection of objects to return a single object that has the first non-null value\n * of all unique properties found in the collection.\n * \n * example:\n * \n * ```\n * collection = [\n *  { first: 'john' },\n *  { last: 'doe' },\n *  { age: 23 }\n * ];\n * utils.agg.coalesce(collection);\n * // { first: 'john', last: 'doe', age: 23 };\n * ```\n * \n * this also works to show example values for a large number of objects\n * \n * ```\n * collection = [\n *   { first: 'john', last: 'doe', age: 23, failedClass: null },\n *   { first: 'jane', last: 'doe', favouriteColor: 'blue', failedClass: null },\n *   null,\n *   { first: 'bill', favouriteColor: 'red', failedClass: 'asbx-dx2' }\n * ];\n * utils.agg.coalesce(collection);\n * //-- now we can understand the types of values we got for each property type\n * // { first: 'john', last: 'doe', age: 23, favouriteColor: 'blue', failedClass: 'asbx-dx2' }\n * ```\n * \n * Note - an optional evaluationFn can be provided, that can be used to determine\n * if a value is collected.\n * \n * ```\n * collection = [{ val: null }, { val: 23 }, { val: 2 }, { val: 100 }];\n * maxCoalesce = (val, current) => val && (!current || val > current);\n * utils.agg.coalesce(collection, maxCoalesce);\n * // { val: 100 }\n * ```\n * \n * @param {Array} collection - \n * @param {Function} [evaluationFn] - optional function that defines the value collected\n *  - function(entryValue:any, currentCoalescedValue:any, entryPropName:string, entry:Object):Boolean\n * @returns {Object} - Object with all properties found, and the first \n * @see {@link module:describe.describeObjects|describe.describeObjects(collection, options)} - to better understand values found\n */\nmodule.exports.coalesce = function coalesce(collection, evaluationFn) {\n  if (!Array.isArray(collection)) return collection;\n  const cleanEvalFn = evaluationFn || AggregateUtils.coalesceDefaultEvaluationFn;\n  const result = {};\n  collection.forEach(entry => {\n    if (ObjectUtils.isObject(entry)) {\n      Object.keys(entry).forEach(key => {\n        const entryValue = entry[key];\n        const currentCoalescedValue = result[key];\n        if (cleanEvalFn(entryValue, currentCoalescedValue, key, entry)) {\n          result[key] = entryValue;\n        }\n      });\n    }\n  });\n  return result;\n};\n\n/**\n * The difference between the lowest and the highest values in the collection\n * \n * @param {Array} collection \n * @param {*} accessor \n * @returns {Number} -\n * @example\n * utils.aggregate.difference([0.87, 2.68, 5.31, 3.94, 4.13, 3.58, 3.62, 2.56]);\n * // 4.44  (max: 5.31 - min: 0.87 = 4.4)\n */\nmodule.exports.difference = function difference(collection, accessor) {\n  const range = AggregateUtils.extent(collection, accessor);\n  return range.max - range.min;\n};\n\n/**\n * Finds the mean value (sum of all values / # of values)\n * @param {Array} collection -\n * @param {Function|String} accessor - function to identify the property, string property name or null\n * @returns {Number} - mean average\n * @example \n * utils.aggregate.avgMean([0.87, 2.68, 5.31, 3.94, 4.13, 3.58, 3.62, 2.56]);\n * // 3.41\n */\nmodule.exports.avgMean = function avgMean(collection, accessor) {\n  const cleanedFunc = ObjectUtils.evaluateFunctionOrProperty(accessor);\n  return collection.reduce((current, val) => current + cleanedFunc(val), 0) / collection.length;\n};\n\n/**\n * Finds the median (halfway number in a sorted series)\n * @param {Array} collection -\n * @param {Function|String} accessor - function to identify the property, string property name or null\n * @returns {Number} - median number from the series\n * @example\n * utils.aggregate.avgMedian([0.87, 2.68, 5.31, 3.94, 4.13, 3.58, 3.62, 2.56]);\n * // [0.87,2.56,2.68,3.58,3.62,3.94,3.98,4.13,5.31]\n * //                      3.62\n */\nmodule.exports.avgMedian = function avgMedian(collection, accessor) {\n  const cleanedFunc = ObjectUtils.evaluateFunctionOrProperty(accessor);\n  const results = collection.map(cleanedFunc).sort((a, b) => a - b);\n  const middle = Math.floor(collection.length / 2);\n  return collection.length % 2 === 0 ? (results[middle - 1] + results[middle]) / 2 : results[middle];\n};\n\n/**\n * Finds the first value in a list.\n * \n * `NOTE: this short circuits and can be helpful if the values are all identical`\n * \n * @param {Array} collection -\n * @param {Function|String} accessor - function to identify the property, string property name or null\n * @returns {any} - the first non undefined || null value found\n * @example\n * utils.aggregate.first([null, undefined, 0.87, 2.68, 5.31, 3.94, 4.13, 3.58, 3.62, 2.56]);\n * // 0.87\n */\nmodule.exports.first = function first(collection, accessor) {\n  const cleanedFunc = ObjectUtils.evaluateFunctionOrProperty(accessor);\n  let result = null;\n  for (let i = 0; i < collection.length; i += 1) {\n    result = cleanedFunc(collection[i]);\n    if (result !== undefined && result !== null) {\n      return result;\n    }\n  }\n  return null;\n};\n\n/**\n * Number of records found in the collection\n * @param {Array} collection -\n * @returns {Number}\n * @example\n * utils.aggregate.count([0.87, 2.68, 5.31, 3.94, 4.13, 3.58, 3.62, 2.56]);\n * // 8\n */\nmodule.exports.length = function length(collection) {\n  return collection.length;\n};\n\n/**\n * Identifies the unique values from the collection.\n * \n * Note that this includes an additional bucketing function - useful for objects.\n * (As String('A') !== String('A)' - because\n * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators|\n * because checking equality of Objects is only true if the operands reference the same Object.})\n * \n * See {@link module:aggregate.count} for more\n * \n * @param {Array} collection -\n * @param {Function|String} accessor - function to identify the property, string property name or null\n * @param {Function} [uniquifierFn] - optional function to make values unique\n * @returns {Array} - unique values\n * @example\n * utils.aggregate.unique(['apple', 'orange', 'apple', 'banana']);\n * // [ 'apple', 'orange', 'banana' ]\n */\nmodule.exports.unique = function unique(collection, accessor, uniquifierFn) {\n  const cleanedFunc = ObjectUtils.evaluateFunctionOrProperty(accessor);\n  if (uniquifierFn) {\n    return Array.from(new Set(collection.map(v => uniquifierFn(cleanedFunc(v)))));\n  }\n  return Array.from(new Set(collection.map(cleanedFunc).reduce((result, val) => val instanceof Set || Array.isArray(val) ? [...result, ...val] : [...result, val], [])));\n};\n\n/**\n * Counts the unique values.\n * \n * Note that this includes an additional bucketing function - useful for objects.\n * (As String('A') !== String('A)' - because\n * \n * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators|\n * because checking equality of Objects is only true if the operands reference the same Object.})\n * \n * See {@link module:aggregate.count} for more\n * \n * @param {Array} collection -\n * @param {Function|String} accessor - function to identify the property, string property name or null\n * @param {Function} [uniquifierFn] - optional function to make values unique\n * @returns {Number} - unique values\n * @example\n * utils.aggregate.unique(['apple', 'orange', 'apple', 'banana']);\n * // 3 - e.g [ 'apple', 'orange', 'banana' ].length\n */\nmodule.exports.distinct = function distinct(collection, accessor, uniquifierFn) {\n  return AggregateUtils.unique(collection, accessor, uniquifierFn).length;\n};\n\n/**\n * Identifies how frequently something has occurred as a value.\n * \n * Note that this also includes a function to make the value unique,\n * so Objects can be compared,\n * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators|\n * because checking equality of Objects is only true if the operands reference the same Object.})\n * \n * See {@link module:aggregate.count} for more\n * \n * @param {Array} collection -\n * @param {Function|String} accessor - function to identify the property, string property name or null\n * @param {Function} [uniquifierFn] - optional function to make values unique\n * @returns {Map} - unique values -> count of how often it was identified\n * @see .count - for an object that convert to string easier\n * @example\n * const source = [\n *   { city: 'Chicago' }, { city: 'Seattle' }, { city: 'New York' },\n *   { city: 'Chicago' }, { city: 'Seattle' }, { city: 'AmsterDam' }\n * ];\n * utils.aggregate.count(source, 'city');\n * // Map([['Chicago', 2], ['Seattle', 2], ['New York', 1], ['Amsterdam'], 1])\n * utils.aggregate.countMap(source, 'city').get('Chicago')\n * // 2\n */\nmodule.exports.countMap = function countMap(collection, accessor, uniquifierFn) {\n  const cleanedFunc = ObjectUtils.evaluateFunctionOrProperty(accessor);\n  const resultMap = new Map();\n  collection.forEach(val => {\n    let result = cleanedFunc(val);\n    if (uniquifierFn) result = uniquifierFn(result);\n    if (result === undefined) result = null;\n    if (!resultMap.has(result)) {\n      resultMap.set(result, 1);\n    } else {\n      resultMap.set(result, resultMap.get(result) + 1);\n    }\n  });\n  return resultMap;\n};\n\n/**\n * Identifies how frequently something has occurred as a value.\n * \n * Note that this also includes a function to make the value unique,\n * so Objects can be compared,\n * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators|\n * because checking equality of Objects is only true if the operands reference the same Object.})\n * \n * See {@link module:aggregate.unique} for more\n * @param {Array} collection -\n * @param {Function|String} accessor - function to identify the property, string property name or null\n * @param {Function} [uniquifierFn] - optional function to make values unique\n * @returns {Object} - with unique values as props, and counts as values\n * @see .countMap - for a map of results that are not converted to string\n * @example\n * const source = [\n *   { city: 'Chicago' }, { city: 'Seattle' }, { city: 'New York' },\n *   { city: 'Chicago' }, { city: 'Seattle' }, { city: 'AmsterDam' }\n * ];\n * utils.aggregate.count(source, 'city');\n * // { Chicago: 2, Seattle: 2, 'New York': 1, Amsterdam: 1 };\n * utils.aggregate.count(source, 'city').Chicago\n * // 2\n * \n * series = [\n *   { station: 'A', timestamp: new Date(2022, 0, 1, 9) },\n *   { station: 'B', timestamp: new Date(2022, 0, 1, 9, 30) },\n *   { station: 'A', timestamp: new Date(2022, 0, 1, 10, 0) },\n *   { station: 'B', timestamp: new Date(2022, 0, 2, 9) },\n *   { station: 'A', timestamp: new Date(2022, 0, 2, 9, 30) },\n *   { station: 'B', timestamp: new Date(2022, 0, 2, 10, 0) },\n *   { station: 'A', timestamp: new Date(2022, 0, 3, 10, 0) },\n *   { station: 'B', timestamp: new Date(2022, 0, 3, 10, 0 }\n * ]\n * utils.aggregate.count(series, 'timestamp', (d) => d.toISOString().slice(0, 10))\n * // { '2022-01-01': 3, '2022-01-02': 2, '2022-01-03': 2 }\n */\nmodule.exports.count = function distribution(collection, accessor, uniquifierFn) {\n  const countResults = AggregateUtils.countMap(collection, accessor, uniquifierFn);\n  const entries = Array.from(countResults.entries()).map(([key, value]) => [FormatUtils.printValue(key), value]);\n  return Object.fromEntries(entries);\n};\n\n/**\n * Determines the values that were duplicated\n * \n * Note that this also includes a function to make the value unique,\n * so even Dates, Objects, etc can be compared,\n * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators|\n * because checking equality of Objects is only true if the operands reference the same Object.})\n * \n * See {@link module:aggregate.count} for more\n * @param {Array} collection -\n * @param {Function|String} accessor - function to identify the property, string property name or null\n * @param {Function} [uniquifierFn] - optional function to make values unique\n * @returns {Array} - array of the duplicate values\n * @see {@link module:aggregate.count} for the number of times they were duplicated\n * @example\n * const source = [\n *   { city: 'Chicago' }, { city: 'Seattle' }, { city: 'New York' },\n *   { city: 'Chicago' }, { city: 'Seattle' }, { city: 'AmsterDam' }\n * ];\n * utils.aggregate.duplicates(source, 'city');\n * // ['Chicago', 'Seattle']\n */\nmodule.exports.duplicates = function duplicates(collection, accessor, uniquifierFn) {\n  const countResults = AggregateUtils.countMap(collection, accessor, uniquifierFn);\n  const results = [];\n  Array.from(countResults.entries()).forEach(([key, value]) => {\n    if (value > 1) {\n      results.push(key);\n    }\n  });\n  return results;\n};\n\n/**\n * Determines the values in collection that are not in he possibleSuperSet.\n * \n * This can be helpful in validating a superSet does indeed include all the values.\n * \n * @param {Array} collection - \n * @param {Function | String} accessor - function to identify the value or string property name or null if array of values\n * @param {Iteratable} possibleSuperSet - Array or Set that we want to identify which values are not in\n * @returns {Set} - set of values from collection not in the possibleSuperSet\n * \n * @example\n * const superSet = new Set(['a', 'b', 'c']);\n * const data = [{ val: 'a' }, { val: 'b' }, { val: 'c' }, { val: 'd' }];\n * \n * aggregate.notIn(data, 'val', superSet);\n * // Set('d')\n */\nmodule.exports.notIn = function notIn(collection, accessor, targetIterator) {\n  const cleanedFunc = ObjectUtils.evaluateFunctionOrProperty(accessor);\n  const targetSet = new Set(targetIterator);\n  const results = new Set();\n  collection.forEach(record => {\n    const recordValue = cleanedFunc(record);\n    if (!targetSet.has(recordValue)) {\n      results.add(recordValue);\n    }\n  });\n  return results;\n};\n\n/**\n * Determines whether the values in the collection are unique.\n * \n * @param {Array} collection -\n * @param {Function | String} accessor - function to access the value, string property or null\n * @returns {Boolean} - whether the values in the array are truly unique\n * @example\n * let data = [{ val: 1 }, { val: 2 }, { val: 3 }, { val: 1 }];\n * aggregate.isUnique(data, 'val'); // false\n * \n * let data = [{ val: 1 }, { val: 2 }, { val: 3 }];\n * aggregate.isUnique(data, 'val'); // true\n * \n * data = ['a', 'b', 'c', 'd'];\n * aggregate.isUnique(data); // true\n */\nmodule.exports.isUnique = function isUnique(collection, accessor) {\n  const cleanedFunc = ObjectUtils.evaluateFunctionOrProperty(accessor);\n  const uniqueValues = new Set();\n  const duplicateValue = collection.find(record => {\n    const result = cleanedFunc(record);\n    if (result === undefined || result === null) {\n      //-- do nothing\n    } else if (!uniqueValues.has(result)) {\n      uniqueValues.add(result);\n      return false;\n    }\n    return true;\n  });\n  return duplicateValue === undefined;\n};\n\n/**\n * Returns a given percentile from a list of objects.\n * \n * **Note: this simply aggregates the values and passes to the [Percentile NPM Package](https://www.npmjs.com/package/percentile)**\n * \n * @param {Object[]} collection - collection of objects\n * @param {Function | String} accessor - function to access the value, string property or null\n * @param {Number} pct - Percentile (either .5 or 50)\n * @returns {Number} - the pct percentile of a property within the collection\n * @example\n * const data = [{ record: 'jobA', val: 1 }, { record: 'jobA', val: 2 },\n *  { record: 'jobA', val: 3 }, { record: 'jobA', val: 4 },\n *  { record: 'jobA', val: 5 }, { record: 'jobA', val: 6 },\n *  { record: 'jobA', val: 7 }, { record: 'jobA', val: 8 },\n *  { record: 'jobA', val: 9 }, { record: 'jobA', val: 10 }\n * ];\n * \n * utils.aggregate.percentile(data, 'val', 50) //-- returns 5\n * utils.aggregate.percentile(data, (r) => r.val, 70) //-- returns 7\n */\nmodule.exports.percentile = function percentile(collection, accessor, pct) {\n  const values = ObjectUtils.propertyFromList(collection, accessor);\n  const cleanPercentile = pct > 0 && pct < 1 ? pct * 100 : pct;\n  return Percentile(cleanPercentile, values);\n};\n\n/**\n * Returns a hard coded percentage\n * \n * {@link module:aggregate.percentage|See Percentage for more detail}\n * \n * @param {Object[]} collection - collection of objects\n * @param {Function | String} accessor - function to access the value, string property or null\n * @returns {Number} - the percentile of a property within the collection\n * @see {@link module:aggregate.percentile|percentile} - as this simply hard codes the percentage\n */\nmodule.exports.percentile_01 = function percentile(collection, accessor) {\n  return AggregateUtils.percentile(collection, accessor, 1);\n};\n\n/**\n * Returns a hard coded percentage\n * \n * {@link module:aggregate.percentage|See Percentage for more detail}\n * \n * @param {Object[]} collection - collection of objects\n * @param {Function | String} accessor - function to access the value, string property or null\n * @returns {Number} - the percentile of a property within the collection\n * @see {@link module:aggregate.percentile|percentile} - as this simply hard codes the percentage\n */\nmodule.exports.percentile_05 = function percentile(collection, accessor) {\n  return AggregateUtils.percentile(collection, accessor, 5);\n};\n\n/**\n * Returns a hard coded percentage\n * \n * {@link module:aggregate.percentage|See Percentage for more detail}\n * \n * @param {Object[]} collection - collection of objects\n * @param {Function | String} accessor - function to access the value, string property or null\n * @returns {Number} - the percentile of a property within the collection\n * @see {@link module:aggregate.percentile|percentile} - as this simply hard codes the percentage\n */\nmodule.exports.percentile_10 = function percentile(collection, accessor) {\n  return AggregateUtils.percentile(collection, accessor, 10);\n};\n\n/**\n * Returns a hard coded percentage\n * \n * {@link module:aggregate.percentage|See Percentage for more detail}\n * \n * @param {Object[]} collection - collection of objects\n * @param {Function | String} accessor - function to access the value, string property or null\n * @returns {Number} - the percentile of a property within the collection\n * @see {@link module:aggregate.percentile|percentile} - as this simply hard codes the percentage\n */\nmodule.exports.percentile_25 = function percentile(collection, accessor) {\n  return AggregateUtils.percentile(collection, accessor, 25);\n};\n\n/**\n * Returns a hard coded percentage\n * \n * {@link module:aggregate.percentage|See Percentage for more detail}\n * \n * @param {Object[]} collection - collection of objects\n * @param {Function | String} accessor - function to access the value, string property or null\n * @returns {Number} - the percentile of a property within the collection\n * @see {@link module:aggregate.percentile|percentile} - as this simply hard codes the percentage\n */\nmodule.exports.percentile_50 = function percentile(collection, accessor) {\n  return AggregateUtils.percentile(collection, accessor, 50);\n};\n\n/**\n * Returns a hard coded percentage\n * \n * {@link module:aggregate.percentage|See Percentage for more detail}\n * \n * @param {Object[]} collection - collection of objects\n * @param {Function | String} accessor - function to access the value, string property or null\n * @returns {Number} - the percentile of a property within the collection\n * @see {@link module:aggregate.percentile|percentile} - as this simply hard codes the percentage\n */\nmodule.exports.percentile_75 = function percentile(collection, accessor) {\n  return AggregateUtils.percentile(collection, accessor, 75);\n};\n\n/**\n * Returns a hard coded percentage\n * \n * {@link module:aggregate.percentage|See Percentage for more detail}\n * \n * @param {Object[]} collection - collection of objects\n * @param {Function | String} accessor - function to access the value, string property or null\n * @returns {Number} - the percentile of a property within the collection\n * @see {@link module:aggregate.percentile|percentile} - as this simply hard codes the percentage\n */\nmodule.exports.percentile_90 = function percentile(collection, accessor) {\n  return AggregateUtils.percentile(collection, accessor, 90);\n};\n\n/**\n * Returns a hard coded percentage\n * \n * {@link module:aggregate.percentage|See Percentage for more detail}\n * \n * @param {Object[]} collection - collection of objects\n * @param {Function | String} accessor - function to access the value, string property or null\n * @returns {Number} - the percentile of a property within the collection\n * @see {@link module:aggregate.percentile|percentile} - as this simply hard codes the percentage\n */\nmodule.exports.percentile_95 = function percentile(collection, accessor) {\n  return AggregateUtils.percentile(collection, accessor, 95);\n};\n\n/**\n * Returns a hard coded percentage\n * \n * {@link module:aggregate.percentage|See Percentage for more detail}\n * \n * @param {Object[]} collection - collection of objects\n * @param {Function | String} accessor - function to access the value, string property or null\n * @returns {Number} - the percentile of a property within the collection\n * @see {@link module:aggregate.percentile|percentile} - as this simply hard codes the percentage\n */\nmodule.exports.percentile_99 = function percentile(collection, accessor) {\n  return AggregateUtils.percentile(collection, accessor, 99);\n};\n\n/**\n * Returns the Top N values from within a collection.\n * \n * For example, if we have a list of weather records,\n * we can get the month with the greatest rain.\n * \n * **Note: this can also return the Bottom N values, if sorting in ascending order.\n * ({@link module:array.createSort|see array.createSort() for more.})**\n * \n * ```\n * collection = [\n *   { id: 0, month: '2021-Sep', precip: 2.68 },\n *   { id: 1, month: '2021-Aug', precip: 0.87 },\n *   { id: 2, month: '2021-Oct', precip: 5.31 },\n *   { id: 3, month: '2021-Nov', precip: 3.94 },\n *   { id: 4, month: '2021-Dec', precip: 4.13 },\n *   { id: 5, month: '2022-Jan', precip: 3.58 },\n *   { id: 6, month: '2022-Feb', precip: 3.62 },\n *   { id: 7, month: '2022-Mar', precip: 3.98 },\n *   { id: 8, month: '2022-Apr', precip: 2.56 }\n * ];\n * \n * //-- We can get the top 3 months with the highest rainfall\n * utils.aggregate.topValues(collection, 3, 'month', '-precip');\n * // '2021-Oct', '2021-Dec', '2022-Mar'\n * \n * //-- Or the 3 most recent precipitation values:\n * utils.aggregate.topValues(collection, 3, 'precip', '-id');\n * // 2.56, 3.98, 3.62\n * \n * //-- Lowest Rainfall is simply sorting in ascending order\n * utils.aggregate.topValues(collection, 5, 'month', 'precip');\n * // 0.87, 2.56, 2.68, 3.58, 3.62\n * \n * //-- you can also combine values to make the values clearer, by passing a function\n * const monthPrecip = function (record) => `${record.month} (${record.precip})`;\n * utils.aggregate.topValues(collection, 3, monthPrecip, '-precip');\n * // '2021-Oct (5.31)', '2021-Dec (4.13)', '2022-Mar (3.98)'\n * ```\n * \n * Literal values are also supported\n * \n * ```\n * collection = [ 2.68, 0.87, 5.31, 3.94, 4.13, 3.58, 3.62, 3.98, 2.56 ];\n * \n * //-- top 5 values\n * utils.aggregate.topValues(collection, 5);\n * utils.aggregate.topValues(collection, 5, null, '-')\n * // [5.31, 4.13, 3.98, 3.94, 3.62]\n * \n * //-- bottom 5 values\n * utils.aggregate.topValues(collection, 5, null, '');\n * // \n * ```\n * \n * @param {Array} collection - Collection of values we want to get the top values from\n * @param {Number} [numValues=5] - the number of values to return\n * @param {string | Function} [fieldOrFn = null] - field of the object to use as the value, <br />\n *    Or the Function to generate the value, <br />\n *    Or null if the value is an array of Comparables (like Number)\n * @param  {...String} sortFields - field in the object to sort by,<br />\n *    Prefixed by '-' if it should be sorted in Descending order\n *    (ex: '-Year', 'Manufacturer')\n * @returns {Array} - array of values\n */\nmodule.exports.topValues = function topValues(collection, numValues = 5, fieldOrFn, ...sortFields) {\n  let cleanCollection = collection || [];\n\n  //-- if no sort fields are provided, sort in descending order\n  const cleanSortFields = sortFields.length === 0 ? ['-'] : sortFields;\n  cleanCollection = cleanCollection.sort(ArrayUtils.createSort(...cleanSortFields));\n  return AggregateUtils.property(cleanCollection.slice(0, numValues), fieldOrFn);\n};\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./src/aggregate.js?");

/***/ }),

/***/ "./src/array.js":
/*!**********************!*\
  !*** ./src/array.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint-disable prefer-template, implicit-arrow-linebreak, function-paren-newline */\n\n__webpack_require__(/*! ./_types/global */ \"./src/_types/global.js\");\n\n/**\n * Utility Methods for working with Arrays / Lists\n * \n * similar to {@link module:group}, this is not meant to be exhaustive,\n * only the ones commonly used.\n * \n * * Generate Array\n *   * {@link module:array.size|array.size(size, default)} - generate array of a specific size and CONSISTENT default value\n *   * {@link module:array.arrange|array.arrange(size, start, step)} - generate array of a size, and INCREASING default value\n *   * {@link module:array.arrangeMulti|array.arrangeMulti(n, m, ...)} - generate a multi-dimensional array\n *   * {@link module:array.clone|array.clone(array)} - deep clones arrays\n * * Sorting\n *   * {@link module:array.createSort|array.createSort(sortIndex, sortIndex, ...)} - generates a sorting function\n *   * {@link module:array.SORT_ASCENDING|array.SORT_ASCENDING} - common ascending sorting function for array.sort()\n *   * {@link module:array.SORT_DESCENDING|array.SORT_DESCENDING} - common descending sorting function for array.sort()\n *   * {@link module:array.indexify|array.indexify} - identify sections within a 1d array to create a hierarchy.\n * * Rearrange Array\n *   * {@link module:array.reshape|array.reshape} - reshapes an array to a size of rows and columns\n *   * {@link module:array.transpose|array.transpose} - transposes (flips - the array along the diagonal)\n * * Picking Values\n *   * {@link module:array.peekFirst|array.peekFirst} - peeks at the first value in the list\n *   * {@link module:array.peekLast|array.peekLast} - peeks at the last value in the list\n *   * {@link module:array.pickRows|array.pickRows} - picks a row from a 2d array\n *   * {@link module:array.pickColumns|array.pickColumns} - picks a column from a 2d array\n *   * {@link module:array.pick|array.pick} - picks either/or rows and columns\n *   * {@link module:array.extract|array.extract} - synonym to array.pick to pick either a row or column from an array\n * * Applying a value\n *   * {@link module:array.applyArrayValue|array.applyArrayValue} - applies a value deeply into an array safely\n *   * {@link module:array.applyArrayValues|array.applyArrayValues} - applies a value / multiple values deeply into an array safely\n * * Understanding Values\n *   * {@link module:array.isMultiDimensional|array.isMultiDimensional} - determines if an array is multi-dimensional\n * \n * @module array\n * @exports array\n */\nmodule.exports = {};\nconst ArrayUtils = module.exports;\n\n/**\n * Simple ascending sort function\n * @type {Function}\n * @example\n * \n * [3,5,1,2,4].sort(utils.sort.SIMPLE_ASCENDING))\n * //\n * [1,2,3,4,5]\n */\nmodule.exports.SORT_ASCENDING = (a, b) => a === b ? 0 : a > b ? 1 : -1;\n\n/**\n * Simple descending sort function\n * @example\n * [3,5,1,2,4].sort(utils.sort.SIMPLE_ASCENDING))\n * //\n * [5,4,3,2,1]\n * @type {Function}\n */\nmodule.exports.SORT_DESCENDING = (a, b) => a === b ? 0 : a > b ? -1 : 1;\n\n/**\n * Creates a sort function based on fields of an object.\n * \n * ```\n * sampleData = [{score: 200, name: 'jane'}, {score: 200, name: 'john'}]\n * // sort by score descending, and then by name ascending\n * sampleData.sort(utils.array.createSort('-score','name'))\n * ```\n * \n * @example\n * \n * sampleData = [{i:4}, {v:2}, {v:1}, {v:3}];\n * sortedData = sampleData.sort(\n *    utils.createSort('-v')\n * );\n * // [{v:4}, {v:3}, {v:2}, {v:1}]\n * \n * @param {String} fieldName - name of property to sort by with - for descending\n * @returns {Function}\n **/\nmodule.exports.createSort = (...fields) => {\n  // const fields = Array.from(arguments);\n  if (fields.length < 1) {\n    //-- if nothing is passed, just give an ascending\n    return ArrayUtils.SORT_ASCENDING;\n  } else if (fields.length === 1) {\n    if (!fields[0]) {\n      //-- createSort('') - like for a simple array\n      return ArrayUtils.SORT_ASCENDING;\n    } else if (fields[0] === '-') {\n      //-- createSort('-') - like for a simple array\n      return ArrayUtils.SORT_DESCENDING;\n    }\n  }\n  const sortFunctions = fields.map(field => {\n    if (field && field.length > 0) {\n      if (field[0] === '-') {\n        const newField = field.slice(1);\n        return (a, b) => ArrayUtils.SORT_DESCENDING(a[newField], b[newField]);\n      }\n      return (a, b) => ArrayUtils.SORT_ASCENDING(a[field], b[field]);\n    }\n    return (a, b) => 0;\n  });\n  return (a, b) => {\n    for (const sortFunction of sortFunctions) {\n      const sortResult = sortFunction(a, b);\n      if (sortResult) return sortResult;\n      // continue\n    }\n  };\n};\n\n/**\n * Peek in an array and return the first value in the array.\n * \n * Or return the default value (`defaultVal`) - if the array is empty\n * \n * @param {Array} targetArray - array to be peeked within\n * @param {any} defaultVal - the value to return if the array is empty\n * @returns {any}\n */\nmodule.exports.peekFirst = function peekFirst(targetArray, defaultVal = null) {\n  return Array.isArray(targetArray) && targetArray.length > 0 ? targetArray[0] : defaultVal;\n};\n\n/**\n * Peek in an array and return the last value in the array.\n * \n * Or return the default value (`defaultVal`) - if the array is empty\n * \n * @param {Array} targetArray - array to be peeked within\n * @param {any} defaultVal - the value to return if the array is empty\n * @returns {any}\n */\nmodule.exports.peekLast = function peekLast(targetArray, defaultVal = null) {\n  return Array.isArray(targetArray) && targetArray.length > 0 ? targetArray[targetArray.length - 1] : defaultVal;\n};\n\n/**\n * Picks a row (or multiple rows) from a 2d array.\n * \n * Please also see [Danfo.js](https://danfo.jsdata.org/) for working with DataFrames.\n * \n * @param {Array} array2d - 2d array to pick from [row][column]\n * @param {...Number} rowIndices - Indexes of the row to return, [0...length-1]\n * @returns - Array with only those rows\n * @see {@link module:array.pick|array.pick} - pick either rows or columns\n * @example\n * data = [\n *  ['john', 23, 'purple'],\n *  ['jane', 32, 'red'],\n *  ['ringo', 27, 'green']\n * ];\n * \n * utils.array.pickRows(data, 0);\n * //-- [['john', 23, 'purple']];\n * \n * utils.array.pickRows(data, 0, 1);\n * //-- [['john', 23, 'purple'], ['jane', 32, 'red']];\n */\nmodule.exports.pickRows = function pickRows(array2d, ...rowIndices) {\n  //-- allow passing an array as the first item\n  const cleanRowIndices = rowIndices.length > 0 && Array.isArray(rowIndices[0]) ? rowIndices[0] : rowIndices;\n  return cleanRowIndices.map(index => array2d[index]);\n};\n\n/**\n * Picks a column (or multiple columns) from a 2d array\n * \n * Please also see [Danfo.js](https://danfo.jsdata.org/) for working with DataFrames.\n * \n * @param {Array} array2d - 2d array to pick from [row][column]\n * @param  {...any} columns - Indexes of the columns to pick the values from: [0...row.length-1]\n * @returns - Array with all rows, and only those columns\n * @see {@link module:array.pick|array.pick} - pick either rows or columns\n * @example\n * data = [\n *  ['john', 23, 'purple'],\n *  ['jane', 32, 'red'],\n *  ['ringo', 27, 'green']\n * ];\n * \n * utils.array.pickColumns(data, 0);\n * //-- [['john'], ['jane'], ['ringo']];\n * \n * utils.array.pickColumns(data, 0, 2);\n * //-- [['john', 'purple'], ['jane', 'red'], ['ringo', 'green']];\n */\nmodule.exports.pickColumns = function pickColumns(array2d, ...columns) {\n  //-- allow passing an array as the first item\n  const cleanColumns = columns.length > 0 && Array.isArray(columns[0]) ? columns[0] : columns;\n  return array2d.map(row => cleanColumns.map(columnIndex => row[columnIndex]));\n};\n\n/**\n * Convenience function for picking specific rows and columns from a 2d array.\n * \n * Please also see [Danfo.js](https://danfo.jsdata.org/) for working with DataFrames.\n * \n * @param {Array} array2d - 2d array to pick from [row][column]\n * @param {Object} options - options on which to pick\n * @param {Number[]} [options.rows = null] - indices of the rows to pick\n * @param {Number[]} [options.columns = null] - indices of the columns to pick.\n * @returns {Array} - 2d array of only the rows and columns chosen.\n * @see {@link module:array.pickRows|array.pickRows} - picking rows\n * @see {@link module:array.pickColumns|array.pickColumns} - picking columns\n * @see {@link module:array.applyArrayValues|array.applyArrayValues} - applies a value / multiple values deeply into an array safely\n * @returns - 2dArray of the columns and rows requested\n * @example\n * data = [\n *  ['john', 23, 'purple'],\n *  ['jane', 32, 'red'],\n *  ['ringo', 27, 'green']\n * ];\n * \n * utils.array.pick(data, {rows: [0, 1]});\n * //-- [['john', 23, 'purple'], ['jane', 32, 'red']];\n * \n * utils.array.pick(data, {columns: [0, 2]});\n * //-- [['john', 'purple'], ['jane', 'red'], ['ringo', 'green']];\n * \n * utils.array.pick(data, {rows:[0, 1], columns:[0, 2]});\n * //-- [['john', 'purple'], ['jane', 'red']];\n */\nmodule.exports.pick = function pick(array2d, options) {\n  const cleanOptions = options || {};\n  const {\n    rows = null,\n    columns = null\n  } = cleanOptions;\n  let results = array2d;\n  if (rows) {\n    results = ArrayUtils.pickRows(results, rows);\n  }\n  if (columns) {\n    results = ArrayUtils.pickColumns(results, columns);\n  }\n  return results;\n};\n\n/**\n * Convenience function for picking specific rows and columns from a 2d array.\n * \n * Alias of {@link module:array.pick|array.pick}\n * \n * Please also see [Danfo.js](https://danfo.jsdata.org/) for working with DataFrames.\n * \n * @param {Array} array2d - 2d array to pick from [row][column]\n * @param {Object} options - options on which to pick\n * @param {Number[]} [options.rows = null] - indices of the rows to pick\n * @param {Number[]} [options.columns = null] - indices of the columns to pick.\n * @returns {Array} - 2d array of only the rows and columns chosen.\n * @see {@link module:array.pickRows} - picking rows\n * @see {@link module:array.pickColumns} - picking columns\n * @returns - 2dArray of the columns and rows requested\n * @example\n * data = [\n *  ['john', 23, 'purple'],\n *  ['jane', 32, 'red'],\n *  ['ringo', 27, 'green']\n * ];\n * \n * utils.array.pick(data, {rows: [0, 1]});\n * //-- [['john', 23, 'purple'], ['jane', 32, 'red']];\n * \n * utils.array.pick(data, {columns: [0, 2]});\n * //-- [['john', 'purple'], ['jane', 'red'], ['ringo', 'green']];\n * \n * utils.array.pick(data, {rows:[0, 1], columns:[0, 2]});\n * //-- [['john', 'purple'], ['jane', 'red']];\n */\nmodule.exports.extract = module.exports.pick;\n\n/**\n * Applies deeply onto an array safely - in-place using dot-notation paths\n * even if the child paths don't exist.\n * \n * While tthis can be as simple as safely applying a value even if targetObj may be null\n * \n * ```\n * targetObj = [1, 2, null, 4, 5];\n * \n * utils.object.applyPropertyValue(targetObj, '[2]', 3);\n * // [1, 2, 3, 4, 5]\n * // equivalent to targetObj[2] = 3;\n * ```\n * \n * This is much more safely working with deeply nested objects\n * \n * ```\n * targetObj = [{\n *  name: 'john smith',\n *  class: {\n *    name: 'ECON_101',\n *    professor: {\n *      last_name: 'Winklemeyer'\n *    }\n *   }\n * }];\n * \n * utils.object.applyPropertyValue(targetObj, '[0].class.professor.first_name', 'RenÃ©');\n * // [{\n * //  name: 'john smith',\n * //  class: {\n * //    name: 'ECON_101',\n * //    professor: {\n * //      last_name: 'Winklemeyer',\n * //      first_name: 'RenÃ©' // <- Added\n * //    }\n * //   }\n * // }];\n * ```\n * \n * or creating intermediary objects along the path - if they did not exist first.\n * \n * ```\n * targetObj = [{\n *  name: 'john smith'\n * }];\n * utils.object.applyPropertyValue(targetObj, '[0].class.professor.first_name', 'RenÃ©');\n * [{\n *  name: 'john smith',\n *  class: {\n *    professor: {\n *      first_name: 'RenÃ©'\n *    }\n *   }\n * }];\n * ```\n * \n * @param {Array} collection - array to apply the value to\n * @param {string} path - dot notation path to set the value, ex: 'geo', or 'states[0].prop'\n * @param {any} value - value to set\n * @returns {Array} - the base array\n * @see {@link module:array.pick|array.pick} - to pick a row or column into an array\n * @see {@link module:array.applyArrayValues|array.applyArrayValues} - applies an array safely and deeply onto another array of values\n */\nmodule.exports.applyArrayValue = function applyArrayValue(collection, path, value) {\n  // const signature = 'applyArrayValue(collection, path, value)';\n\n  if (!collection) return collection;\n  if (!path) return collection;\n  const cleanPath = String(path).replace(/\\[/g, '.').replace(/\\]/g, '.').replace(/[.]+/g, '.').replace(/^[.]+/, '').replace(/[.]$/, '');\n  const splitPath = cleanPath.split('.');\n  const terminalIndex = splitPath.length - 1;\n  return splitPath.reduce((currentVal, prop, currentIndex) => {\n    //-- can no longer occur\n    // if (!prop) throw Error(`${signature}:Unable to set value with path:${path}`);\n\n    const isLeaf = currentIndex === terminalIndex;\n    if (isLeaf) {\n      // eslint-disable-next-line no-param-reassign\n      currentVal[prop] = value;\n      // if (value === undefined) {\n      //   delete currentVal[prop];\n      // } else {\n      //   currentVal[prop] = value;\n      // }\n      return collection;\n    }\n    //-- not a leaf\n    if (!currentVal[prop]) {\n      // eslint-disable-next-line no-param-reassign\n      currentVal[prop] = {};\n    }\n    return currentVal[prop];\n  }, collection);\n};\n\n/**\n * Converse from the extractPropertyValue, this takes a value / set of values\n * and applies the values for each index in the collection.\n * \n * for example:\n * \n * ```\n * weather = [{ id: 1, city: 'Seattle',  month: 'Aug', precip: 0.87 },\n *   { id: 3, city: 'New York', month: 'Apr', precip: 3.94 },\n *   { id: 6, city: 'Chicago',  month: 'Apr', precip: 3.62 }];\n * \n * cities = utils.object.extractObjectProperty('city');\n * // ['Seattle', 'New York', 'Chicago'];\n * \n * //-- async process to geocode\n * geocodedCities = geocodeCity(cities);\n * // [{ city: 'Seattle', state: 'WA', country: 'USA' },\n * // { city: 'New York', state: 'NY', country: 'USA' },\n * // { city: 'Chicago', state: 'IL', country: 'USA' }]\n * \n * utils.applyArrayValues(weather, 'geo', geocodedCities);\n * // [{ id: 1, city: 'Seattle',  month: 'Aug', precip: 0.87, geo: { city: 'Seattle', state: 'WA', country: 'USA' } },\n * //  { id: 3, city: 'New York', month: 'Apr', precip: 3.94, geo: { city: 'New York', state: 'NY', country: 'USA' } },\n * //  { id: 6, city: 'Chicago',  month: 'Apr', precip: 3.62, geo: { city: 'Chicago', state: 'IL', country: 'USA' } }];\n * \n * Note that traditional [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\n * works best for if you are working with objects completely in memory.\n * \n * But this helps quite a bit if the action of mapping / transforming values\n * needs to be separate from the extraction / application of values back.\n * \n * @param {Array} collection - array to apply the value to on each index\n * @param {string} path - dot notation path to set the value within each index, ex: 'geo', or 'states[0].prop'\n * @param {any} value - the value that should be set at that path.\n * @returns {Object}\n * @see {@link module:array.applyArrayValue|array.applyArrayValue} - to apply a single value to a single object\n * @see {@link module:array.pick|array.pick} - to pick a row or column into an array\n */\nmodule.exports.applyArrayValues = function applyArrayValues(collection, path, valueList) {\n  // const signature = 'applyValue(objectList, path, valueList)';\n  if (!collection || !path) {\n    //-- do nothing\n    return collection;\n  }\n  const cleanCollection = Array.isArray(collection) ? collection : [collection];\n  const cleanValueList = Array.isArray(valueList) ? valueList : Array(cleanCollection.length).fill(valueList);\n\n  // if (cleanCollection.length !== cleanValueList) throw Error(\n  //   `${signature}: objectList.length[${cleanCollection.length}] does not match valueList.length[${cleanValueList.length}]`\n  // );\n  const minLength = Math.min(cleanCollection.length, cleanValueList.length);\n  for (let i = 0; i < minLength; i += 1) {\n    const obj = cleanCollection[i];\n    const val = cleanValueList[i];\n    ArrayUtils.applyArrayValue(obj, path, val);\n  }\n  return collection;\n};\n\n/**\n * Creates an array of a specific size and default value\n * \n * Especially useful for forLoops, map or reduce\n * \n * @example\n * \n * utils.array.size(3, null)\n *  .map((v, index) => `item ${index}`)\n * \n * @param {Number} length - the length of the new array\n * @param {any} defaultValue - the new value to put in each cell\n * @see {@link module:array.arrange} for values based on the index\n * @returns {Array} - an array of length size with default values\n */\nmodule.exports.size = function size(length, defaultValue) {\n  if (typeof defaultValue === 'function') {\n    return new Array(length).fill(null).map((_, index) => defaultValue(index));\n  }\n  return new Array(length).fill(defaultValue);\n};\n\n/**\n * Creates an array of values to replace for loops\n * \n * @example\n * \n * utils.array.arange(10, 1)\n *  .map((val) => `item ${val}`);\n * //\n * [\n *   'item 1', 'item 2',\n *   'item 3', 'item 4',\n *   'item 5', 'item 6',\n *   'item 7', 'item 8',\n *   'item 9', 'item 10'\n * ]\n * @param {Number} length - the number of items toreturn\n * @param {Number} [start=0] - the starting number\n * @param {Number} [step=1] - the number to increment for each step\n  * @see {@link module:array.size} for consistent values in the array\n * @return {Number[]} - collection of numbers\n */\nmodule.exports.arrange = function arange(len, start = 0, step = 1) {\n  return Array.from(new Array(len)).map((v, i) => i * step + start);\n};\n\n/**\n * @see {@link module:array.arange} synonym\n * @private\n */\nmodule.exports.arange = module.exports.arrange;\n\n/**\n * Determine whether an array is multi-dimensional (an array of arrays)\n * \n * For example:\n * \n * ```\n * utils.array.isMultiDimensional(0); // false\n * utils.array.isMultiDimensional([0,1,2,3]); // false\n * utils.array.isMultiDimensional([[0,1], [2,3]]); // true\n * utils.array.isMultiDimensional([0, [1,2]]); // true\n * ```\n * \n * @param {Array} targetArray - array to check if multi-dimensional\n * @returns {Boolean} - if the targetArray has any values that are multi-dimensional\n */\nmodule.exports.isMultiDimensional = function isMultiDimensional(targetArray) {\n  if (!targetArray || !Array.isArray(targetArray)) {\n    return false;\n  }\n  return targetArray.find(v => Array.isArray(v)) !== undefined;\n};\n\n/**\n * Determines the depth of a two dimensional array\n * @param {Array} targetArray - two dimensional array\n * @returns {Number}\n * @private\n */\nmodule.exports.arrayLength2d = function arrayLength2d(targetArray) {\n  return (targetArray || []).reduce((max, line) => {\n    const len = (line || []).length;\n    return len > max ? len : max;\n  }, 0);\n};\n\n/**\n * Transposes a two dimensional array, so an NxM becomes MxN\n * @param {any[]} matrix - MxN array\n * @returns {any[]} - NxM array\n * \n * @example\n * \n * baseArray = [ 0, 1, 2, 3, 4 ];\n * utils.array.transpose(utils.array.arrange(5))\n * //\n * [ [ 0 ],\n *   [ 1 ],\n *   [ 2 ],\n *   [ 3 ],\n *   [ 4 ] ]\n */\nmodule.exports.transpose = function transpose(matrix) {\n  //-- fast fail\n  if (!matrix || !Array.isArray(matrix)) {\n    return [];\n  }\n\n  //-- check for 1d arrays\n  if (!Array.isArray(matrix[0])) {\n    return matrix.map(v => [v]);\n  }\n\n  //-- for speed, we use for loops.\n  const rows = matrix.length;\n  const cols = ArrayUtils.arrayLength2d(matrix); // matrix[0].length; \n  let colI;\n  let rowI;\n  const result = Array.from(new Array(cols)).map(r => Array.from(new Array(rows)));\n  for (colI = 0; colI < cols; colI += 1) {\n    for (rowI = 0; rowI < rows; rowI += 1) {\n      result[colI][rowI] = matrix[rowI][colI];\n    }\n  }\n  return result;\n};\n\n/**\n * Resizes an NxM dimensional array by number of columns\n * @param {any[]} sourceArray - an array to resize\n * @param {Number} numColumns - number of columns\n * @returns {any[][]} - 2 dimensinal array\n * @example\n * \n * baseArray = utils.array.arrange(12);\n * [\n *    0,  1, 2, 3, 4, 5,  6, 7, 8, 9, 10, 11\n * ]\n * \n * //-- resize the 1d array based on 3 columns\n * newArray = utils.array.reshape(baseArray, 3)\n * [ [ 0, 1, 2 ],\n *   [ 3, 4, 5 ],\n *   [ 6, 7, 8 ],\n *   [ 9, 10, 11 ] ];\n * \n * //-- now resize the 4x3 array to 3x4\n * utils.array.reshape(newArray, 4);\n * [ [ 0, 1, 2, 3 ],\n *   [ 4, 5, 6, 7 ],\n *   [ 8, 9, 10, 11 ] ]\n */\nmodule.exports.reshape = function reshape(sourceArray, numColumns) {\n  const results = [];\n  let resultGroup = [];\n  let column;\n  const array1d = sourceArray.flat();\n  array1d.forEach((value, index) => {\n    column = index % numColumns;\n    if (index > 0 && column === 0) {\n      results.push(resultGroup);\n      resultGroup = [];\n    }\n    resultGroup.push(value);\n  });\n  //-- push the last result group\n  results.push(resultGroup);\n  return results;\n};\n\n/**\n * Deep clones multi-dimensional arrays.\n * \n * If you want to just deep clone a 1d array, use [...target] instead\n * \n * NOTE: this only deep clones Arrays, and not the values within the arrays.\n * \n * ```\n * const sourceArray = [[0, 1], [2, 3]];\n * const targetArray = utils.array.clone(sourceArray);\n * \n * targetArray[0][0] = 99;\n * \n * console.log(targetArray); // [[99, 1], [2, 3]];\n * console.log(sourceArray); // [[0, 1], [2, 3]];\n * ```\n * \n * @param {any | Array} target - Array to be cloned\n * @returns New deep-cloned array\n */\nmodule.exports.clone = function clone(target) {\n  if (!Array.isArray(target)) return target;\n  return target.map(item => Array.isArray(item) ? ArrayUtils.clone(item) : item);\n};\n\n/**\n * Creates an array for multiple dimensions of varying sizes.\n * \n * (In order from higher order dimensions to lower)\n * \n * ```\n * utils.array.arangeMulti(0); // []\n * utils.array.arangeMulti(2); // [0, 1]\n * utils.array.arangeMulti(4); // [0, 1, 2, 3]\n * utils.array.arangeMulti(2, 2); // [[0, 1], [0, 1]]\n * utils.array.arangeMulti(2, 2, 2); // [[[0, 1], [0, 1]], [[0, 1], [0, 1]]]\n * utils.array.arangeMulti(2, 2, 4); // [[[0, 1, 2, 3], [0, 1, 2, 3]], [[0, 1, 2, 3], [0, 1, 2, 3]]]\n * ```\n * \n * Note that this can help with laying items out within a grid\n * \n * ```\n * gridPositions = utils.array.arangeMulti(4, 4)\n *   .reduce((result, row, rowIndex) => [ ...result,\n *      ...row.reduce((rowReduce, value, columnIndex) => [...rowReduce, [rowIndex, columnIndex]], [])\n *   ], []);\n * // [\n * //   [ 0, 0 ], [ 0, 1 ], [ 0, 2 ], [ 0, 3 ],\n * //   [ 1, 0 ], [ 1, 1 ], [ 1, 2 ], [ 1, 3 ],\n * //   [ 2, 0 ], [ 2, 1 ], [ 2, 2 ], [ 2, 3 ],\n * //   [ 3, 0 ], [ 3, 1 ], [ 3, 2 ], [ 3, 3 ]\n * // ]\n * \n * myList.forEach((value, index) => {\n *   const [x, y] = gridPositions[index];\n *   console.log(`placing ${value} in row:${x}, column:${y}`);\n * });\n * ```\n * \n * @param  {...any} dimensions - sizes of each dimension to create\n * @returns Multi-dimensional array \n */\nmodule.exports.arrangeMulti = function arangeMulti(...dimensions) {\n  if (dimensions.length < 1) {\n    return [];\n  } else if (dimensions.length === 1) {\n    return ArrayUtils.arange(dimensions[0]);\n  }\n  const currentDimension = dimensions[0];\n  const remainderDimensions = dimensions.slice(1);\n  const childDimensionalValue = ArrayUtils.arangeMulti.apply(this, remainderDimensions);\n  return ArrayUtils.size(currentDimension, () => ArrayUtils.clone(childDimensionalValue));\n};\nmodule.exports.arangeMulti = module.exports.arrangeMulti;\n\n/** \n * Create a unique number index for each element in an array,\n * alternatively using additional functions to indicate hierarchies of data.\n * \n * For example, markdown can be considered a hierarchy of data:\n * \n * ```\n * markdownList = `# Overview\n * This entire list is a hierarchy of data.\n * \n * # Section A\n * This describes section A\n * \n * ## SubSection 1\n * With a subsection belonging to Section A\n * \n * ## SubSection 2\n * And another subsection sibling to SubSection 1, but also under Section A.\n * \n * # Section B\n * With an entirely unrelated section B, that is sibling to Section A\n * \n * ## SubSection 1\n * And another subsection 1, but this time related to Section B.`;\n * ```\n * \n * And we want to convert this 1d array into a hierarchy.\n * \n * ```\n * data = markdownList.split('\\n')\n *    .filter(line => line ? true : false); // check for empty lines\n * \n * utils.format.consoleLines( data, 4);\n * // ['# Overview',\n * // 'This entire list is a hierarchy of data.',\n * // '# Section A',\n * // 'This describes section A',;\n * \n * //-- functions that return True if we are in a new \"group\"\n * isHeader1 = (str) => str.startsWith('# ');\n * \n * isHeader1('# Overview'); // true\n * isHeader1('This entire list is a hierarchy of data'); // false\n * isHeader1('# Section A'); // true\n * isHeader1('This describes section A'); // false\n * \n * indexedData = utils.array.indexify(data, isHeader1);\n * [\n *   { entry: 'Heading', section: [ 0 ], subIndex: 1 },\n *   { entry: '# Overview', section: [ 1 ], subIndex: 0 },\n *   {\n *     entry: 'This entire list is a hierarchy of data.',\n *     section: [ 1 ],\n *     subIndex: 1\n *   },\n *   { entry: '# Section A', section: [ 2 ], subIndex: 0 },\n *   { entry: 'This describes section A', section: [ 2 ], subIndex: 1 },\n *   { entry: '## SubSection 1', section: [ 2 ], subIndex: 2 },\n *   {\n *     entry: 'With a subsection belonging to Section A',\n *     section: [ 2 ],\n *     subIndex: 3\n *   },\n *   { entry: '## SubSection 2', section: [ 2 ], subIndex: 4 },\n *   {\n *     entry: 'And another subsection sibling to SubSection 1, but also under Section A.',\n *     section: [ 2 ],\n *     subIndex: 5\n *   },\n *   { entry: '# Section B', section: [ 3 ], subIndex: 0 },\n *   {\n *     entry: 'With an entirely unrelated section B, that is sibling to Section A',\n *     section: [ 3 ],\n *     subIndex: 1\n *   },\n *   { entry: '## SubSection 1', section: [ 3 ], subIndex: 2 },\n *   {\n *     entry: 'And another subsection 1, but this time related to Section B.',\n *     section: [ 3 ],\n *     subIndex: 3\n *   }\n * ];\n * ```\n * \n * Note that this only indexes elements by the first header.\n * \n * To index this with two levels of hierarchy, we can pass another function.\n * \n * ```\n * isHeader2 = (str) => str.startsWith('## ');\n * \n * isHeader2('# Overview'); // false\n * isHeader2('This entire list is a hierarchy of data'); // false\n * isHeader2('# Section A'); // true\n * isHeader2('This describes section A'); // false\n * \n * indexedData = utils.array.indexify(data, isHeader1, isHeader2);\n * // [\n * //   { entry: 'Heading', section: [ 0, 0 ], subIndex: 1 },\n * //   { entry: '# Overview', section: [ 1, 0 ], subIndex: 0 },\n * //   {\n * //     entry: 'This entire list is a hierarchy of data.',\n * //     section: [ 1, 0 ],\n * //     subIndex: 1\n * //   },\n * //   { entry: '# Section A', section: [ 2, 0 ], subIndex: 0 },\n * //   { entry: 'This describes section A', section: [ 2, 0 ], subIndex: 1 },\n * //   { entry: '## SubSection 1', section: [ 2, 1 ], subIndex: 0 },\n * //   {\n * //     entry: 'With a subsection belonging to Section A',\n * //     section: [ 2, 1 ],\n * //     subIndex: 1\n * //   },\n * //   { entry: '## SubSection 2', section: [ 2, 2 ], subIndex: 0 },\n * //   {\n * //     entry: 'And another subsection sibling to SubSection 1, but also under Section A.',\n * //     section: [ 2, 2 ],\n * //     subIndex: 1\n * //   },\n * //   { entry: '# Section B', section: [ 3, 0 ], subIndex: 0 },\n * //   {\n * //     entry: 'With an entirely unrelated section B, that is sibling to Section A',\n * //     section: [ 3, 0 ],\n * //     subIndex: 1\n * //   },\n * //   { entry: '## SubSection 1', section: [ 3, 1 ], subIndex: 0 },\n * //   {\n * //     entry: 'And another subsection 1, but this time related to Section B.',\n * //     section: [ 3, 1 ],\n * //     subIndex: 1\n * //   }\n * // ];\n * ```\n * \n * @param {Array} source - list of values to index\n * @param {...Function} sectionIndicatorFunctions - each function indicates a new section\n * @returns {Object[]} - collection of objects, each with a new section (indicating the layers) \n *            and subIndex: unique value in the section (always 0 for header)\n */\nmodule.exports.indexify = function indexify(source, ...sectionIndicatorFunctions) {\n  const functionSignature = 'indexify(source, ...sectionIndicatorFunctions)';\n  const counters = new Array(sectionIndicatorFunctions.length).fill(0);\n  let subIndex = 0;\n  // counters[counters.length - 1] = -1;\n\n  //-- validate inputs\n  if (!Array.isArray(source)) {\n    throw new Error(`${functionSignature}: source must be an array`);\n  }\n  sectionIndicatorFunctions.forEach(fn => {\n    if (typeof fn !== 'function') {\n      throw new Error(`${functionSignature}: all section indicators passed must be functions`);\n    }\n  });\n  const results = source.map(entry => {\n    let isNewSectionTripped = false;\n    sectionIndicatorFunctions.forEach((fn, index) => {\n      if (isNewSectionTripped) {\n        counters[index] = 0;\n      } else {\n        isNewSectionTripped = fn(entry) ? true : false;\n        if (isNewSectionTripped) {\n          counters[index] += 1;\n        }\n      }\n    });\n    if (isNewSectionTripped) {\n      subIndex = 0;\n    } else {\n      subIndex += 1;\n    }\n    return {\n      entry,\n      section: [...counters],\n      subIndex\n    };\n  });\n  return results;\n};\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./src/array.js?");

/***/ }),

/***/ "./src/base64.js":
/*!***********************!*\
  !*** ./src/base64.js ***!
  \***********************/
/***/ ((module) => {

eval("/**\n * Simple library for working with base64 strings\n * \n * * {@link module:base64.toBase64|toBase64(str)} - convert a string to base64\n * * {@link module:base64.fromBase64|fromBase64(str)} - parse a base64 encoded string\n * \n * @module base64\n * @exports base64\n * @example\n * const str = 'Hello';\n * utils.base64.toBase64(str); // 'SGVsbG8=';\n * \n * const b64Str = 'SGVsbG8=';\n * utils.base64.fromBase64(b64Str); // 'Hello';\n */\nmodule.exports = {};\n\n// const Base64Utils = module.exports;\n\n/**\n * Convert a string to base64\n * @param {String} str - string to be converted\n * @returns {String} - base64 encoding of the string\n * @example\n * const str = 'Hello';\n * utils.base64.toBase64(str); // 'SGVsbG8=';\n */\nmodule.exports.toBase64 = function toBase64(str) {\n  return Buffer.from(str).toString('base64');\n};\n\n/**\n * Transfers a base64 string back.\n * @param {String} str - base64 encoded string\n * @returns {String} - decoded string\n * @example\n * const b64Str = 'SGVsbG8=';\n * utils.base64.fromBase64(b64Str); // 'Hello';\n */\nmodule.exports.fromBase64 = function fromBase64(str) {\n  return Buffer.from(str, 'base64').toString();\n};\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./src/base64.js?");

/***/ }),

/***/ "./src/chain.js":
/*!**********************!*\
  !*** ./src/chain.js ***!
  \**********************/
/***/ ((module) => {

eval("/* eslint-disable class-methods-use-this */\n\n/**\n * Simple monad like wrapper.\n * \n * {@link module:chain|See the util.chain method} for more.\n * \n * Very helpful for taking values and then progressively working on them,\n * instead of continually wrapping deeper in method calls.\n * \n * Calling `chain(3)` - gives an object you can then chain calls against:\n * \n * * {@link ChainContainer#close|.close()} - gets the value of the current chain\n * * {@link ChainContainer#chain|.chain(function)} - where it is passed the value, and returns a new Chain with that value.\n * * {@link ChainContainer#errorHandler|.errorHandler(fn)} - custom function called if an error is ever thrown\n * * {@link ChainContainer#debug|.debug()} - console.logs the current value, and continues the chain with that value\n * \n * Along with methods that can iterate on each element, assuming the value in the chain is an Array.\n * \n * * {@link ChainContainer#chainMap|.chainMap(function)} - where it calls the `.map` on value, and applies the function on every item in the array,\n *      storing the result from the function. <br /> <b>(Useful for changing values without changing the original object))</b>\n * * {@link ChainContainer#chainForEach|.chainForEach(function)} - where calls `.forEach` on value, and applies the function on every item,\n *      without storing the result from the function. <br /> <b>(Useful for changing objects in-place)</b>\n * * {@link ChainContainer#chainFlatMap|.chainFlatMap(function)} - where it calls `.flatMap` on value, and applies the function on every item,\n *        flattening the results. <br /> <b>(Useful for expanding an array based on values in the array)</b>\n * * {@link ChainContainer#chainFilter|.chainFilter(function)} - where it calls `.filter` on value, using the function on every item,\n *        keeping the item in the list if the function returns true.\n *        <br /> <b>(Useful for removing items from an array)</b>\n * * {@link ChainContainer#chainReduce|.chainReduce(function, initialValue)} - where it calls `.reduce` on value, and reduces the value\n *        to a single result.\n *        <br /> <b>(Useful for reducing the array to a single value <br /> - like a concatenated string or sum total)</b>\n * \n * There may be times you want to run side effects, or replace the value entirely. (This isn't common, but may be useful on occasion)\n * \n * * {@link ChainContainer#execute|.execute(function)} - where it calls a function, but doesn't pass on the result.\n *        <br /> (This is useful for side-effects, like writing to files)\n * * {@link ChainContainer#replace|.replace(value)} - replaces the value in the chain with a literal value,\n *        regardless of the previous value.\n * \n * For example:\n * \n * ```\n * addTwo = (value) => value + 2;\n * \n * //-- we can always get the value\n * utils.chain(3).close();  // 3\n * ```\n * \n * but this is much easier if we continue to chain it\n * \n * ```\n * addTwo = (value) => value + 2;\n * addTwo(3); // 5\n * \n * utils.chain(3)\n *   .chain(addTwo) // (3 + 2)\n *   .chain(addTwo) // (5 + 2)\n *   .debug() // consoles 7 and passes the value along\n *   // define a function inline\n *   .chain((value) => value + 3) // (7 + 3)\n *   .close()\n * \n * // consoles out value `7`\n * // returns value 10\n * ```\n * \n * Note that we can also map against values in the array\n * \n * ```\n * initializeArray = (size) => Array.from(Array(size)).map((val, index) => index);\n * initializeArray(3); // [0, 1, 2]\n * \n * addTwo = (value) => value + 2;\n * addTwo(3); // 5\n * \n * utils.chain(3)\n *   .chain(initializeArray) // [0, 1, 2]\n *   .chainMap(addTwo) // [2, 3, 4] or [0 + 2, 1 + 2, 2 + 2]\n *   .chainMap(addTwo)\n *   .close();\n * // [4, 5, 6]\n * ```\n * \n * Chain to log results while transforming values\n * \n * ```\n * results = [{ userId: 'abc123' }, { userId: 'xyz987' }];\n * \n * activeUsers = chain(results)\n *  .chainMap((record) => users.get(record.userId))\n *  .chainForEach(record => record.status =  'active')\n *  .chain(records => d3.csv.format(records))\n *  .execute(records => utils.file.writeFile('./log', d3.csv.format(records)))\n *  .close()\n * ```\n * \n * Or even combine with other utility methods\n * \n * ```\n * badStr = 'I%20am%20the%20very%20model%20of%20a%20modern%20Major'\n *  + '-General%0AI\\'ve%20information%20vegetable%2C%20animal%2C%20'\n *  + 'and%20mineral%0AI%20know%20the%20kings%20of%20England%2C%20'\n *  + 'and%20I%20quote%20the%20fights%0AHistorical%0AFrom%20Marath'\n *  + 'on%20to%20Waterloo%2C%20in%20order%20categorical';\n * \n * chain(badStr)\n *     .chain(decodeURIComponent)\n *     .chain(v => v.split('\\n'))\n *     // .debug()                  // check the values along the way\n *     .chainMap(line => ({ line, length: line.length }))\n *     .chain(values => utils.table(values).render());\n * ```\n * \n * this can be more legible than the normal way to write this, <br />\n * especially if you need to troubleshoot the value halfway through.\n * \n * ```\n * utils.table(\n *  decodeURIComponent(badStr)\n *    .split('\\n')\n *    .map(line => ({ line, length: line.length }))\n * ).render()\n * ```\n * \n * and it renders out a lovely table like this:\n * \n * line                                               |length\n * --                                                 |--    \n * I am the very model of a modern Major-General      |45    \n * I've information vegetable, animal, and mineral    |47    \n * I know the kings of England, and I quote the fights|51    \n * Historical                                         |10    \n * From Marathon to Waterloo, in order categorical    |47    \n */\nclass ChainContainer {\n  /**\n   * Custom function to run if there is any error along the chain.\n   * (Scoped to the current Container when running)\n   * @type {Function}\n   * @private\n   */\n  errorHandlerFn;\n\n  /**\n   * Value this container stores, can be anythhing.\n   * \n   * Also access through {@link ChainContainer#close}\n   * \n   * @type {any}\n   */\n  value;\n\n  /**\n   * Constructor that creates a new Container to pass along the chain.\n   * \n   * If the context is null, then we assume we are binding the container to the current iJavaScript cell.\n   * \n   * @param {any} value - the value to use along the chain\n   */\n  constructor(value) {\n    this.value = value;\n  }\n\n  /**\n   * Clones the value, and ties the output to this cell.\n   * @returns {ChainContainer} - new chain container to use in this cell.\n   * @example\n   * \n   * customErrorHandler = (err) => console.error('Some custom warning');\n   * initialChain = utils.chain(3)\n   *   .errorHandler(customErrorHandler);\n   * \n   * newChain = initialChain.clone()\n   *   .chain(v => v + 2) // 3 + 2\n   *   .close();\n   * \n   * // 5\n   */\n  clone() {\n    const result = new ChainContainer(this.value);\n    result.errorHandlerFn = this.errorHandlerFn;\n    return result;\n  }\n\n  /**\n   * Creates a new chain container holding the value returned from functor(this.value)\n   * \n   * ```\n   * value = 2;\n   * plus2 = (value) => value + 2;\n   * \n   * chain(value)\n   *  .chain(plus2) // 2 + 2\n   *  .chain(plus2) // 4 + 2\n   *  .debug()\n   *  .chain(plu2)  // 6 + 2\n   *  .close();\n   * \n   * // 6\n   * // 8\n   * ```\n   * \n   * Or even combine with other utility methods\n   * \n   * ```\n   * badStr = 'I%20am%20the%20very%20model%20of%20a%20modern%20Major'\n   *  + '-General%0AI\\'ve%20information%20vegetable%2C%20animal%2C%20'\n   *  + 'and%20mineral%0AI%20know%20the%20kings%20of%20England%2C%20'\n   *  + 'and%20I%20quote%20the%20fights%0AHistorical%0AFrom%20Marath'\n   *  + 'on%20to%20Waterloo%2C%20in%20order%20categorical';\n   * \n   * chain(badStr)\n   *     .chain(decodeURIComponent)\n   *     .chain(v => v.split('\\n'))\n   *     // .debug()                  // check the values along the way\n   *     .chainMap(line => ({ line, length: line.length }))\n   *     .chain(values => utils.table(values).render());\n   * ```\n   * \n   * and it renders out a lovely table like this:\n   * \n   * line                                               |length\n   * --                                                 |--    \n   * I am the very model of a modern Major-General      |45    \n   * I've information vegetable, animal, and mineral    |47    \n   * I know the kings of England, and I quote the fights|51    \n   * Historical                                         |10    \n   * From Marathon to Waterloo, in order categorical    |47  \n   * \n   * @param {Function} functor - the function given the value, returning a transformed value\n   * @see {@link ChainContainer#chain} - to get the value\n   * @see {@link ChainContainer#chainMap} - convenience to apply a function to each item in an array\n   * @see {@link ChainContainer#chainReduce} - convenience to reduce the array\n   * @see {@link ChainContainer#debug} - to see the value at a specific time\n   * @returns {ChainContainer} - container with the results from functor(this.value)\n   */\n  chain(functor) {\n    try {\n      return this.update(functor(this.value));\n    } catch (err) {\n      this.handleError(err);\n\n      //-- handle error throws again, line will never be called.\n      // this.close();\n    }\n  }\n\n  /**\n   * Assuming that value is an array, this does a\n   * [javascript array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\n   * and applies `fn` to every value in the array.\n   * \n   * ```\n   * initializeArray = (size) => Array.from(Array(size)).map((val, index) => index);\n   * initializeArray(3); // [0, 1, 2]\n   * \n   * addTwo = (value) => value + 2;\n   * addTwo(3); // 5\n   * \n   * utils.chain(3)\n   *   .chain(initializeArray) // [0, 1, 2]\n   *   .chainMap(addTwo) // [2, 3, 4] or [0 + 2, 1 + 2, 2 + 2]\n   *   .chainMap(addTwo)\n   *   .close();\n   * \n   * // [4, 5, 6]\n   * ```\n   * \n   * This is in contrast to {@link ChainContainer#chainForEach|chainForEach}\n   * \n   * @param {Function} fn - applies function under every index of this.value\n   * @returns {ChainContainer} \n   */\n  chainMap(fn) {\n    if (!Array.isArray(this.value)) throw Error(`chainMap expected an array, but was passed:${this.value}`);\n    return this.chain(value => value.map(fn));\n  }\n\n  /**\n   * Assuming that value is an array, performs a \n   * [javaScript forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)\n   * against the results.\n   * \n   * This will run the passed function against every element in the result,\n   * without replacing the element with the returned value and makes inline editing simpler.\n   * \n   * ```\n   * list = [{ first: 'john', last: 'doe' }, { first: 'jane', last: 'doe' }];\n   * utils.chain(list)\n   *  .mapForEach((entry) => entry.name = `${entry.first} ${entry.last})\n   *  .close();\n   * // [{ first: 'john', last: 'doe', name: 'john doe' }, { first: 'jane', last: 'doe', name: 'jane doe' }]\n   * ```\n   * \n   * This is in contrast to {@link ChainContainer#chainMap|chainMap}, that replaces the element with the value returned.\n   * @param {Function(any):any} fn - function to execute on each element\n   * @returns {ChainContainer} - chainable container\n   */\n  chainForEach(fn) {\n    if (!Array.isArray(this.value) && !(this.value instanceof Set) && !(this.value instanceof Map)) {\n      throw Error(`chainForEach expects an array, but was passed:${this.value}`);\n    }\n    this.value.forEach(fn);\n    return this;\n  }\n\n  /**\n   * Assuming that value is an array, performs a\n   * [javaScript flatMap](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap)\n   * against the results.\n   * \n   * This can be very helpful in expanding the list of items in an array, or removing items from an array.\n   * \n   * ```\n   * // expanding size of the array\n   * initializeArray = (size) => Array.from(Array(size)).map((val, index) => index);\n   * initializeArray(3); // [0, 1, 2]\n   * \n   * utils.chain([1, 2, 3, 4])\n   *  .chainFlatMap(initializeArray)\n   *  .close();\n   * \n   * // [1, 1, 2, 1, 2, 3, 1, 2, 3, 4];\n   * ```\n   * \n   * or similar to {@link ChainContainer#chainFilter|chainFilter}\n   * \n   * ```\n   * // reducing the size of the array\n   * filterOdd = (value) => value % 2 === 0 ? [value] : [];\n   * filterOdd(2); // [2]\n   * filterOdd(1); // []\n   * \n   * chain([1, 2, 3, 4, 5])\n   *  .chainFlatMap(filterOdd)\n   *  .close();\n   * \n   * // [2, 4];\n   * ```\n   * \n   * @param {function(any):any} fn - function that can either return a value or array of values.\n   * @returns {ChainContainer}\n   * @see {@link ChainContainer#chainFilter} - for other options in filtering\n   */\n  chainFlatMap(fn) {\n    if (!Array.isArray(this.value)) throw Error(`chainFlatMap expects an array, but was passed:${this.value}`);\n    return this.chain(value => value.flatMap(fn));\n  }\n\n  /**\n   * Assuming that value is an array, this maps fn to filter the results in the array.\n   * \n   * ```\n   * chain([1,2,3,4])\n   *    .chainFilter((value) => value < 3)\n   *    .close();\n   * // [1, 2]\n   * ```\n   * \n   * @param {function(any):Boolean} fn - Function accepting a value and returning whether it should be included (true) or not (false)\n   * @returns {ChainContainer}\n   */\n  chainFilter(fn) {\n    if (!Array.isArray(this.value)) throw Error(`chainFilter expects an array, but was passed:${this.value}`);\n    return this.chain(value => value.filter(fn));\n  }\n\n  /**\n   * Assuming that the value is an array, performs a reduce using fn and initialValue\n   * \n   * ```\n   * initializeArray = (size) => Array.from(Array(size)).map((val, index) => index);\n   * initializeArray(3); // [0, 1, 2]\n   * \n   * addTwo = (value) => value + 2;\n   * addTwo(3); // 5\n   * \n   * utils.chain(3)\n   *   .chain(initializeArray) // [0, 1, 2]\n   *   .chainMap(addTwo) // [2, 3, 4] or [0 + 2, 1 + 2, 2 + 2]\n   *   .debug()\n   *   .chainReduce((result, value) => result + value, 0)\n   *   .close();\n   * \n   * // [2, 3, 4]\n   * // 9\n   * ```\n   * \n   * @param {Function} fn - reducer function\n   * @param {any} initialValue - initial value passed to the reducer\n   * @returns {ChainContainer}\n   */\n  chainReduce(fn, initialValue) {\n    if (!Array.isArray(this.value)) throw Error(`chainReduce expected an array, but was passed:${this.value}`);\n    return this.chain(value => value.reduce(fn, initialValue));\n  }\n\n  /**\n   * Console.logs the value, and returns the unmodified current value.\n   * \n   * ```\n   * value = 2;\n   * plus2 = (value) => value + 2;\n   * \n   * chain(value)\n   *  .chain(plus2) // 2 + 2\n   *  .chain(plus2) // 4 + 2\n   *  .debug()\n   *  .chain(plu2)  // 6 + 2\n   *  .debug((value) => console.log(value))\n   *  .close();\n   * \n   * // 6\n   * // 8\n   * // 8\n   * ```\n   * \n   * @param {Function} [fn=null] - optional custom function\n   * @returns {ChainContainer} - the same value as current, regardless of the result from fn.\n   */\n  debug(fn) {\n    if (fn) {\n      fn(this.value);\n    } else {\n      this.console(this.value);\n    }\n    return this;\n  }\n\n  /**\n   * Applies a function against the current value, while not passing the results along the chain.\n   * \n   * ```\n   * results = [{ userId: 'abc123' }, { userId: 'xyz987' }];\n   * \n   * activeUsers = chain(results)\n   *  .chainMap((record) => users.get(record.userId))\n   *  .chainForEach(record => record.status =  'active')\n   *  .chain(records => d3.csv.format(records))\n   *  .execute(records => utils.file.writeFile('./log', d3.csv.format(records)))\n   *  .close()\n   * ```\n   * \n   * @param {Function} fn - function to execute against the current value\n   * @returns {ChainContainer}\n   */\n  execute(fn) {\n    fn(this.value);\n    return this;\n  }\n\n  /**\n   * Function to call if an error occurs anywhere on the chain.\n   * \n   * ```\n   * someErrorOccurred = false;\n   * flipSwitch = (err) => {\n   *   console.log('custom handler');\n   *   someErrorOccurred = true;\n   * };\n   * throwError = () => {\n   *   throw Error('Custom Error');\n   * };\n   * \n   * chain(2)\n   *   .errorHandler(flipSwitch)\n   *   .chain((value) => value + 2)\n   *   .chain(throwError);\n   * \n   * // customHandler\n   * // {\n   * //   \"name\": \"Error\",\n   * //   \"message\": \"Custom Error\"\n   * // }\n   * // /Users/proth/Documents/notebooks/jupyter-ijavascript-utils/src/chain.js:175\n   * //     throw err;\n   * //     ^\n   * // \n   * // Error: Custom Error\n   * //     at throwError (evalmachine.<anonymous>:7:9)\n   * ```\n   * \n   * @param {Function} errorHandler - function that is passed the error caught\n   */\n  errorHandler(errorHandlerFn) {\n    this.errorHandlerFn = errorHandlerFn;\n    return this;\n  }\n\n  /**\n   * Normally, you will want to replace the value in the chain\n   * based on the current value.\n   * \n   * This replaces the value regardless, and is rarely used.\n   * \n   * @param {any} value - new value in the chain.\n   * @returns {ChainContainer}\n   */\n  replace(value) {\n    this.value = value;\n    return this;\n  }\n\n  /**\n   * Closes the chain and returns the current value.\n   * @returns {any}\n   * @see {@link ChainContainer#chain}\n   * @example\n   * \n   * utils.chain(3)\n   *   .chain(v => v + 2) // 3 + 2\n   *   .close();\n   * \n   * // 5\n   */\n  close() {\n    return this.value;\n  }\n\n  //-- private methods\n\n  /**\n   * Clones the value, and ties the output to this cell.\n   * @param {any} newValue - new value of the clone\n   * @returns {ChainContainer} - new chain container to use in this cell.\n   * @private\n   */\n  update(newValue) {\n    const result = new ChainContainer(newValue);\n    result.errorHandlerFn = this.errorHandlerFn;\n    return result;\n  }\n\n  /**\n   * Default handler catching any error that happens along the chain.\n   * @param {Error} err - the error caught\n   * @private\n   */\n  handleError(err) {\n    if (this.errorHandlerFn) {\n      this.errorHandlerFn.apply(this, [err]);\n    }\n    console.error(JSON.stringify(err, ['name', 'message'], 2));\n\n    // Assert.fail('error occurred. halting.');\n    throw err;\n  }\n\n  /**\n   * call the console regardless of context\n   * @param {any} msg - message to send\n   * @private\n   */\n  console(msg) {\n    console.log(msg); // eslint-disable-line no-console\n  }\n\n  /**\n   * toString replacement\n   * @private\n   */\n  toString() {\n    const {\n      context,\n      ...cleanThis\n    } = this; // eslint-disable-line\n    return JSON.stringify(cleanThis, 2, false);\n  }\n\n  /**\n   * inspect replacement\n   * @private\n   */\n  inspect() {\n    return this.toString();\n  }\n\n  /**\n   * toJSON replacement\n   * @private\n   */\n  toJSON() {\n    const {\n      context,\n      ...cleanThis\n    } = this; // eslint-disable-line\n    return cleanThis;\n  }\n\n  /**\n   * toStringTag used for inspect\n   */\n  // get [Symbol.toStringTag]() {\n  //   return 'Chain';\n  // }\n}\n\n/**\n * Simple monad like wrapper.\n * \n * {@link ChainContainer|See the ChainContainer} for more.\n * \n * Very helpful for taking values and then progressively working on them,\n * instead of continually wrapping deeper in method calls.\n * \n * Calling `chain(3)` - gives an object you can then chain calls against:\n * \n * * {@link ChainContainer#close|.close()} - gets the value of the current chain\n * * {@link ChainContainer#chain|.chain(function)} - where it is passed the value, and returns a new Chain with that value.\n * * {@link ChainContainer#errorHandler|.errorHandler(fn)} - custom function called if an error is ever thrown\n * * {@link ChainContainer#debug|.debug()} - console.logs the current value, and continues the chain with that value\n * \n * Along with methods that can iterate on each element, assuming the value in the chain is an Array.\n * \n * * {@link ChainContainer#chainMap|.chainMap(function)} - where it calls the `.map` on value, and applies the function on every item in the array,\n *      storing the result from the function. <br /> <b>(Useful for changing values without changing the original object))</b>\n * * {@link ChainContainer#chainForEach|.chainForEach(function)} - where calls `.forEach` on value, and applies the function on every item,\n *      without storing the result from the function. <br /> <b>(Useful for changing objects in-place)</b>\n * * {@link ChainContainer#chainFlatMap|.chainFlatMap(function)} - where it calls `.flatMap` on value, and applies the function on every item,\n *        flattening the results. <br /> <b>(Useful for expanding an array based on values in the array)</b>\n * * {@link ChainContainer#chainFilter|.chainFilter(function)} - where it calls `.filter` on value, using the function on every item,\n *        keeping the item in the list if the function returns true.\n *        <br /> <b>(Useful for removing items from an array)</b>\n * * {@link ChainContainer#chainReduce|.chainReduce(function, initialValue)} - where it calls `.reduce` on value, and reduces the value\n *        to a single result.\n *        <br /> <b>(Useful for reducing the array to a single value <br /> - like a concatenated string or sum total)</b>\n * \n * There may be times you want to run side effects, or replace the value entirely. (This isn't common, but may be useful on occasion)\n * \n * * {@link ChainContainer#execute|.execute(function)} - where it calls a function, but doesn't pass on the result.\n *        <br /> (This is useful for side-effects, like writing to files)\n * * {@link ChainContainer#replace|.replace(value)} - replaces the value in the chain with a literal value,\n *        regardless of the previous value.\n * \n * For example:\n * \n * ```\n * addTwo = (value) => value + 2;\n * \n * //-- we can always get the value\n * utils.chain(3).close();  // 3\n * ```\n * \n * but this is much easier if we continue to chain it\n * \n * ```\n * addTwo = (value) => value + 2;\n * addTwo(3); // 5\n * \n * utils.chain(3)\n *   .chain(addTwo) // (3 + 2)\n *   .chain(addTwo) // (5 + 2)\n *   .debug() // consoles 7 and passes the value along\n *   // define a function inline\n *   .chain((value) => value + 3) // (7 + 3)\n *   .close()\n * \n * // consoles out value `7`\n * // returns value 10\n * ```\n * \n * Note that we can also map against values in the array\n * \n * ```\n * initializeArray = (size) => Array.from(Array(size)).map((val, index) => index);\n * initializeArray(3); // [0, 1, 2]\n * \n * addTwo = (value) => value + 2;\n * addTwo(3); // 5\n * \n * utils.chain(3)\n *   .chain(initializeArray) // [0, 1, 2]\n *   .chainMap(addTwo) // [2, 3, 4] or [0 + 2, 1 + 2, 2 + 2]\n *   .chainMap(addTwo)\n *   .close();\n * // [4, 5, 6]\n * ```\n * \n * Chain to log results while transforming values\n * \n * ```\n * results = [{ userId: 'abc123' }, { userId: 'xyz987' }];\n * \n * activeUsers = chain(results)\n *  .chainMap((record) => users.get(record.userId))\n *  .chainForEach(record => record.status =  'active')\n *  .chain(records => d3.csv.format(records))\n *  .execute(records => utils.file.writeFile('./log', d3.csv.format(records)))\n *  .close()\n * ```\n * \n * Or even combine with other utility methods\n * \n * ```\n * badStr = 'I%20am%20the%20very%20model%20of%20a%20modern%20Major'\n *  + '-General%0AI\\'ve%20information%20vegetable%2C%20animal%2C%20'\n *  + 'and%20mineral%0AI%20know%20the%20kings%20of%20England%2C%20'\n *  + 'and%20I%20quote%20the%20fights%0AHistorical%0AFrom%20Marath'\n *  + 'on%20to%20Waterloo%2C%20in%20order%20categorical';\n * \n * chain(badStr)\n *     .chain(decodeURIComponent)\n *     .chain(v => v.split('\\n'))\n *     // .debug()                  // check the values along the way\n *     .chainMap(line => ({ line, length: line.length }))\n *     .chain(values => utils.table(values).render());\n * ```\n * \n * this can be more legible than the normal way to write this, <br />\n * especially if you need to troubleshoot the value halfway through.\n * \n * ```\n * utils.table(\n *  decodeURIComponent(badStr)\n *    .split('\\n')\n *    .map(line => ({ line, length: line.length }))\n * ).render()\n * ```\n * \n * and it renders out a lovely table like this:\n * \n * line                                               |length\n * --                                                 |--    \n * I am the very model of a modern Major-General      |45    \n * I've information vegetable, animal, and mineral    |47    \n * I know the kings of England, and I quote the fights|51    \n * Historical                                         |10    \n * From Marathon to Waterloo, in order categorical    |47    \n * \n * @exports chain\n * @module chain\n */\nmodule.exports = function chain(value) {\n  return new ChainContainer(value);\n};\n\n// example gist: https://gist.github.com/paulroth3d/fc97580636ba706783c6a84467a625db\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./src/chain.js?");

/***/ }),

/***/ "./src/datasets.js":
/*!*************************!*\
  !*** ./src/datasets.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const vegaDatasets = __webpack_require__(/*! vega-datasets */ \"./node_modules/vega-datasets/build/vega-datasets.js\");\nconst fetch = __webpack_require__(/*! node-fetch */ \"./node_modules/node-fetch/browser.js\");\n\n/**\n * Utilities to facilitate working with [vega/vega-datasets](https://github.com/vega/vega-datasets)\n * \n * Vega datasets are a collection of datasets used in Vega and in Vega-Lite examples.\n * \n * The data lives at [https://github.com/vega/vega-datasets](https://github.com/vega/vega-datasets)\n * and [https://cdn.jsdelivr.net/npm/vega-datasets](https://cdn.jsdelivr.net/npm/vega-datasets)\n * \n * **For those of you familiar with Pandas, please consider looking at [danfo.js](https://danfo.jsdata.org/)\n * and [DataFrame.js](https://gmousse.gitbooks.io/dataframe-js/content/#dataframe-js)**\n * \n * * {@link module:datasets.list|list()} - retrieves the list of the datasets available\n * * {@link module:datasets.fetch|fetch(datasetName)} - returns a promise and fetches the dataset\n * \n * @module datasets\n * @exports datasets\n * \n * @example\n * \n * datasets.list(); //-- prints the list of the datasets supported\n * myDataset = datasets.fetch('cars.json');\n * \n */\nmodule.exports = {};\nconst DatasetUtils = module.exports;\n\n//-- setup datasets\n/**\n * Polyfill for 'global.fetch' if your nodejs instance does not have an implementation\n * (and will only polyfill if so);\n * \n * Once executed, global.fetch will have an implementation.\n * \n * {@link https://www.npmjs.com/package/node-fetch|See the `node-fetch` library for more details}\n */\nmodule.exports.polyfillFetch = function polyfillFetch() {\n  if (typeof __webpack_require__.g.fetch === 'undefined') {\n    __webpack_require__.g.fetch = fetch;\n  }\n};\n\n/**\n * Prints the lists of datasets available\n * @returns {String[]} - list of dataset ids that can be fetched.\n * \n * @example\n * \n * datasets.list();\n * \n * // [\n * // 'annual-precip.json',\n * // 'anscombe.json',\n * // 'barley.json',\n * // 'budget.json',\n * // 'budgets.json',\n * // 'burtin.json',\n * // 'cars.json',\n * // 'countries.json',\n * // 'crimea.json',\n * // 'driving.json',\n * // ... ];\n */\nmodule.exports.list = () => Object.keys(vegaDatasets).filter(r => r.endsWith('.json'));\n\n/**\n * Shim for fetching things through the node-fetch library\n * @private\n */\nmodule.exports.nodeFetch = fetch;\n\n/**\n * Fetches a specific dataset from within the list available from [vega-datasets](https://github.com/vega/vega-datasets)\n * \n * Example:\n * \n * Using `utils.datasets.list()` we can see the list of datasets\n * ```\n * ['barley.json', 'cars.json', ...]\n * ```\n * \n * We can then fetch the dataset using that key, and accepting the promise.\n * (Note that this option does not pause execution before running the next cell)\n * \n * ```\n * datasets.fetch('cars.json').then(results => cars = results);\n * [\n *   {\n *     Name: 'chevrolet chevelle malibu',\n *     Miles_per_Gallon: 18,\n *     Cylinders: 8,\n *     Displacement: 307,\n *     Horsepower: 130,\n *     Weight_in_lbs: 3504,\n *     Acceleration: 12,\n *     Year: '1970-01-01',\n *     Origin: 'USA'\n *   },\n *   ...\n * ];\n * ```\n * \n * **Note** - the {@link module:ijs.await|utils.ijs.await method} can simplify this call, to support await.\n * \n * ```\n * utils.ijs.await(async ($$, console) => {\n *   gapMinder = await utils.datasets.load('gapminder.json');\n * });\n * ```\n * \n * @param {string} library - one of the names of the libraries available from list\n * @returns {Promise<any>} - results from the dataset\n * @see #~list\n */\nmodule.exports.fetch = library => {\n  const listSet = new Set(DatasetUtils.list());\n  if (!listSet.has(library)) {\n    throw new Error(`datasets do not contain[${library}] : ${listSet}`);\n  }\n  DatasetUtils.polyfillFetch();\n  return vegaDatasets[library]();\n};\n\n/**\n * Simple `fetch` call for JSON handling simple cases.\n * \n * ```\n * const response = await fetch(targetAddress, options);\n * if (!response.ok) throw new Error(`unexpected response ${response.statusText}`);\n * return response.json();\n * ```\n * \n * @param {String} targetAddress - Address of the file to load\n * @param {Object} options - options to pass to fetch\n * @returns {Object} - parsed JSON of the response\n * \n * @example\n * utils.ijs.await(async ($$, console) => {\n *  worldJSON = await utils.datasets.fetchJSON('https://unpkg.com/world-atlas@1/world/110m.json');\n *  console.log(worldJSON.type); // Topology\n * });\n * \n * // use worldJSON as global variable\n */\nmodule.exports.fetchJSON = async function fetchJSON(targetAddress, options) {\n  const response = await fetch(targetAddress, options || {});\n  if (!response.ok) throw new Error(`unexpected response ${response.statusText}`);\n  return response.json();\n};\n\n/**\n * Simple `fetch` call for Text handling simple cases.\n * \n * ```\n * const response = await fetch(targetAddress, options);\n * if (!response.ok) throw new Error(`unexpected response ${response.statusText}`);\n * return response.text();\n * ```\n * \n * @param {String} targetAddress - Address of the file to load\n * @param {Object} options - options to pass to fetch\n * @returns {Object} - parsed JSON of the response\n * \n * @example\n * utils.ijs.await(async ($$, console) => {\n *     myText = await utils.datasets.fetchText('https://unpkg.com/qr-image@3.2.0/LICENSE');\n *     return myText;\n * });\n * \n * // use myText as global variable\n */\nmodule.exports.fetchText = async function fetchText(targetAddress, options = {}) {\n  const response = await fetch(targetAddress, options);\n  if (!response.ok) throw new Error(`unexpected response ${response.statusText}`);\n  return response.text();\n};\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./src/datasets.js?");

/***/ }),

/***/ "./src/describe.js":
/*!*************************!*\
  !*** ./src/describe.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint-disable max-classes-per-file, class-methods-use-this */\n\nconst FormatUtils = __webpack_require__(/*! ./format */ \"./src/format.js\");\nconst ObjectUtils = __webpack_require__(/*! ./object */ \"./src/object.js\");\n\n/**\n * Module to describe objects or sets of data\n * \n * Describe an array of objects\n *  * {@link module:describe.describeObjects|describeObjects(collection, options)} - given a list of objects, describes each of the fields\n * Describe an array of values (assuming all are the same type)\n *  * {@link module:describe.describeBoolean|describeBoolean(collection, options)} - describes a series of booleans\n *  * {@link module:describe.describeStrings|describeStrings(collection, options)} - describes a series of strings\n *  * {@link module:describe.describeNumbers|describeNumbers(collection, options)} - describes a series of numbers\n *  * {@link module:describe.describeDates|describeDates(collection, options)} - describes a series of dates\n * \n * Most commonly, {@link module:describe.describeObjects|object.describeObjects(collection, options)} is used -\n * as it describes with the appropriate type for each property.\n * \n * Note, if there are multiple child objects within the collection, {@link module:object.flatten|object.flatten()}\n * will bring those values down through dot notation (similar to arrow format) - so they can be better described.\n * \n * @module describe\n * @exports describe\n */\nmodule.exports = {};\nconst DescribeUtil = module.exports;\n\n/**\n * @typedef {Object} DescribeOptions\n * @property {Boolean} uniqueStrings - whether unique strings / frequency should be captured\n */\n\n/**\n * Base Description for a series of values\n * @class\n */\nclass SeriesDescription {\n  /**\n   * Constructor\n   * @param {String} what - description of what is being described\n   * @param {DescribeOptions} options - options for how things are described\n   */\n  constructor(what, type, options) {\n    this.reset();\n    this.what = what;\n    this.type = type;\n    // this.options = options || {};\n  }\n\n  /**\n   * Options used for describing\n   * @type {DescribeOptions}\n   */\n  // options;\n\n  /**\n   * What is being described\n   * @type {String}\n   */\n  what;\n\n  /**\n   * The type of thing being described\n   * @type {String}\n   */\n  type;\n\n  /**\n   * The number of entries reviewed\n   * @type {Number}\n   */\n  count;\n\n  /**\n   * The minimum value found;\n   * @type {any}\n   */\n  min;\n\n  /**\n   * The maximum value found\n   * @type {any}\n   */\n  max;\n\n  /**\n   * Resets the Description to the initial state\n   */\n  reset() {\n    this.count = 0;\n    this.max = null;\n    this.min = null;\n  }\n\n  /**\n   * Validates a value is the type expected\n   * or throws an error if the type is not\n   * or throws false if the value is 'empty'\n   * @param {any} value - value to be checked\n   * @param {String} expectedTypeOf - the type of the value\n   * @returns {Boolean} - true if found and the right type, false if empty\n   * @throws {Error} if the value is the wrong type\n   */\n  check(value, expectedType) {\n    if (FormatUtils.isEmptyValue(value)) {\n      return false;\n    }\n    const valueType = typeof value;\n    if (expectedType && valueType !== expectedType) {\n      throw Error(`describe: Value passed(${value}) expected to be:${expectedType}, but was: ${valueType}`);\n    }\n    this.count += 1;\n    return true;\n  }\n\n  /**\n   * Checks for minimum and maximum values\n   * @param {any} value\n   */\n  checkMinMax(value) {\n    if (this.min === null || value < this.min) {\n      this.min = value;\n    }\n    if (this.max === null || value > this.max) {\n      this.max = value;\n    }\n  }\n\n  /**\n   * Finalizes the review\n   */\n  finalize() {\n    // eslint-disable-line\n    const result = {\n      ...this\n    };\n    // delete result.options;\n    return result;\n  }\n}\n\n/**\n * Describes a series of Boolean Values\n * @augments SeriesDescription\n * @class\n */\nclass BooleanDescription extends SeriesDescription {\n  /**\n   * Mean sum as expressed\n   * @type {number}\n   */\n  mean;\n\n  /**\n   * \n   * @param {String} what - what is being described\n   * @param {DescribeOptions} options - options used for describing\n   */\n  constructor(what, options) {\n    super(what, 'boolean', options);\n    this.reset();\n  }\n  reset() {\n    super.reset();\n    this.mean = 0.0;\n  }\n\n  /**\n   * Whether the value can be described with this\n   * @param {any} value - value to check\n   * @returns {Boolean} - true if the value matches\n   */\n  static matchesType(value) {\n    return FormatUtils.isBoolean(value);\n  }\n  check(value) {\n    if (FormatUtils.isEmptyValue(value)) return;\n    this.count += 1;\n    const cleanValue = FormatUtils.parseBoolean(value) ? 1 : 0;\n    const oldMean = this.mean;\n    this.mean += (cleanValue - oldMean) / this.count;\n    if (this.max === null && cleanValue === 1) this.max = 1;\n    if (this.min === null && cleanValue === 0) this.min = 0;\n  }\n  finalize() {\n    const result = super.finalize();\n    return result;\n  }\n}\n\n/**\n * Describes a series of Numbers\n */\nclass NumberDescription extends SeriesDescription {\n  /**\n   * Mean sum as expressed\n   * @type {number}\n   */\n  mean;\n\n  /**\n   * M2 - sum of squared deviation\n   */\n  m2;\n\n  /**\n   * Standard deviation of the numbers \n   */\n  stdDeviation;\n\n  /**\n   * Constructor\n   * @param {String} what - What is being described\n   * @param {DescribeOptions} options -\n   */\n  constructor(what, options) {\n    super(what, 'number', options);\n    this.reset();\n  }\n  reset() {\n    super.reset();\n    this.mean = 0.0;\n    this.m2 = 0.0;\n    this.stdDeviation = 0.0;\n  }\n\n  /**\n   * Whether the value can be described with this\n   * @param {any} value - value to check\n   * @returns {Boolean} - true if the value matches\n   */\n  static matchesType(value) {\n    return typeof value === 'number';\n  }\n  check(value) {\n    if (!super.check(value, 'number')) return;\n    super.checkMinMax(value);\n\n    /*\n    @see Welford's algorithm\n    @see https://stackoverflow.com/a/1348615\n    @see https://lingpipe-blog.com/2009/03/19/computing-sample-mean-variance-online-one-pass/\n    @see https://lingpipe-blog.com/2009/07/07/welford-s-algorithm-delete-online-mean-variance-deviation/\n    @see https://www.calculator.net/standard-deviation-calculator.html\n    */\n    const oldMean = this.mean;\n    this.mean += (value - oldMean) / this.count;\n    this.m2 += (value - oldMean) * (value - this.mean);\n    // console.log(`value:${value}, this.mean:${this.mean}, oldMean:${oldMean}, stdDeviation:${this.stdDeviation}`);\n  }\n  finalize() {\n    let newDeviation;\n    if (this.count > 1) {\n      newDeviation = Math.sqrt(this.m2 / this.count);\n    } else {\n      newDeviation = 0.0;\n    }\n    // console.log(`updated m2:${this.m2}, stdDeviation:${this.stdDeviation}, count:${this.count}, newDeviation:${newDeviation}`);\n    this.stdDeviation = newDeviation;\n    const result = super.finalize();\n    delete result.m2;\n    return result;\n  }\n}\n\n/**\n * Describes a series of string values\n */\nclass StringDescription extends SeriesDescription {\n  /**\n   * Map of unique values\n   * @type {Map<String,Number>}\n   */\n  uniqueMap;\n\n  /**\n   * Number of unique values;\n   * @type {Number}\n   */\n  unique;\n\n  /**\n   * The most common string\n   * @type {String}\n   */\n  top;\n\n  /**\n   * The frequency of the most common string\n   * @type {Number}\n   */\n  topFrequency;\n\n  /**\n   * Constructor\n   * @param {String} what - What is being described\n   * @param {DescribeOptions} options -\n   */\n  constructor(what, options) {\n    super(what, 'string', options);\n    this.uniqueMap = null;\n    this.reset();\n  }\n  reset() {\n    super.reset();\n    this.uniqueMap = new Map();\n    this.unique = null;\n    this.top = null;\n    this.topFrequency = null;\n  }\n\n  /**\n   * Whether the value can be described with this\n   * @param {any} value - value to check\n   * @returns {Boolean} - true if the value matches\n   */\n  static matchesType(value) {\n    return typeof value === 'string';\n  }\n  check(value) {\n    if (!super.check(value, 'string')) return;\n    if (this.uniqueMap.has(value)) {\n      this.uniqueMap.set(value, this.uniqueMap.get(value) + 1);\n      return;\n    }\n    this.uniqueMap.set(value, 1);\n    const len = value.length;\n    if (this.min === null || len < this.min.length) this.min = value;\n    if (this.max === null || len > this.max.length) this.max = value;\n    // console.log(`len:${len}, min:${this.min}, max:${this.max}`);\n  }\n  finalize() {\n    super.finalize();\n    let currentTop = null;\n    let currentTopFrequency = null;\n    for (const [key, count] of this.uniqueMap.entries()) {\n      if (currentTopFrequency == null || count > currentTopFrequency) {\n        currentTop = key;\n        currentTopFrequency = count;\n      }\n    }\n    this.top = currentTop;\n    this.topFrequency = currentTopFrequency;\n    this.unique = this.uniqueMap.size;\n    this.uniqueMap = null;\n    const result = super.finalize();\n    delete result.uniqueMap;\n    return result;\n  }\n}\n\n/**\n * Describes a series of Dates\n */\nclass DateDescription extends SeriesDescription {\n  /**\n   * Mean sum as expressed\n   * @type {number}\n   */\n  mean;\n\n  /**\n   * Constructor\n   * @param {String} what - What is being described\n   * @param {DescribeOptions} options -\n   */\n  constructor(what, options) {\n    super(what, 'Date', options);\n    this.reset();\n  }\n  reset() {\n    super.reset();\n    this.mean = null;\n  }\n\n  /**\n   * Whether the value can be described with this\n   * @param {any} value - value to check\n   * @returns {Boolean} - true if the value matches\n   */\n  static matchesType(value) {\n    return value instanceof Date; // || (typeof value) === 'number';\n  }\n  check(value) {\n    if (FormatUtils.isEmptyValue(value)) return;\n    let cleanValue;\n    if (value instanceof Date) {\n      cleanValue = value.getTime();\n    } else if (typeof value === 'number') {\n      cleanValue = value;\n    } else {\n      throw Error(`describe: Value passed(${value}) - expected to be type:Date`);\n    }\n    this.count += 1;\n    const oldMean = this.mean;\n    this.mean += (cleanValue - oldMean) / this.count;\n    super.checkMinMax(cleanValue);\n  }\n  finalize() {\n    if (!FormatUtils.isEmptyValue(this.min)) this.min = new Date(this.min);\n    if (!FormatUtils.isEmptyValue(this.max)) this.max = new Date(this.max);\n    if (!FormatUtils.isEmptyValue(this.mean)) this.mean = new Date(this.mean);\n    const result = super.finalize();\n    return result;\n  }\n}\n\n/**\n * Describes a collection of objects.\n * \n * For example, given the following collection:\n * \n * ```\n *  collection = [{\n *      first: 'john',\n *      last: 'doe',\n *      age: 23,\n *      enrolled: new Date('2022-01-01')\n *    }, {\n *      first: 'john',\n *      last: 'doe',\n *      age: 24,\n *      enrolled: new Date('2022-01-03')\n *    }, {\n *      first: 'jan',\n *      last: 'doe',\n *      age: 25,\n *      enrolled: new Date('2022-01-05')\n *    }];\n *  ```\n * \n * Running `utils.describe.describeObjects(collection);` gives:\n * \n *  ```\n *  [{\n *      \"count\": 3,\n *      \"max\": \"john\",\n *      \"min\": \"jan\",\n *      \"top\": \"john\",\n *      \"topFrequency\": 2,\n *      \"type\": \"string\",\n *      \"unique\": 2,\n *      \"what\": \"first\"\n *    }, {\n *      \"count\": 3,\n *      \"max\": \"doe\",\n *      \"min\": \"doe\",\n *      \"top\": \"doe\",\n *      \"topFrequency\": 3,\n *      \"type\": \"string\",\n *      \"unique\": 1,\n *      \"what\": \"last\"\n *    }, {\n *      \"count\": 3,\n *      \"max\": 25,\n *      \"min\": 23,\n *      \"mean\": 24,\n *      \"stdDeviation\": 0.816496580927726,\n *      \"type\": \"number\",\n *      \"what\": \"age\"\n *    }, {\n *      \"count\": 3,\n *      \"max\": \"2022-01-05T00:00:00.000Z\",\n *      \"min\": \"2022-01-01T00:00:00.000Z\",\n *      \"mean\": \"2022-01-03T00:00:00.000Z\",\n *      \"type\": \"Date\",\n *      \"what\": \"enrolled\"\n *  }]\n *  ```\n *\n *  Or Rendered to a table: `utils.table(results).render()`:\n *\n *  what    |type  |count|max                     |min                     |mean                    |top |topFrequency|unique\n *  --      |--    |--   |--                      |--                      |--                      |--  |--          |--    \n *  first   |string|3    |john                    |jan                     |                        |john|2           |2     \n *  last    |string|3    |doe                     |doe                     |                        |doe |3           |1     \n *  age     |number|3    |25                      |23                      |24                      |    |            |      \n *  enrolled|Date  |3    |2022-01-05T00:00:00.000Z|2022-01-01T00:00:00.000Z|2022-01-03T00:00:00.000Z|    |            |         \n *  \n * Note, if there are multiple child objects within the collection, {@link module:object.flatten|object.flatten()}\n * will bring those values down through dot notation (similar to arrow format) - so they can be better described.\n * \n * @param {Object[]} collection - Collection of objects to be described\n * @param {Object} options - options to be used\n * @param {String[]} options.include - string list of fields to include in the description\n * @param {String[]} options.exclude - string list of fields to exclude in the description\n * @param {Object} options.overridePropertyType - object with property:type values (string|number|date|boolean)\n *      - that will override how that property is parsed.\n * @param {Number} maxRows - max rows to consider before halting\n * @returns {SeriesDescription[]} - collection of descriptions - one for each property\n * @see {@link module:object.flatten|object.flatten()} - if the collection of objects have a large number of child objects.\n */\nmodule.exports.describeObjects = function describeObjects(collection, options) {\n  const cleanCollection = Array.isArray(collection) ? collection : [collection];\n  const cleanOptions = options ? options : {};\n  cleanOptions.include = cleanOptions.include ? new Set(cleanOptions.include) : null;\n  cleanOptions.exclude = new Set(cleanOptions.exclude || []);\n  cleanOptions.maxRows = cleanOptions.maxRows || -1;\n\n  // cleanOptions.prepareFn = typeof cleanOptions.prepareFn === 'function'\n  //   ? cleanOptions.prepareFn\n  //   : (val) => val;\n\n  const results = new Map();\n  if (cleanOptions.overridePropertyType) {\n    ObjectUtils.keys(cleanOptions.overridePropertyType).forEach(key => {\n      const keyValue = cleanOptions.overridePropertyType[key];\n      if (keyValue === 'string') {\n        results.set(key, new StringDescription(key, cleanOptions));\n      } else if (keyValue === 'number') {\n        results.set(key, new NumberDescription(key, cleanOptions));\n      } else if (keyValue === 'date') {\n        results.set(key, new DateDescription(key, cleanOptions));\n      } else if (keyValue === 'boolean' || keyValue === 'bool') {\n        results.set(key, new StringDescription(key, cleanOptions));\n      }\n    });\n  }\n  let val;\n  // let describer;\n\n  cleanCollection.every((obj, index) => {\n    if (cleanOptions.maxRows > 0 && index >= cleanOptions.maxRows) {\n      return false;\n    }\n    //-- handles null objects\n    // obj = cleanOptions.prepareFn(obj);\n    ObjectUtils.keys(obj).forEach(key => {\n      val = obj[key];\n      if (cleanOptions.include && !cleanOptions.include.has(key)) {\n        //-- ignore\n      } else if (cleanOptions.exclude.has(key)) {\n        //-- ignore\n      } else if (FormatUtils.isEmptyValue(val)) {\n        //-- do nothing\n      } else {\n        if (Object.prototype.hasOwnProperty.call(results, key)) {\n          //-- describer already found\n        } else if (StringDescription.matchesType(val)) {\n          results[key] = new StringDescription(key);\n        } else if (DateDescription.matchesType(val)) {\n          results[key] = new DateDescription(key);\n        } else if (NumberDescription.matchesType(val)) {\n          results[key] = new NumberDescription(key);\n        } else if (BooleanDescription.matchesType(val)) {\n          results[key] = new BooleanDescription(key);\n        } else {\n          //-- ignore?\n          results[key] = new SeriesDescription(key, typeof val);\n        }\n        results[key].check(val);\n      }\n    });\n    return true;\n  });\n  const resultArray = ObjectUtils.keys(results).map(key => results[key].finalize());\n  return resultArray;\n};\n\n/**\n * Describes a series of numbers\n * @param {String[]} collection - collection of string values to describe\n * @param {Object} options - options for describing strings\n * @returns {StringDescription} - Description of the list of strings\n */\nmodule.exports.describeStrings = function describeStrings(collection, options) {\n  const cleanCollection = Array.isArray(collection) ? collection : [collection];\n  const result = new StringDescription(null, options);\n  cleanCollection.forEach(value => result.check(value));\n  return result.finalize();\n};\n\n/**\n * Describes a series of numbers\n * @param {Number[]} collection - Array of numbers\n * @param {Object} options - options for describing numbers\n * @returns {NumberDescription}\n */\nmodule.exports.describeNumbers = function describeNumbers(collection, options) {\n  const cleanCollection = Array.isArray(collection) ? collection : [collection];\n  const result = new NumberDescription(null, options);\n  cleanCollection.forEach(value => result.check(value));\n  return result.finalize();\n};\n\n/**\n * Describes a series of boolean values.\n * \n * Note, that the following are considered TRUE:\n * \n * * Boolean true\n * * Number 1\n * * String TRUE\n * * String True\n * * String true\n * \n * @param {Boolean[] | String[] | Number[]} collection - Array of Boolean Values\n * @param {Object} options - options for describing boolean values\n * @returns {BooleanDescription}\n * @see {@link module:format.parseBooleanValue}\n */\nmodule.exports.describeBoolean = function describeBoolean(collection, options) {\n  const cleanCollection = Array.isArray(collection) ? collection : [collection];\n  const result = new BooleanDescription(null, options);\n  cleanCollection.forEach(value => result.check(value));\n  return result.finalize();\n};\n\n/**\n * Describes a series of Date / Epoch Numbers\n * \n * @param {Date[] | Number[]} collection - Array of Dates / Epoch Numbers\n * @param {Object} options - options for describing dates\n * @returns {DateDescription}\n */\nmodule.exports.describeDates = function describeDates(collection, options) {\n  const cleanCollection = Array.isArray(collection) ? collection : [collection];\n  const result = new DateDescription(null, options);\n  cleanCollection.forEach(value => result.check(value));\n  return result.finalize();\n};\n\n//-- Testing Internal items\n\n/**\n * Sanity check for standard deviation\n * @param {Number[]} series - collection of numbers\n * @returns {Number} - standard deviation of the numbers\n * @private\n */\nDescribeUtil.stdDeviation = function stdDeviation(series) {\n  let avg = 0;\n  if (series.length < 2) return 0.0;\n  const sum = series.reduce((result, val) => result + val, 0);\n  avg = sum / series.length;\n  const s1 = series.reduce((result, val) => result + (val - avg) ** 2, 0);\n  // console.log(`s1:${s1}`);\n  const s2 = Math.sqrt(s1 / series.length);\n  return s2;\n};\n\n/**\n * Number Description - used for testing\n * @private\n */\nDescribeUtil.NumberDescription = NumberDescription;\n\n/**\n * String Description - used for testing\n * @private\n */\nDescribeUtil.StringDescription = StringDescription;\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./src/describe.js?");

/***/ }),

/***/ "./src/format.js":
/*!***********************!*\
  !*** ./src/format.js ***!
  \***********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint-disable max-len */\n\n/**\n * Utility methods for printing and formatting values\n * \n * * Printing Values to String\n *   * {@link module:format.printValue|format.printValue} - Prints any type of value to string\n *   * {@link module:format#.DATE_FORMAT|format.DATE_FORMAT} - Options for printValue Date Formats (see {@link module:array.printValue|array.printValue(value, options)})\n * * formatting Numbers\n *   * {@link module:format.zeroFill|format.zeroFill} - Pads a number to a specific length\n *   * {@link module:format.divideR|format.divideR}   - Divides a number to provide { integer, remainder } - ex: 5/3 as ( 1, remainder 2 )\n *   * {@link module:format.compactNumber|format.compactNumber} - Converts a number to a compact format, ex: 100K, 2M\n *   * {@link module:format.compactParse|format.compactParse} - Parses a compact number to a true number (very useful for sorting)\n * * Formatting Strings\n *   * {@link module:format.capitalize|format.capitalize} - Capitalizes only the first character in the string (ex: 'John paul');\n *   * {@link module:format.capitalizeAll|format.capitalizeAll} - Capitalizes all the words in a string (ex: 'John Paul')\n *   * {@link module:format.ellipsify|format.ellipsify} - Truncates a string if the length is 'too long'\n *   * {@link module:format.stripHtmlTags|format.stripHtmlTags} - removes html / xml tags from strings.\n *   * {@link module:format.limitLines|format.limitLines(string, toLine, fromLine, lineSeparator)} - selects only a subset of lines in a string\n *   * {@link module:format.consoleLines|format.consoleLines(...)} - same as limit lines, only console.logs the string out.\n *   * {@link module:format.wordWrap|format.wordWrap(str, options)} - breaks apart string by line length\n *   * {@link module:format.lineCount|format.lineCount(str, options)} - counts the number of lines in a string\n * * Replacing values in Strings\n *   * {@link module:format.replaceString|format.replaceString(string, stringTupletsOrMap)} - applies replace from a collection of [matcher, replacement] tuplets or map based on key-> values\n *   * {@link module:format.replaceStrings|format.replaceStrings(stringsArray, stringTupletsOrMap)} - applies replaceString on an array of values\n * * Formatting Time\n *   * {@link module:format.millisecondDuration|format.millisecondDuration}\n * * Mapping Values\n *   * {@link module:format.mapDomain|format.mapDomain} - projects a value from a domain of expected values to a range of output values, ex: 10% of 2 Pi\n *   * {@link module:format.mapArrayDomain|format.mapArrayDomain} - projects a value from between a range a value, and picks the corresponding value from an array\n * * Identifying Time Periods\n *   * {@link module:format.timePeriod|format.timePeriod} - Converts a time to a time period, very helpful for animations\n *   * {@link module:format.timePeriodPercent|format.timePeriodPercent} - Determines the percent complete of the current time period\n * * Converting values safely\n *   * {@link module:format.safeConvertString|format.safeConvertString} - converts a value to string, or uses a default for any error\n *   * {@link module:format.safeConvertFloat|format.safeConvertFloat} - converts a value to a Number (123.4), or uses a default for any error or NaN\n *   * {@link module:format.safeConvertInteger|format.safeConvertInteger} - converts a value to a Number (123), or uses a default for any error or NaN\n *   * {@link module:format.safeConvertBoolean|format.safeConvertBoolean} - converts a value to a boolean\n * * Parsing values\n *   * {@link module:format.parseBoolean|format.parseBoolean(val)} - converts a value to a boolean value\n *   * {@link module:format.parseNumber|format.parseNumber(val, locale)} - converts a value to a number\n * * Identifying values\n *   * {@link module:format.isEmptyValue|format.isEmptyValue} - determine if a value is not 'empty'\n * * Extracting values\n *   * {@link module:format.extractWords|format.extractWords} - to extract the words from a string\n * \n * @module format\n * @exports format\n */\nmodule.exports = {};\nconst FormatUtils = module.exports; // eslint-disable-line no-unused-vars\n\n__webpack_require__(/*! ./_types/global */ \"./src/_types/global.js\");\n\n/**\n * The number of milliseconds of various time durations\n * @private\n */\nmodule.exports.DURATION = {\n  MILLISECOND: 1,\n  SECOND: 1000,\n  MINUTE: 1000 * 60,\n  HOUR: 1000 * 60 * 60,\n  DAY: 1000 * 60 * 60 * 24\n};\n\n/**\n * Date Formats\n * @type {DateFormat}\n * @see {@link module:format.printValue|printValue()} -\n * @see {@link TableGenerator} - \n * @example\n * d = new Date();\n * format = { dateFormat: utils.format.DATE_FORMAT.LOCAL }; // .LOCAL = 'toLocaleString'\n * utils.format.printValue( new Date(), format)\n * //3/8/2022, 4:22:38 PM\n * \n * format = { dateFormat: utils.format.DATE_FORMAT.LOCAL_DATE }; // .LOCAL_DATE = 'toLocaleDateString'\n * utils.format.printValue( new Date(), format)\n * //3/8/2022\n * \n * format = { dateFormat: utils.format.DATE_FORMAT.LOCAL_TIME }; // .LOCAL_TIME = 'toLocaleTimeString'\n * utils.format.printValue( new Date(), format)\n * //4:22:38 PM\n * \n * format = { dateFormat: utils.format.DATE_FORMAT.GMT }; // .GMT = 'toGMTString'\n * utils.format.printValue( new Date(), format)\n * //Tue, 08 Mar 2022 22:22:38 GMT\n * \n * format = { dateFormat: utils.format.DATE_FORMAT.ISO }; // .ISO = 'toISOString'\n * utils.format.printValue( new Date(), format)\n * //2022-03-08T22:22:38.163Z\n * \n * format = { dateFormat: utils.format.DATE_FORMAT.UTC }; // .UTC = 'toUTCString'\n * utils.format.printValue( new Date(), format)\n * //Tue, 08 Mar 2022 22:22:38 GMT\n * \n * format = { dateFormat: utils.format.DATE_FORMAT.NONE };\n * utils.format.printValue( new Date(), format)\n * //Tue Mar 08 2022 16:22:38 GMT-0600 (Central Standard Time)\n */\nmodule.exports.DATE_FORMAT = {\n  LOCAL: 'toLocaleString',\n  LOCAL_DATE: 'toLocaleDateString',\n  LOCAL_TIME: 'toLocaleTimeString',\n  GMT: 'toGMTString',\n  ISO: 'toISOString',\n  UTC: 'toUTCString',\n  NONE: 'NONE'\n};\n\n/**\n * Ellipsis unicode character `â€¦`\n * @type {String}\n * @private\n * @example\n * utils.format.ellipsis('supercalifragilisticexpialidocious', 5)\n * // superâ€¦\n */\nmodule.exports.ELLIPSIS = 'â€¦';\n\n/**\n * Print a value in legible string format\n * \n * Note: collapsing \n * \n * @param {any} value - the value to print\n * @param {Object} options - collection of options\n * @param {Boolean} options.collapseObjects - if true, typesof Object values are not expanded\n * @param {String} options.dateFormat - ('LOCAL'|'LOCAL_DATE','LOCAL_TIME','GMT','ISO','UTC','NONE')\n * @returns {string} - legible formatted value\n * @see #.DATE_FORMAT\n * @example\n * \n * format = { dateFormat: utils.format.DATE_FORMAT.ISO };\n * utils.format.printValue( new Date(), format)\n * //2022-03-08T22:22:38.163Z\n * \n * //-- but you will mostly be using this in aggregate, like with the TableGenerator\n * \n * obj = { first: 'john', last: 'doe', classes: [23, 34], professor: { name: 'jane doe' }, dateTime: new Date(), aliases: new Set(['jdoe', 'j_doe'])}\n * new utils.TableGenerator([obj])\n *   .generateMarkdown();\n * \n * //-- with many objects, this can get unweildy\n * first|last|classes|professor          |dateTime                |aliases                  \n * --   |--  |--     |--                 |--                      |--                       \n * john |doe |[23,34]|{\"name\":\"jane doe\"}|2022-03-08T22:50:03.632Z|\"Set(\\\"jdoe\\\",\\\"j_doe\\\")\"\n * \n * new utils.TableGenerator([obj])\n *   .printOptions({ collapse: true, dateFormat: 'toLocaleDateString' })\n *   .generateMarkdown();\n * \n * //-- a bit more easy to read\n * first|last|classes|professor      |dateTime|aliases     \n * --   |--  |--     |--             |--      |--          \n * john |doe |23,34  |[object Object]|3/8/2022|[object Set]\n * \n */\nmodule.exports.printValue = function printValue(value, options) {\n  const {\n    dateFormat = FormatUtils.DATE_FORMAT.ISO,\n    collapseObjects = false,\n    collapse = false\n  } = options || {};\n  if (value === null) {\n    return 'null';\n  } else if (value === undefined) {\n    return 'undefined';\n  }\n  const valType = typeof value;\n  if (valType === 'string') {\n    return value;\n  } else if (valType === 'number') {\n    return value.toLocaleString();\n  } else if (value instanceof Date) {\n    if (dateFormat === FormatUtils.DATE_FORMAT.NONE) {\n      return String(value);\n    }\n    return value[dateFormat || FormatUtils.DATE_FORMAT.ISO]();\n  } else if (value instanceof Map) {\n    if (collapseObjects || collapse) {\n      return `[Map length=${value.size} ]`;\n    }\n    return JSON.stringify(value, FormatUtils.mapReplacer);\n  } else if (typeof value[Symbol.iterator] === 'function') {\n    //-- iterator\n    return JSON.stringify(Array.from(value));\n  } else if (valType === 'object' && (collapseObjects || collapse)) {\n    return String(value);\n  }\n  return JSON.stringify(value);\n};\n\n/**\n * Print a number and zero fill it until it is len long.\n * \n * @param {Number} num - Number to be converted\n * @param {Number} [len = 3] - the length of the string\n * @param {String} [fill = '0'] - the value to pad with \n * @returns {String}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padStart|MDN - Pad Start} - for padding strings at the start\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padEnd|MDN - Pad End} - for padding strings at the end\n * @example\n * utils.format.zeroFill(23)         // '023';\n * utils.format.zeroFill(23, 5)      // '00023';\n * utils.format.zeroFill(23, 5, ' ') // '   23'\n */\nmodule.exports.zeroFill = function zeroFill(num, len = 3, fill = '0') {\n  return String(num).padStart(len, fill);\n};\n\n/**\n * Generate a random Integer between a maximum and a minimum number\n * \n * @param {Number} max - maximum value\n * @param {Number} min - minimum value\n * @returns {Number}\n * \n * @example\n * utils.format.randomInt(10) // 4\n * utils.format.randomInt(20, 10) // 11\n */\nmodule.exports.randomInt = function randomInt(max, min = 0) {\n  return Math.trunc(Math.random() * (max - min) + min);\n};\n\n/**\n * Generate a random Float between a maximum and minimum number\n * @param {Number} max - maximum value\n * @param {Number} min - minimum value\n * @returns {Number}\n * \n * @example\n * utils.format.randomFloat(10) // 7.21323\n * utils.format.randomFloat(10) // 4.2232392\n */\nmodule.exports.randomFloat = function randomFloat(max, min = 0) {\n  return Math.random() * (max - min) + min;\n};\n\n/**\n * Replaces maps with strings.\n * \n * @see SourceMap.stringifyReducer for other instances.\n * @private\n */\nmodule.exports.mapReplacer = function replacer(key, value) {\n  if (value instanceof Map) {\n    return {\n      dataType: 'Map',\n      value: Array.from(value.entries()) // or with spread: value: [...value]\n    };\n  }\n  return value;\n};\n\n/**\n * Divide a number and get the integer value and remainder\n * @param {Number} numerator - number to be divided\n * @param {Number} denominator - number to divide with\n * @returns {Object} - ({value, remainder}) \n * @example\n * utils.format.divideR(5, 3)\n * // ({ value: 1, remainder: 2 })\n */\nmodule.exports.divideR = function divideR(numerator, denominator) {\n  return {\n    value: Math.trunc(numerator / denominator),\n    remainder: numerator % denominator\n  };\n};\n\n/**\n * @typedef {Object} Duration\n * @property {Number} days -\n * @property {Number} hours -\n * @property {Number} minutes -\n * @property {Number} seconds -\n * @property {Number} milliseconds -\n * @property {Number} epoch - the total duration in milliseconds\n */\n\n/**\n * Determines the length of time that a number of milliseconds take in duration\n * @param {Number} milliseconds - Number of millisecond duration\n * @returns {Duration}\n * @example\n * d1 = new Date();\n * // 2022-03-08T22:55:14.775Z\n * d2 = new Date(d1.getTime())\n * // 2022-03-08T23:02:18.040Z\n * \n * utils.format.millisecondDuration(d2.getTime() - d1.getTime())\n * // {\n * //   days: 0,\n * //   hours: 0,\n * //   minutes: 7,\n * //   seconds: 3,\n * //   milliseconds: 265,\n * //   epoch: 423265\n * // }\n */\nmodule.exports.millisecondDuration = function millisecondDuration(milliseconds) {\n  const result = {};\n  let division = FormatUtils.divideR(milliseconds, FormatUtils.DURATION.DAY);\n  result.days = division.value;\n  division = FormatUtils.divideR(division.remainder, FormatUtils.DURATION.HOUR);\n  result.hours = division.value;\n  division = FormatUtils.divideR(division.remainder, FormatUtils.DURATION.MINUTE);\n  result.minutes = division.value;\n  division = FormatUtils.divideR(division.remainder, FormatUtils.DURATION.SECOND);\n  result.seconds = division.value;\n  result.milliseconds = division.remainder;\n  result.epoch = milliseconds;\n  return result;\n};\n\n/**\n * Ellipsifies a string (but only if it is longer than maxLen)\n * \n * @param {String} str - string to be ellipsified\n * @param {Integer} [maxLen = 50] - the maximum length of str before getting ellipsified\n * @returns {String}\n * @example\n * format.ellipsify('longName') // 'longName' (as maxLen is 50)\n * format.ellipsify('longName', 8) // 'longName' (as maxLen is 8)\n * format.ellipsify('longName', 4) // 'longâ€¦' (as str is longer than maxLen)\n */\nmodule.exports.ellipsify = function ellipsify(str, maxLen) {\n  const cleanStr = !str ? '' : typeof str === 'string' ? str : JSON.stringify(str);\n  const cleanLen = maxLen > 0 ? maxLen : 50;\n  if (cleanStr.length > cleanLen) {\n    return `${cleanStr.substring(0, cleanLen)}â€¦`;\n  }\n  return cleanStr;\n};\n\n/**\n * projects a value from a domain of expected values to a range of output values, ex: 10% of 2 Pi.\n * \n * This is SUPER helpful in normalizing values, or converting values from one \"range\" of values to another.\n * \n * @param {Number} val - value to be mapped\n * @param {Array} domain - [min, max] - domain of possible input values\n * @param {Array} domain.domainMin - minimum input value (anything at or below maps to rangeMin)\n * @param {Array} domain.domainMax - maximum input value (anything at or above maps to rangeMax)\n * @param {Array} range - [min, max] - range of values to map to\n * @param {Array} range.rangeMin - minimum output value\n * @param {Array} range.rangeMax - maximum output value\n * @returns Number\n * @see {@link module:format.clampDomain|clampDomain(value, [min, max])}\n * @example\n * \n * format.mapDomain(-2, [0, 10], [0, 1])\n * // 0   - since it is below the minimum value\n * format.mapDomain(0, [0, 10], [0, 1])\n * // 0   - since it is the minimum value\n * format.mapDomain(5, [0, 10], [0, 1])\n * // 0.5 - since it is 5/10\n * format.mapDomain(12, [0, 10], [0, 1])\n * // 1   - since it is above the maximum value\n * \n * format.mapDomain(0.5, [0, 1], [0, 10])\n * format.mapDomain(0.5, [0, 1], [0, Math.PI + Math.PI])\n * // 5 - since it is half of 0-1, and half of 1-10\n * // 3.1415 or Math.PI - since it is half of 2 PI\n */\nmodule.exports.mapDomain = function mapDomain(val, [domainMin, domainMax], [rangeMin = 0, rangeMax = 1]) {\n  if (val < domainMin) {\n    return rangeMin;\n  } else if (val > domainMax) {\n    return rangeMax;\n  }\n  // domainMin / val / domainMax = rangeMin / result / rangeMax\n  // (val - domainMin) / (domainMax - domainMin) = (result - rangeMin) / (rangeMax - rangeMin)\n  // (val - domainMin) * (rangeMax - rangeMin) / (domainMax - domainMin) = result - rangeMin;\n  // (val - domainMin) * (rangeMax - rangeMin) / (domainMax - domainMin) + rangeMin = result\n  return (val - domainMin) * (rangeMax - rangeMin) / (domainMax - domainMin) + rangeMin;\n};\n\n/**\n * projects a value from a domain of expected values to an array - very useful for random distributions.\n * \n * like mapping normal / gaussian distributions to an array of values with \n * [d3-random](https://observablehq.com/@d3/d3-random)\n * as format.mapArrayDomain projects a value from between a range a value,\n * and picks the corresponding value from an array.\n * \n * For example:\n * \n * ```\n * require('esm-hook');\n * d3 = require('d3');\n * utils = require('jupyter-ijavascript-utils');\n * \n * //-- create a number generator using Normal / Gaussian distribution\n * randomGenerator = d3.randomNormal(\n *  0.5, // mu - or centerline\n *  0.1 // sigma - or spread of values\n * );\n * \n * randomValue = randomGenerator();\n * // randomValue - 0.4\n * \n * randomDataset = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'];\n * \n * numPicks = 3; // increase to a larger number (ex: 1000) to better see distributions\n * \n * //-- create an array of 3 items, each with the results from randomGenerator\n * results = utils.array.size(numPicks, () => randomGenerator());\n * // [ 0.6235937672428706, 0.4991359903898883, 0.4279365561645624 ]\n * \n * //-- map those values to the randomDataset\n * resultPicks = results.map(val => ({ pick: utils.format.mapArrayDomain(val, randomDataset) }));\n * // [ { pick: 'g' }, { pick: 'e' }, { pick: 'e' } ]\n * \n * //-- group them by the pick field\n * //-- then add a new property called count - using the # of records with the same value\n * groupedResults = utils.group.by(resultPicks, 'pick')\n *     .reduce((list) => ({ count: list.length }));\n * // [ { pick: 'g', count: 1 }, { pick: 'e', count: 2 } ]\n * \n * //-- make a bar chart (only with 10k results)\n * utils.vega.embed((vl) => {\n *     return vl\n *       .markBar()\n *       .title('Distribution')\n *       .data(groupedResults)\n *       .encode(\n *         vl.x().fieldN('pick'),\n *         vl.y().fieldQ('count').scale({type: 'log'})\n *       );\n * });\n * ```\n * ![Screenshot of the chart above](img/randomMap_normalDistribution.png)\n * \n * @param {Number} val - value to be mapped\n * @param {Array} targetArray - array of values to pick from\n * @param {Array} domain - [min, max] - domain of possible input values\n * @param {Array} [domain.domainMin = 0] - minimum input value (anything at or below maps to rangeMin)\n * @param {Array} [domain.domainMax = 1] - maximum input value (anything at or above maps to rangeMax)\n * @returns Number\n * @see {@link module:format.clampDomain|clampDomain(value, [min, max])}\n * @example\n * \n * //-- array of 10 values\n * randomArray = ['a', 'b', 'c', 'd', 'e'];\n * \n * format.mapArrayDomain(-1, randomArray, [0, 5]);\n * // 'a'  - since it is below the minimum value\n * format.mapArrayDomain(6, randomArray, [0, 5]);\n * // 'e'   - since it is the minimum value\n * \n * format.mapArrayDomain(0.9, randomArray, [0, 5]);\n * // 'a'\n * format.mapArrayDomain(1, randomArray, [0, 5]);\n * // 'b'\n * format.mapArrayDomain(2.5, randomArray, [0, 5]);\n * // 'c' \n * \n * //-- or leaving the domain of possible values value can be out:\n * format.mapArrayDomain(0.5, randomArray); // assumed [0, 1]\n * // 'c'\n */\nmodule.exports.mapArrayDomain = function mapArrayDomain(val, targetArray, domain = null) {\n  if (!targetArray || !Array.isArray(targetArray)) {\n    throw Error('mapArrayDomain: targetArray is not an array');\n  } else if (targetArray.length < 1) {\n    throw Error('mapArrayDomain: targetArray is not a populated array');\n  }\n  const cleanArray = domain || [];\n  const [domainMin = 0, domainMax = 1] = cleanArray;\n  if (val <= domainMin) {\n    return targetArray[0];\n  } else if (val >= domainMax) {\n    return targetArray[targetArray.length - 1];\n  }\n  const targetIndex = Math.floor(FormatUtils.mapDomain(val, [domainMin, domainMax], [0, targetArray.length]));\n  // console.log(targetIndex);\n  return targetArray[targetIndex];\n};\n\n/**\n * Given that a period of time is millisecondPeriod number of milliseconds long,\n * determines which period of time we are currently in (timeEpoch / millisecondPeriod)\n * \n * This is especially handy for animations or cyclical time measuring.\n * \n * **NOTE: consider sending the timeEpoch relative to a separate start time**,\n * it is rarely ever needed to know how many 10 second intervals occurred since 1970...\n * \n * Likely, we care more that the animation should have cycled 40 times since the page loaded though.\n * \n * @param {Integer} millisecondPeriod - Number of Milliseconds in a Period of time\n * @param {Integer} [timeMilli = now] - optional time to check - in epoch milliseconds\n * @param {Integer} [startMilli = null] - optional starting epoch\n * @returns {Number} - (timeEpoch - startEpoch) / millisecondPeriod - number of periods \n * \n * @example\n * const startTime = new Date().getTime();\n * \n * format.timePeriod(1000)\n * // 164955061.3 - using the current time and epoch starting point\n * \n * format.timePeriod(1000, new Date().getTime(), startTime);\n * // 0.0 - using the starting point instead\n * \n * // - wait 3 seconds\n * \n * format.timePeriod(10000, new Date().getTime(), startTime); // 0.3\n * format.timePeriod(10000, null, startTime); // 0.3\n * \n * // - wait another 14 seconds\n * \n * format.timePeriod(10000, new Date().getTime(), startTime); // 1.7\n * \n * //-- wait 8 seconds\n * \n * format.timePeriod(10000, new Date().getTime(), startTime) // 2.5\n */\nmodule.exports.timePeriod = function mapTime(millisecondPeriod, timeMilli = null, startMilli = null) {\n  let updatedMilli = !timeMilli ? new Date().getTime() : timeMilli;\n  if (startMilli) {\n    updatedMilli -= startMilli;\n  }\n  return updatedMilli / millisecondPeriod;\n};\n\n/**\n * Given that a period of time is millisecondPeriod number of milliseconds long,\n * determines how far along in the CURRENT PERIOD.\n * \n * This is especially handy for animations or cyclical time measuring.\n * \n * @param {Integer} millisecondPeriod - Number of Milliseconds in a Period of time\n * @param {Integer} [timeEpoch = now] - time to check - in epoch milliseconds\n * @returns {Number} - percentage through the current millisecond period (0 <= x < 1)\n * \n * @example\n * format.timePeriodPercent(10000, new Date().getTime()) // 0.3\n * \n * //-- wait 14 seconds\n * \n * format.timePeriodPercent(10000, new Date().getTime()) // 0.7\n * \n * //-- wait 8 seconds\n * \n * format.timePeriodPercent(10000, new Date().getTime()) // 0.5\n */\nmodule.exports.timePeriodPercent = function mapEpochInPeriod(millisecondPeriod, timeEpoch = new Date().getTime()) {\n  return timeEpoch % millisecondPeriod / millisecondPeriod;\n};\n\n/**\n * Clamps (restircts) a value to a specific domain.\n * \n * Meaning if value is less than minimum, then the minimum is returned.\n * If the value is greater than the maximum, then the maximum is returned.\n * \n * NOTE: null or undefined are not treated specially when comparing to maximum or minimum values.\n * \n * @param {Number} value - the value that will be modified if less than min or max\n * @param {Array} domain - Domain of min and max values\n * @param {Number} domain.min - the minimum value allowable\n * @param {Number} domain.max - the maximum value allowable\n * @returns {Number} - minimum if value is less than minimum, maximum if more, value otherwise.\n * \n * @see {@link module:format.mapDomain|mapDomain(value, [min, max], [newMin, newMax])}\n * @example\n * format.clampDomain( -1, [0, 1]); // 0\n * format.clampDomain( 2, [0, 1]); // 1\n * format.clampDomain( 0.5, [0, 1]); // 0.5\n **/\nmodule.exports.clampDomain = function clampDomain(value, [minimum, maximum]) {\n  if (value < minimum) {\n    return minimum;\n  } else if (value > maximum) {\n    return maximum;\n  }\n  return value;\n};\n\n/**\n * Capitalizes the first character of the string.\n * \n * @param {String} str - String to capitalize the first letter only\n * @returns {String} - ex: 'John paul'\n * @see {@link module:format.capitalizeAll|capitalizeAll} - to capitalize all words in a string\n * @example\n * utils.format.capitalize('john'); // 'John'\n * utils.format.capitalize('john doe'); // 'John doe'\n */\nmodule.exports.capitalize = function capitalize(str) {\n  if (!str || str.length === 0) {\n    return '';\n  }\n\n  //-- charAt does not work for unicode\n  const [first, ...rest] = str;\n  return first.toLocaleUpperCase() + rest.join('');\n};\n\n/**\n * Capitalizes all words in a string.\n * \n * @param {String} str - String to capitalize\n * @returns {String} - ex: 'John-Paul'\n * @see {@link module:format.capitalizeAll|capitalizeAll} - to capitalize all words in a string\n * @example\n * utils.format.capitalize('john'); // 'John'\n * utils.format.capitalize('john doe'); // 'John Doe'\n * utils.format.capitalize('john-paul'); // 'John-Paul'\n */\nmodule.exports.capitalizeAll = function capitalizeAll(str) {\n  return (str || '').split(/\\b/).map(FormatUtils.capitalize).join('');\n};\n\n/* eslint-disable comma-spacing */\nmodule.exports.metricSI = [['Y', {\n  key: 'Y',\n  name: 'yotta',\n  value: 10 ** 24,\n  fullName: 'Septillion'\n}], ['Z', {\n  key: 'Z',\n  name: 'zetta',\n  value: 10 ** 21,\n  fullName: 'Sextillion'\n}], ['E', {\n  key: 'E',\n  name: 'exa',\n  value: 10 ** 18,\n  fullName: 'Quintillion'\n}], ['P', {\n  key: 'P',\n  name: 'peta',\n  value: 10 ** 15,\n  fullName: 'Quadrillion'\n}], ['T', {\n  key: 'T',\n  name: 'tera',\n  value: 10 ** 12,\n  fullName: 'Trillion'\n}], ['G', {\n  key: 'G',\n  name: 'giga',\n  value: 10 ** 9,\n  fullName: 'Billion'\n}], ['M', {\n  key: 'M',\n  name: 'mega',\n  value: 10 ** 6,\n  fullName: 'Million'\n}], ['K', {\n  key: 'K',\n  name: 'kilo',\n  value: 10 ** 3,\n  fullName: 'Thousand'\n}],\n// ['H', { key: 'H', name: 'hecto', value: 10 ** 2  , fullName: 'Hundred'       }],\n// ['D', { key: 'D', name: 'deka',  value: 10 ** 1  , fullName: 'Ten'           }],\n// ['d', { key: 'd', name: 'deci',  value: 10 ** -1 , fullName: 'Tenth'         }],\n['', {\n  key: '',\n  name: '',\n  value: 1,\n  fullName: ''\n}], ['c', {\n  key: 'c',\n  name: 'centi',\n  value: 10 ** -2,\n  fullName: 'Hundredth'\n}], ['m', {\n  key: 'm',\n  name: 'milli',\n  value: 10 ** -3,\n  fullName: 'Thousandth'\n}], ['Î¼', {\n  key: 'Î¼',\n  name: 'micro',\n  value: 10 ** -6,\n  fullName: 'Millionth'\n}], ['n', {\n  key: 'n',\n  name: 'nano',\n  value: 10 ** -9,\n  fullName: 'Billionth'\n}], ['p', {\n  key: 'p',\n  name: 'pico',\n  value: 10 ** -12,\n  fullName: 'Trillionth'\n}], ['f', {\n  key: 'f',\n  name: 'femto',\n  value: 10 ** -15,\n  fullName: 'Quadrillionth'\n}], ['a', {\n  key: 'a',\n  name: 'atto',\n  value: 10 ** -18,\n  fullName: 'Quintillionth'\n}], ['z', {\n  key: 'z',\n  name: 'zepto',\n  value: 10 ** -21,\n  fullName: 'Sextillionth'\n}], ['y', {\n  key: 'y',\n  name: 'yocto',\n  value: 10 ** -24,\n  fullName: 'Septillionth'\n}]];\nmodule.exports.metricSIMap = new Map(FormatUtils.metricSI);\n/* eslint-enable comma-spacing */\n\n/**\n * This parses compact numbers, like 100K, 2M, etc.\n * \n * key|name |fullName     |value2  \n * -- |--   |--           |--      \n * Y  |yotta|Septillion   |10^24   \n * Z  |zetta|Sextillion   |10^21   \n * E  |exa  |Quintillion  |10^18   \n * P  |peta |Quadrillion  |10^15   \n * T  |tera |Trillion     |10^12   \n * G  |giga |Billion      |10^9    \n * M  |mega |Million      |10^6    \n * K  |kilo |Thousand     |10^3    \n * m  |milli|Thousandth   |0.001   \n * Î¼  |micro|Millionth    |0.000001\n * n  |nano |Billionth    |10^-9   \n * p  |pico |Trillionth   |10^-12  \n * f  |femto|Quadrillionth|10^-15  \n * a  |atto |Quintillionth|10^-18  \n * z  |zepto|Sextillionth |10^-21  \n * y  |yocto|Septillionth |10^-24\n * \n * @param {String} compactStr - Compact Number String, like 100K, 2M, etc.\n * @returns {Number}\n * @example\n * utils.compactParse('1.2K'); // 1200\n * utils.compactParse('12');   // 12\n * utils.compactParse('299.8M')// 299800000\n */\nmodule.exports.compactParse = function compactParse(compactStr) {\n  const match = (compactStr || '').match(/([\\d.]+)([a-zA-ZÎ¼])?/);\n  if (!match) {\n    throw Error(`Unable to parse short number:${compactStr}`);\n  }\n  const parsedNumber = parseFloat(match[1]);\n  const char = match[2];\n  let value = parsedNumber;\n  if (FormatUtils.metricSIMap.has(char)) {\n    value *= FormatUtils.metricSIMap.get(char).value;\n  }\n  return value;\n};\n\n/**\n * Converts a number to a compact version.\n * \n * key|name |fullName     |value2  \n * -- |--   |--           |--      \n * Y  |yotta|Septillion   |10^24   \n * Z  |zetta|Sextillion   |10^21   \n * E  |exa  |Quintillion  |10^18   \n * P  |peta |Quadrillion  |10^15   \n * T  |tera |Trillion     |10^12   \n * G  |giga |Billion      |10^9    \n * M  |mega |Million      |10^6    \n * K  |kilo |Thousand     |10^3    \n * m  |milli|Thousandth   |0.001   \n * Î¼  |micro|Millionth    |0.000001\n * n  |nano |Billionth    |10^-9   \n * p  |pico |Trillionth   |10^-12  \n * f  |femto|Quadrillionth|10^-15  \n * a  |atto |Quintillionth|10^-18  \n * z  |zepto|Sextillionth |10^-21  \n * y  |yocto|Septillionth |10^-24\n * \n * Note, a standard method Javascript is now available\n * with {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat|Intl.NumberFormat()}\n * \n * This method handles very simple cases, but you can use the `compact` layout\n * for much more control.\n * \n * @param {Number} num - Number to create into a compact number\n * @param {Number} digits - Significant digits\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed|Number.toFixed(num, digits)}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat|Intl.NumberFormat()} - as the compact format does something similar\n * @returns {String}\n * @example \n * utils.format.compactNumber(123.456, 1);   // 123.5\n * utils.format.compactNumber(759878, 0);    // 760K\n * utils.format.compactNumber(0.0000002, 1); // 200n\n * \n * //-- or using Intl.NumberFormat\n * new Intl.NumberFormat('en-GB', {\n *   notation: \"compact\",\n *   compactDisplay: \"short\"\n * }).format(987654321);\n * // â†’ 988M\n */\nmodule.exports.compactNumber = function compactNumber(num, digits = 0) {\n  if (num === 0) {\n    return '0';\n  } else if (Number.isNaN(num) || !num) {\n    return '';\n  }\n  let si = FormatUtils.metricSI.find(siEntry => siEntry[1].value <= num);\n  if (!si) si = FormatUtils.metricSI[FormatUtils.metricSI.length - 1];\n  const siValue = si[1].value;\n  const siKey = si[0];\n  return (num / siValue).toFixed(digits) + siKey;\n};\n\n/**\n * Converts a value to a String, <br />\n * Or returns `otherwise` if any exceptions are found.\n * \n * @param {any} val - value to convert\n * @param {any} otherwise - value to use if any exceptions are caught\n * @returns {String} - `String(val)`\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive|toPrimitive}\n * @returns {String}\n * @example\n * utils.format.safeConvertString(23); // '23'\n * \n * const customObj = {\n *  toString: () => `String Value`\n * };\n * utils.format.safeConvertString(customObj); // 'String Value'\n */\nmodule.exports.safeConvertString = function safeConvertString(val, otherwise = null) {\n  try {\n    return String(val);\n  } catch (err) {\n    return otherwise;\n  }\n};\n\n/**\n * Converts a value to a Floating Number, <br />\n * Or returns `otherwise` if any exceptions are found or value is NaN\n * \n * @param {any} val - value to convert\n * @param {any} otherwise - value to use if any exceptions are caught\n * @returns {Number}\n * @example\n * utils.format.safeConvertFloat('23.1'); // 23.1\n * utils.format.safeConvertFloat('not a number', -1); // -1\n */\nmodule.exports.safeConvertFloat = function safeConvertFloat(val, otherwise = NaN) {\n  if (typeof val === 'string') {\n    //-- replace the variable in memory to minimize garbage collection.\n    // eslint-disable-next-line no-param-reassign\n    val = val.replace(/[^0-9.]/g, '');\n  }\n  try {\n    const result = Number.parseFloat(val);\n    if (Number.isNaN(result)) {\n      return otherwise;\n    }\n    return result;\n  } catch (err) {\n    //-- cannot reliably get the exception to be thrown so cannot test this line\n    /* istanbul ignore next */\n    return otherwise;\n  }\n};\n\n/**\n * Converts a value to a Floating Number, <br />\n * Or returns `otherwise` if any exceptions are found or value is Not a Number.\n * \n * @param {any} val - value to convert\n * @param {any} otherwise - value to use if any exceptions are caught\n * @param {Number} [radix = 10] - radix to use in converting the string\n * @returns {Number}\n * @example\n * utils.format.safeConvertFloat('23'); // 23\n * utils.format.safeConvertFloat('not a number', -1); // -1\n */\nmodule.exports.safeConvertInteger = function safeConvertInteger(val, otherwise = NaN, radix = 10) {\n  if (typeof val === 'string') {\n    //-- replace the variable in memory to minimize garbage collection.\n    // eslint-disable-next-line no-param-reassign\n    val = val.replace(/[^0-9.]/g, '');\n  }\n  try {\n    const result = Number.parseInt(val, radix);\n    if (Number.isNaN(result)) {\n      return otherwise;\n    }\n    return result;\n  } catch (err) {\n    //-- cannot reliably get the exception to be thrown so cannot test this line\n    /* istanbul ignore next */\n    return otherwise;\n  }\n};\n\n/**\n * Converts a value to boolean.\n * \n * Note this uses the standard JavaScript `truthy` conversion,\n * but with special exceptions for strings: only 'true', 'yes', '1' are considered true.\n * \n * @param {any} val - value to be converted\n * @returns {Boolean}\n * @example\n * utils.format.safeConvertBoolean(1); // true\n * utils.format.safeConvertBoolean({ pojo: true }); // true\n * utils.format.safeConvertBoolean('TruE'); // true - case insensitive\n * utils.format.safeConvertBoolean('YeS'); // true - case insensitive\n * utils.format.safeConvertBoolean('1'); // true\n * \n * utils.format.safeConvertBoolean(0); // false\n * utils.format.safeConvertBoolean(null); // false\n * utils.format.safeConvertBoolean('false'); // false\n * utils.format.safeConvertBoolean('No'); // false\n * utils.format.safeConvertBoolean('0'); // false\n */\nmodule.exports.safeConvertBoolean = function safeConvertBoolean(val) {\n  if (typeof val === 'string') {\n    const valUpper = val.toUpperCase();\n    return valUpper === 'TRUE' || valUpper === 'YES' || valUpper === '1';\n  }\n  return val ? true : false;\n};\nmodule.exports.parseCommand = function parseCommand(commandStr) {\n  if (!commandStr || commandStr.indexOf('(') < 0) {\n    return [commandStr];\n  }\n  const match = commandStr.match(/^([a-zA-Z].+)[(](.*)[)]$/i);\n  let result = [];\n  if (match) {\n    const commandArgs = (match[2] || '').split(',').map(s => s.trim()).filter(v => v !== '');\n    result = [match[1].trim(), commandArgs];\n  } else {\n    result = [commandStr];\n  }\n  return result;\n};\nmodule.exports.prepareFormatterObject = function prepareFormatterObject(formatterObject) {\n  //-- @TODO: find way to reliably say that the propertyTranslation is an object\n  // propertyTranslations.constructor.name !== 'Object'\n  if (!formatterObject) {\n    throw Error(['ObjectUtils.formatProperties(collection, propertyTranslations): propertyTranslations must be an object, ', 'with the properties matching those to be formatted, and values as functions returning the new value'].join(''));\n  }\n  const translationKeys = Array.from(Object.keys(formatterObject));\n  const result = {\n    ...formatterObject\n  };\n  translationKeys.forEach(key => {\n    const translationVal = formatterObject[key];\n    const translationValType = typeof translationVal;\n    if (translationValType === 'function') {\n      //-- do nothing\n    } else if (translationValType === 'string') {\n      const [command, args = []] = FormatUtils.parseCommand(translationVal);\n      if (command === 'string') {\n        result[key] = FormatUtils.safeConvertString;\n      } else if (command === 'ellipsify' || command === 'elipsify' || command === 'ellipsis' || command === 'elipsis') {\n        result[key] = str => FormatUtils.ellipsify(str, args[0]);\n      } else if (command === 'number' || command === 'float') {\n        result[key] = FormatUtils.safeConvertFloat;\n      } else if (command === 'int' || command === 'integer') {\n        result[key] = FormatUtils.safeConvertInteger;\n      } else if (command === 'bool' || command === 'boolean') {\n        result[key] = FormatUtils.safeConvertBoolean;\n      } else {\n        result[key] = () => translationVal;\n      }\n    } else {\n      result[key] = () => translationVal;\n    }\n  });\n  return result;\n};\n\n/**\n * Tests for empty values:\n * \n * * (zeros are allowed)\n * * not null\n * * not undefined\n * * not an empty string\n * * not an empty array `[]`\n * \n * @param {any} val - a value to be tested \n * @returns {Boolean} - TRUE if the value is not 'empty'\n */\nmodule.exports.isEmptyValue = val =>\n//-- allow for 0s\nval === null || val === undefined || val === '' || Array.isArray(val) && val.length === 0;\n\n/**\n * Determines if a value is a boolean true value.\n * \n * Matches for:\n * \n * * boolean TRUE\n * * number 1\n * * string 'TRUE'\n * * string 'True'\n * * string 'true'\n * \n * @param {any} val - the value to be tested\n * @returns {Boolean} - TRUE if the value matches\n */\nmodule.exports.parseBoolean = function parseBoolean(val) {\n  return val === true || val === 1 || val === 'TRUE' || val === 'True' || val === 'true';\n};\nmodule.exports.isBoolean = function isBoolean(val) {\n  return val === true || val === false || val === 1 || val === 0 || val === 'TRUE' || val === 'FALSE' || val === 'True' || val === 'False' || val === 'true' || val === 'false';\n};\nFormatUtils.parseLocaleCache = new Map();\n\n/**\n * Parses a given number, based on a {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat|Intl.NumberFormat}\n * \n * If the locale is not passed (ex: 'fr-FR'), then 'en-US' is assumed\n * \n * @param {any} val - value to parse\n * @returns {Number} - parsed number\n * @example\n * \n * utils.format.parseNumber(10); // 10\n * utils.format.parseNumber('10'); // 10\n * utils.format.parseNumber('1,000'); // 1000\n * utils.format.parseNumber('1,000.5'); // 1000.5\n * utils.format.parseNumber('1,000', 'en-US'); // 1000\n * utils.format.parseNumber('1,000.5', 'en-US'); // 1000.5\n * utils.format.parseNumber('1 000', 'fr-FR'); // 1000\n * utils.format.parseNumber('1 000,5', 'fr-FR'); // 1000.5\n */\nmodule.exports.parseNumber = function parseNumber(val, locale = 'en-US') {\n  const valType = typeof val;\n  if (valType === 'number') {\n    return val;\n  } else if (valType === 'string') {\n    let separator;\n    if (FormatUtils.parseLocaleCache.has(locale)) {\n      separator = FormatUtils.parseLocaleCache.get(locale);\n    } else {\n      const example = Intl.NumberFormat(locale).format('1.1');\n      separator = example.charAt(1);\n      FormatUtils.parseLocaleCache.set(locale, separator);\n    }\n    const cleanPattern = new RegExp(`[^-+0-9${separator}]`, 'g');\n    const cleaned = val.replace(cleanPattern, '');\n    const normalized = cleaned.replace(separator, '.');\n    return parseFloat(normalized);\n  } else if (!val) {\n    return val;\n  }\n  return parseFloat(val);\n};\n\n/**\n * Narrows to only fromLine - toLine (inclusive) within a string.\n * \n * @see {@link module:format.consoleLines|format.consoleLines()} - to console the values out\n * @param {String|Object} str - string to be limited, or object to be json.stringify-ied\n * @param {Number} toLine \n * @param {Number} [fromLine=0] - starting line number (starts at 0)\n * @param {String} [lineSeparator='\\n'] - separator for lines\n * @returns {String}\n * @example\n * str = '1\\n2\\n\\3';\n * utils.format.limitLines(str, 2); // '1\\n2'\n * \n * str = '1\\n2\\n3';\n * utils.format.limitLines(str, 3, 2); // '2\\n3'\n * \n * str = '1\\n2\\n3';\n * utils.format.limitLines(str, undefined, 2); // '2\\n3'\n */\nmodule.exports.limitLines = function limitLines(str, toLine, fromLine, lineSeparator) {\n  const cleanStr = typeof str === 'string' ? str : JSON.stringify(str || '', FormatUtils.mapReplacer, 2);\n  const cleanLine = lineSeparator || '\\n';\n  return cleanStr.split(cleanLine).slice(fromLine || 0, toLine).join(cleanLine);\n};\n\n/**\n * Same as {@link module:format.limitLines|limitLines()} - only prints to the console.\n * \n * @see {@link module:format.limitLines|format.limitLines}\n * @param {String|Object} str - string to be limited, or object to be json.stringify-ied\n * @param {Number} toLine \n * @param {Number} [fromLine=0] - starting line number (starts at 0)\n * @param {String} [lineSeparator='\\n'] - separator for lines\n * @returns {String}\n * @example\n * str = '1\\n2\\n\\3';\n * utils.format.limitLines(str, 2); // '1\\n2'\n * \n * str = '1\\n2\\n3';\n * utils.format.limitLines(str, 3, 2); // '2\\n3'\n * \n * str = '1\\n2\\n3';\n * utils.format.limitLines(str, undefined, 2); // '2\\n3'\n */\nmodule.exports.consoleLines = function consoleLines(str, toLine, fromLine, lineSeparator) {\n  console.log(FormatUtils.limitLines(str, toLine, fromLine, lineSeparator));\n};\n\n/**\n * Strips any html or xml tags from a string.\n * \n * Note, if you want to remove html entities (ex: `&nbsp;` or `&#8209;`), please consider [other libraries](https://www.npmjs.com/search?q=html%20entities)\n * \n * @param {String} str - string to strip html / xml entities from\n * @returns {String}\n * @example \n * \n * utils.format.stripHtmlTags('Hello <br />Nice to see <b>you</b>'); // 'Hello Nice to see you'\n * utils.format.stripHtmlTags('example string'); // 'example string' -- untouched\n */\nmodule.exports.stripHtmlTags = function stripHtmlTags(str) {\n  if (!str) return str;\n  return str.replace(/<[^>]+>/g, '');\n};\n\n/**\n * Breaks apart a string into an array of strings by a new line character.\n * \n * @param {String} str - string to be broken apart into lines\n * @param {Object} options - options to apply\n * @param {Number} [options.width=50] - width of lines to cut\n * @param {boolean} [options.cut=false] - whether to cut words in the middle\n * @param {boolean} [options.trim=true] - whether to trim the whitespace at ends of lines - after splitting.\n * @returns {String[]} - array of strings\n * @example\n * \n * const str = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor '\n * + 'incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation';\n * \n * //-- does not cut the line by default, and width of 50\n * utils.format.wordWrap(str);\n * // [\n * //   'Lorem ipsum dolor sit amet, consectetur adipiscing',\n * //   'elit, sed do eiusmod tempor incididunt ut labore',\n * //   'et dolore magna aliqua. Ut enim ad minim veniam,',\n * //   'quis nostrud exercitation'\n * // ];\n * \n * //-- you can also set the width, and whether to cut in the middle of the line\n * utils.format.wordWrap(str, { cut: true, width: 70 });\n * const expected = [\n *   'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmo',\n *   'd tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim',\n *   'veniam, quis nostrud exercitation'\n * ];\n */\nmodule.exports.wordWrap = function wordWrap(str, options) {\n  const cleanOptions = options || {};\n  const {\n    width = 50,\n    cut = false,\n    trim = true\n  } = cleanOptions;\n  if (!str || !(typeof str === 'string')) return str;\n  let rexStr = `.{1,${width}}`;\n  if (cut !== true) {\n    rexStr += '([\\\\s\\u200B]+|$)|[^\\\\s\\u200B]+?([\\\\s\\u200B]+|$)';\n  }\n  const rex = new RegExp(rexStr, 'g');\n\n  /* istanbul ignore next */\n  let lines = str.match(rex) || [];\n  if (trim) {\n    lines = lines.map(line => line.trim());\n  }\n  return lines;\n};\n\n/**\n * Determines the number of lines in a string\n * \n * @param {String} str - String to be checked for number of lines\n * @param {String} [newlineCharacter='\\n'] - the newline character to use\n * @returns {Number} - Number of lines found\n * @see {@link module:format.wordWrap|wordWap(str, options})} for other options.\n * @example\n * \n * utils.format.lineCount('single line'); // 1\n * utils.format.lineCount(`line 1\n *   line 2\n *   line 3`); // 3\n * utils.format.lineCount('line 1\\rLine2\\rLine3', '\\r'); // 3\n */\nmodule.exports.lineCount = function lineCount(str, newlineCharacter = '\\n') {\n  const cleanNewLine = newlineCharacter || '\\n';\n  if (!str || !(typeof str === 'string')) return 0;\n  const rex = new RegExp(`${cleanNewLine}`, 'g');\n  const match = str.match(rex);\n  return match ? match.length + 1 : 1;\n};\n\n/**\n * Performs a set of replacement against a string or list of strings.\n * \n * The string replacements can either be [[search,replace],[search,replace]]\n * or a map of Map([[search, replace], [search, replace]])\n * \n * This is meant to provide a way to apply consistent string cleanups across projects.\n * \n * example:\n * \n * ```\n * targetStrings = [\n *   'jack and jill went up the hill',\n *   'to fetch the pail of water',\n *   'jack fell down and broke his crown',\n *   'and jill came tumbling after'\n * ];\n * \n * //-- include an array of strings to all remove out\n * utils.format.replaceStrings(targetStrings, ['down ', ' of water']);\n * // [ 'jack and jill went up the hill',\n * //   'to fetch the pail',\n * //   'jack fell and broke his crown',\n * //   'and jill came tumbling after' ]\n *\n * //-- or use tuplets of [find, replace] with regular expressions\n * //-- and strings not in tuplets are simply removed.\n * replaceValues = [['jack', 'john'], [/\\s+jill/i, ' ringo'], ' down'];\n * utils.format.replaceStrings(targetStrings, replaceValues);\n * expected = [\n *   'john and ringo went up the hill',\n *   'to fetch the pail of water',\n *   'john fell and broke his crown',\n *   'and ringo came tumbling after'\n * ];\n * \n * //-- a map will do the same, but will not support regular expressions for keys\n * replaceValues = new Map();\n * replaceValues.set('jack', 'john');\n * replaceValues.set('jill', 'ringo');\n * utils.format.replaceStrings(targetStrings, replaceValues);\n * expected = [\n *   'john and ringo went up the hill',\n *   'to fetch the pail of water',\n *   'john fell down and broke his crown',\n *   'and ringo came tumbling after'\n * ];\n * ```\n * \n * @param {string|string[]} targetStr - the string to search for with the tuplets\n * @param {Array|Map<string|RegExp,string>} stringTupletsOrMap - [[search, replace]] or Map<String|RegExp,String>\n * @returns {string[]} - the resulting list of strings\n */\nmodule.exports.replaceStrings = function replaceStrings(targetStr, stringTupletsOrMap) {\n  const cleanStrings = !targetStr ? [] : Array.isArray(targetStr) ? targetStr : [targetStr];\n  // const signature = 'replaceStrings(targetStrings, stringTupletsOrMap)';\n  const replacementEntries = [];\n  if (Array.isArray(stringTupletsOrMap)) {\n    stringTupletsOrMap.forEach(possibleReplacement => {\n      if (typeof possibleReplacement === 'string') {\n        replacementEntries.push([possibleReplacement, '']);\n      } else if (Array.isArray(possibleReplacement)) {\n        const [replaceSearch, replaceWith] = possibleReplacement;\n        replacementEntries.push([replaceSearch, replaceWith || '']);\n      }\n    });\n  } else if (stringTupletsOrMap instanceof Map) {\n    [...stringTupletsOrMap.entries()].forEach(([replaceSearch, replaceWith]) => {\n      replacementEntries.push([replaceSearch, replaceWith || '']);\n    });\n  }\n  return cleanStrings.map(stringToClean => !stringToClean ? stringToClean : replacementEntries.reduce((result, [replaceSearch, replaceWith]) => !result ? result : result.replace(replaceSearch, replaceWith), stringToClean));\n};\n\n/**\n * Conveience function for calling {@link module:format.replaceStrings|format.replaceStrings} -\n * giving and receiving a single value (instead of an array of values).\n * @param {String} targetStr - A Single string to replace values on.\n * @param {Array|Map<string|RegExp,string>} stringTupletsOrMap - [[search, replace]] or Map<String|RegExp,String>\n * @returns {string} - the targetStr with the values replaced\n * @see {@link module:format.replaceStrings}\n */\nmodule.exports.replaceString = function replaceString(targetStr, stringTupletsOrMap) {\n  if (Array.isArray(targetStr)) {\n    throw Error('replaceString(targetStr, stringTupletsOrMap): targetStr was sent an array - please use replaceStrings instead');\n  }\n  return FormatUtils.replaceStrings([targetStr], stringTupletsOrMap)[0];\n};\n\n/**\n * Identify an array of words each from a string.\n * \n * Note that this uses the new [Unicode Properties](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Unicode_character_class_escape)\n * using `\\p{L}` to identify characters based on unicode properties.\n * \n * For example:\n * \n * ```\n * strs = 'I am Modern \"major-general\".';\n * FormatUtils.extractWords(strs);\n * // ['I', 'am', 'Modern', 'major', 'general'];\n * ```\n * \n * you can also include additional characters that will no longer be considered word boundaries.\n * \n * ```\n * strs = 'I am Modern \"major-general\".';\n * FormatUtils.extractWords(strs);\n * // ['I', 'am', 'Modern', 'major-general'];\n * ```\n * \n * arrays of strings are also supported\n * \n * ```\n * strs = ['letras mayÃºsculas de tamaÃ±o igual a las minÃºsculas',\n *  'Ø§Ù„Ø§Ø®ØªØ±Ø§Ø¹ØŒ ÙˆÙ…Ø§ÙŠÙƒÙ„ Ù‡Ø§Ø±Øª'];\n * FormatUtils.extractWords(strs);\n * // [ 'letras', 'mayÃºsculas', 'de', 'tamaÃ±o', 'igual', 'a', 'las', 'minÃºsculas', 'Ø§Ù„Ø§Ø®ØªØ±Ø§Ø¹', 'ÙˆÙ…Ø§ÙŠÙƒÙ„', 'Ù‡Ø§Ø±Øª'];\n * ```\n * \n * @param {String|String[]} strToExtractFrom - collection of strings to extract words from\n * @param {String} additionalNonBreakingCharacters - each char in this string will not be treated as a word boundry\n * @returns {string[]} - collection of words\n */\nmodule.exports.extractWords = function extractWords(strToExtractFrom, additionalNonBreakingCharacters) {\n  if (!strToExtractFrom) return strToExtractFrom;\n  const cleanNonBreaking = additionalNonBreakingCharacters ? additionalNonBreakingCharacters : '';\n  const regex = cleanNonBreaking ? new RegExp(`[${additionalNonBreakingCharacters}\\\\p{L}]+`, 'gu') : /\\p{L}+/ug; // -- old attempt/[A-Za-zÃ€-Ã–Ã˜-Ã¶Ã¸-Ã¿]+/g;\n\n  const cleanStrings = Array.isArray(strToExtractFrom) ? strToExtractFrom : [strToExtractFrom];\n  return cleanStrings.reduce((result, str) => [...result, ...((str || '').match(regex) || [])], []);\n};\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./src/format.js?");

/***/ }),

/***/ "./src/group.js":
/*!**********************!*\
  !*** ./src/group.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SourceMap = __webpack_require__(/*! ./SourceMap */ \"./src/SourceMap.js\");\nconst ObjectUtils = __webpack_require__(/*! ./object */ \"./src/object.js\");\n\n/**\n * Utilities for collating and grouping records\n * \n * * Creating Groups of records\n *   * {@link module:group.by|group.by(collection, field, field, ...)} - group arrays by common values - for further reduction, etc.\n *   * {@link module:group.separateByFields|group.separateByFields(collection, field, field)} - duplicate collections by fields (useful for charting)\n * * Indexing records by a unique key\n *   * {@link module:group.index|group.index(collection, field)} - create a map of records by a unique field (helpful for joining records)\n * * Reducing Collections of records\n *   * {@link module:group.rollup|group.rollup(collection, field)} - group and \"reduce\" to aggregate a collection of records\n * \n * Please also see:\n * \n * * {@link SourceMap} - as it is the result from {@link module:group.by|group.by()}\n * * {@link module:aggregate|aggregate} - a collection of utilities to aggregate / reduce records.\n * \n * See {@link https://stackoverflow.com/questions/31412537/numpy-like-package-for-node|this stackoverflow}\n * for someone asking why couldn't {@link https://numpy.org/doc/stable/user/quickstart.html|Numpy} be written in JavaScript;\n * \n * * D3, specifically: [group / rollup / index](https://observablehq.com/@d3/d3-group)\n * and [flatGroup / flatRollup](https://observablehq.com/@d3/d3-flatgroup)\n * \n * * {@link https://danfo.jsdata.org/|DanfoJS} - a js library heavily inspired by\n * {@link https://pandas.pydata.org/pandas-docs/stable/index.html|Pandas}\n * so someone familiar with Pandas can get up to speed very quickly\n * \n * * {@link https://gmousse.gitbooks.io/dataframe-js/|dataframe-js} -\n * provides an immutable data structure for DataFrames\n * which allows to work on rows and columns with a sql\n * and functional programming inspired api.\n * \n * * {@link https://github.com/stdlib-js/stdlib|StdLib} - \n * is a great library that compiles down to C/C++ level to provide speeds comparable to Numpy.\n * \n * * {@link https://www.npmjs.com/package/numjs | NumJS}\n * is also a great number processing library.\n * It may not be as fast as StdLib, but it can sometimes be easier to use.\n * \n * @module group\n * @exports group\n */\nmodule.exports = {};\nconst GroupUtils = module.exports;\n\n/**\n * Group a collection into multiple levels of maps.\n * \n * @param {Array} collection - Array of objects or two dimensional array\n * @param {String|Number} key - the key to group the collection by\n * @param {...String} key - the additional keys to group the collection by\n * @returns {SourceMap} - collection of results with the source as the key used for that level\n * \n * For example:\n * \n * ```\n * initializeWeather = () => [\n *   { id: 1, city: 'Seattle',  month: 'Aug', precip: 0.87 },\n *   { id: 0, city: 'Seattle',  month: 'Apr', precip: 2.68 },\n *   { id: 2, city: 'Seattle',  month: 'Dec', precip: 5.31 },\n *   { id: 3, city: 'New York', month: 'Apr', precip: 3.94 },\n *   { id: 4, city: 'New York', month: 'Aug', precip: 4.13 },\n *   { id: 5, city: 'New York', month: 'Dec', precip: 3.58 },\n *   { id: 6, city: 'Chicago',  month: 'Apr', precip: 3.62 },\n *   { id: 8, city: 'Chicago',  month: 'Dec', precip: 2.56 },\n *   { id: 7, city: 'Chicago',  month: 'Aug', precip: 3.98 }\n * ];\n * weather = initializeWeather();\n * \n * utils.group.by(weather, 'city')\n * ```\n * \n * // provides\n * \n * ```\n * SourceMap(3) [Map] {\n *   'Seattle' => [\n *     { id: 1, city: 'Seattle', month: 'Aug', precip: 0.87 },\n *     { id: 0, city: 'Seattle', month: 'Apr', precip: 2.68 },\n *     { id: 2, city: 'Seattle', month: 'Dec', precip: 5.31 }\n *   ],\n *   'New York' => [\n *     { id: 3, city: 'New York', month: 'Apr', precip: 3.94 },\n *     { id: 4, city: 'New York', month: 'Aug', precip: 4.13 },\n *     { id: 5, city: 'New York', month: 'Dec', precip: 3.58 }\n *   ],\n *   'Chicago' => [\n *     { id: 6, city: 'Chicago', month: 'Apr', precip: 3.62 },\n *     { id: 8, city: 'Chicago', month: 'Dec', precip: 2.56 },\n *     { id: 7, city: 'Chicago', month: 'Aug', precip: 3.98 }\n *   ],\n *   source: 'city'\n * }\n * ```\n * \n * or using multiple groups:\n * `utils.group.by(weather, 'month', 'city')`\n * \n * provides:\n * \n * ```\n * SourceMap(3) [Map] {\n *   'Aug' => SourceMap(3) [Map] {\n *     'Seattle' => [ [Object] ],\n *     'New York' => [ [Object] ],\n *     'Chicago' => [ [Object] ],\n *     source: 'city'\n *   },\n *   'Apr' => SourceMap(3) [Map] {\n *     'Seattle' => [ [Object] ],\n *     'New York' => [ [Object] ],\n *     'Chicago' => [ [Object] ],\n *     source: 'city'\n *   },\n *   'Dec' => SourceMap(3) [Map] {\n *     'Seattle' => [ [Object] ],\n *     'New York' => [ [Object] ],\n *     'Chicago' => [ [Object] ],\n *     source: 'city'\n *   },\n *   source: 'month'\n * }\n```\n */\nmodule.exports.by = function by(collection, prop, ...rest) {\n  const resultMap = new SourceMap();\n  if (!collection || !Array.isArray(collection) || collection.length < 1) {\n    throw Error('Group.By:Collection is not an array');\n  }\n  resultMap.source = prop;\n  collection.forEach((item, index) => {\n    let val = item[prop];\n    if (val instanceof Date) {\n      val = val.toISOString();\n    }\n    if (!resultMap.has(val)) {\n      resultMap.set(val, [item]);\n    } else {\n      resultMap.get(val).push(item);\n    }\n  });\n  if (rest.length > 0) {\n    //-- do the next level\n    [...resultMap.keys()].forEach(key => {\n      const newCollection = resultMap.get(key);\n      resultMap.set(key, GroupUtils.by.apply(this, [newCollection, ...rest]));\n    });\n  }\n  return resultMap;\n};\n\n/**\n * Group and \"Reduce\" a collection of records.\n * \n * (Similar to {@link https://observablehq.com/@d3/d3-group|d3 - rollup})\n * \n * @param {Array} collection - Collection to be rolled up\n * @param {Function} reducer - {(Array) => any} Function to reduce the group of records down\n * @param {String} prop - The property on the objects to group by\n * @param  {...any} fields - Additional fields to group by\n * @returns {SourceMap} - a reduced sourceMap, where only the leaves of the groups are reduced\n * @see {@link SourceMap#map} - Used to reduce or filter records\n * @see {@link module:group.by|group.by(collection, fields, ...)} - to group records\n * \n * @example\n * const data = [\n * weather = [\n *   { id: 1, city: 'Seattle',  month: 'Aug', precip: 0.87, dateTime: new Date(2020, 7, 1)  , year: 2020},\n *   { id: 2, city: 'Seattle',  month: 'Dec', precip: 5.31, dateTime: new Date(2020, 11, 1) , year: 2020},\n *   { id: 0, city: 'Seattle',  month: 'Apr', precip: 2.68, dateTime: new Date(2021, 3, 1)  , year: 2021},\n *   { id: 4, city: 'New York', month: 'Aug', precip: 4.13, dateTime: new Date(2020, 7, 1)  , year: 2020},\n *   { id: 5, city: 'New York', month: 'Dec', precip: 3.58, dateTime: new Date(2020, 11, 1) , year: 2020},\n *   { id: 3, city: 'New York', month: 'Apr', precip: 3.94, dateTime: new Date(2021, 3, 1)  , year: 2021},\n *   { id: 7, city: 'Chicago',  month: 'Aug', precip: 3.98, dateTime: new Date(2020, 7, 1)  , year: 2020},\n *   { id: 8, city: 'Chicago',  month: 'Dec', precip: 2.56, dateTime: new Date(2020, 11, 1) , year: 2020},\n *   { id: 6, city: 'Chicago',  month: 'Apr', precip: 3.62, dateTime: new Date(2021, 3, 1)  , year: 2021}\n * ];\n * \n * utils.group.rollup(weather, (collection) => collection.length, 'city')\n * \n * // SourceMap(3) [Map] {\n * //   'Seattle' => 3,\n * //   'New York' => 3,\n * //   'Chicago' => 3,\n * //   source: 'city'\n * // }\n * \n * utils.group.rollup(weather, r => r.length, 'city', 'year')\n * \n * //  SourceMap(3) [Map] {\n * //   'Seattle' => SourceMap(2) [Map] { 2020 => 2, 2021 => 1, source: 'year' },\n * //   'New York' => SourceMap(2) [Map] { 2021 => 1, 2020 => 2, source: 'year' },\n * //   'Chicago' => SourceMap(2) [Map] { 2021 => 1, 2020 => 2, source: 'year' },\n * //   source: 'city'\n * // }\n */\nmodule.exports.rollup = function rollup(collection, reducer, prop, ...fields) {\n  return GroupUtils.by.apply(this, [collection, prop, ...fields]).map(reducer);\n};\n\n/**\n * Vega needs the series on separate objects.\n * \n * Each object then made per group leaf collection, preserving the groups used to make it.\n * \n * The object generated by the function is then merged.\n * \n * See [vega-lite fold transform](https://vega.github.io/vega-lite/docs/fold.html)\n * \n * @example\n * aggregateWeather = utils.group.by(weather, 'city')\n *   .reduce((group) => ({\n *     min: utils.agg.min(group, 'precip'),\n *     max: utils.agg.max(group, 'precip'),\n *     avg: utils.agg.avgMean(group, 'precip')\n *   }));\n * \n * //-- gives\n * \n * [\n *   { city: 'Seattle', min: 0.87, max: 5.31, avg: 2.953 },\n *   { city: 'New York', min: 3.58, max: 4.13, avg: 3.883 },\n *   { city: 'Chicago', min: 2.56, max: 3.98, avg: 3.387 }\n * ]\n * \n * separateByFields(aggregateWeather, 'min', 'max', 'avg')\n * \n * //-- gives\n * [\n *   { city: 'Seattle', min: 0.87, max: 5.31, avg: 2.953,  key: 'min', value: 0.87 },\n *   { city: 'New York', min: 3.58, max: 4.13, avg: 3.883, key: 'min', value: 3.58 },\n *   { city: 'Chicago', min: 2.56, max: 3.98, avg: 3.387,  key: 'min', value: 2.56 },\n *   { city: 'Seattle', min: 0.87, max: 5.31, avg: 2.953,  key: 'max', value: 5.31 },\n *   { city: 'New York', min: 3.58, max: 4.13, avg: 3.883, key: 'max', value: 4.13 },\n *   { city: 'Chicago', min: 2.56, max: 3.98, avg: 3.387,  key: 'max', value: 3.98},\n *   ...\n * ]\n * \n * @TODO - Vega needs series on separate records\n * @param {Array} collection - array of objects\n * @param  {...any} fields - string field name to separate by\n * @returns {Array}\n */\nmodule.exports.separateByFields = function separateByFields(collection, ...fields) {\n  if (!collection || !Array.isArray(collection)) {\n    throw Error('SeparateByFields: collection should be an array');\n  }\n  if (!fields || !Array.isArray(fields) || fields.length < 1) {\n    throw Error('separateByFields: fields are expected');\n  }\n  return fields.flatMap(field => collection.map(obj => ({\n    ...obj,\n    key: field,\n    value: obj[field]\n  })));\n};\n\n/**\n * Index a collection of records to a map based on a specific value.\n * \n * Unlike group.by, only one indexing function is accepted.\n * \n * This is very helpful for joining records of two separate groups.\n * \n * @param {Array} collection - Collection of objects to index by a specific field or value\n * @param {Function | String} indexFn - the propert name or function evaluating to a value for the index\n * @returns {Map}\n * \n * @example\n * athletes = [\n *   {name: \"Neymar\", sport: \"Soccer\", nation: \"Brazil\", earnings: 90},\n *   {name: \"LeBron James\", sport: \"Basketball\", nation: \"United States\",  earnings: 85.5},\n *   {name: \"Roger Federer\", sport: \"Tennis\", nation: \"Switzerland\", earnings: 77.2},\n * ];\n * \n * facts = [\n *   {about: \"Neymar\", fact: \"Neymar is Neymar da Silva Santos JÃºnior\"},\n *   {about: \"Roger Federer\", fact: \"Federer has won 20 Grand Slam men's singles titles\"},\n *   {about: \"Megan Rapinoe\", fact: \"Rapinoe was named The Best FIFA Women's Player in 2019\"}\n * ];\n * \n * athletesByName = utils.group.index(athletes, 'name');\n * facts.map(({about: name, ...rest}) => ({...rest, name, ...athletesByName.get(name)}))\n * \n * // [\n * //   {\n * //     fact: 'Neymar is Neymar da Silva Santos JÃºnior',\n * //     name: 'Neymar', sport: 'Soccer', nation: 'Brazil', earnings: 90\n * //   },\n * //   {\n * //     fact: \"Federer has won 20 Grand Slam men's singles titles\",\n * //     name: 'Roger Federer', sport: 'Tennis', nation: 'Switzerland', earnings: 77.2\n * //   },\n * //   //-- not found\n * //   {\n * //     fact: \"Rapinoe was named The Best FIFA Women's Player in 2019\",\n * //     name: 'Megan Rapinoe'\n * //   }\n * // ]\n */\nmodule.exports.index = function index(collection, indexFn) {\n  const resultMap = new Map();\n  if (!collection || !Array.isArray(collection) || collection.length < 1) {\n    throw Error('group.index: Collection is not an array');\n  }\n  const cleanedIndexFn = ObjectUtils.evaluateFunctionOrProperty(indexFn);\n  collection.forEach((item, offset) => {\n    let val = cleanedIndexFn(item, offset);\n    if (val instanceof Date) {\n      val = val.toISOString();\n    }\n    if (resultMap.has(val)) {\n      throw Error(`group.index: found duplicate item with index:${val} \\n ${JSON.stringify(resultMap.get(val))}`);\n    }\n    resultMap.set(val, item);\n  });\n  return resultMap;\n};\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./src/group.js?");

/***/ }),

/***/ "./src/hashMap.js":
/*!************************!*\
  !*** ./src/hashMap.js ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const FormatUtils = __webpack_require__(/*! ./format */ \"./src/format.js\");\n\n/**\n * Library for working with JavaScript hashmaps.\n * \n * * Modifying\n *   * {@link module:hashMap.add|hashMap.add(map, key, value):Map} - Add a value to a map and return the Map\n *   * {@link module:hashMap.union|hashMap.union(targetMap, additionalMap, canOverwrite)} - merges two maps and ignores or overwrites with conflicts\n * * Cloning\n *   * {@link module:hashMap.clone|hashMap.clone(map):Map} - Clones a given Map\n * * Conversion\n *   * {@link module:hashMap.stringify|hashMap.stringify(map, indent)} - converts a Map to a string representation\n *   * {@link module:hashMap.toObject|hashMap.toObject(map)} - converts a hashMap to an Object\n *   * {@link module:hashMap.fromObject|hashMap.fromObject(object)} - converts an object's properties to hashMap keys\n * \n * Note: JavaScript Maps can sometimes be faster than using Objects,\n * and sometimes slower.\n * \n * (Current understanding is that Maps do better with more updates made)\n * \n * There are many searches such as `javascript map vs object performance`\n * with many interesting links to come across.\n * \n * @module hashMap\n * @exports hashMap\n */\nmodule.exports = {};\nconst HashMapUtil = module.exports;\n\n/**\n * Set a Map in a functional manner (adding a value and returning the map)\n * @param {Map} map - the map to be updated\n * @param {any} key -\n * @param {any} value -\n * @returns {Map} - the updated map value\n * @example\n * const objectToMap = { key1: 1, key2: 2, key3: 3 };\n * const keys = [...Object.keys(objectToMap)];\n * // ['key1', 'key2', 'key3'];\n * \n * const result = keys.reduce(\n *  (result, key) => utils.hashMap.add(result, key, objectToMap[key]),\n *  new Map()\n * );\n * // Map([[ 'key1',1 ], ['key2', 2], ['key3', 3]]);\n */\nmodule.exports.add = function add(map, key, value) {\n  map.set(key, value);\n  return map;\n};\n\n/**\n * Clones a Map\n * @param {Map} target - Map to clone\n * @returns {Map} - clone of the target map\n * @example\n * const sourceMap = new Map();\n * sourceMap.set('first', 1);\n * const mapClone = utils.hashMap.clone(sourceMap);\n * mapClone.has('first'); // true\n */\nmodule.exports.clone = function clone(target) {\n  if (!(target instanceof Map)) {\n    throw Error('hashMap.clone(targetMap): targetMap must be a Map');\n  }\n  return new Map(target.entries());\n};\n\n/**\n * Creates a new map that includes all entries of targetMap, and all entries of additionalMap.\n * \n * If allowOverwrite is true, then values found in additionalMap will take priority in case of conflicts.\n * \n * ```\n * const targetMap = new Map([['first', 'John'], ['amount': 100]]);\n * const additionalMap = new Map([['last': 'Doe'], ['amount': 200]]);\n * \n * utils.hashMap.union(targetMap, additionalMap, true);\n * // Map([['first', 'John'], ['last', 'Doe'], ['amount', 200]]);\n * ```\n * \n * If allowOverwrite is false, then values found in targetMap will take priority in case of conflicts.\n * \n * ```\n * const targetMap = new Map([['first', 'John'], ['amount': 100]]);\n * const additionalMap = new Map([['last': 'Doe'], ['amount': 200]]);\n * \n * utils.hashMap.union(targetMap, additionalMap);\n * utils.hashMap.union(targetMap, additionalMap, false);\n * // Map([['first', 'John'], ['last', 'Doe'], ['amount', 100]]);\n * ```\n * \n * @param {Map} targetMap \n * @param {Map} additionalMap - \n * @param {Boolean} [allowOverwrite=false] - whether targetMap is prioritized (false) or additional prioritized (true)\n * @returns {Map}\n */\nmodule.exports.union = function union(targetMap, additionalMap, allowOverwrite) {\n  if (!(targetMap instanceof Map)) {\n    return HashMapUtil.clone(additionalMap);\n  }\n  const result = new Map(targetMap.entries());\n  if (!(additionalMap instanceof Map)) {\n    return result;\n  }\n  for (const key of additionalMap.keys()) {\n    if (!result.has(key) || allowOverwrite) {\n      result.set(key, additionalMap.get(key));\n    }\n  }\n  return result;\n};\n\n/**\n * Serializes a hashMap (plain javascript Map) to a string\n * \n * ```\n * const target = new Map([['first', 1], ['second', 2]]);\n * HashMapUtil.stringify(target);\n * // '{\"dataType\":\"Map\",\"value\":[[\"first\",1],[\"second\",2]]}'\n * ```\n * \n * Note, that passing indent will make the results much more legible.\n * \n * ```\n * {\n *   \"dataType\": \"Map\",\n *   \"value\": [\n *     [\n *       \"first\",\n *       1\n *     ],\n *     [\n *       \"second\",\n *       2\n *     ]\n *   ]\n * }\n * ```\n * @param {Map} target - the Map to be serialized\n * @param {Number} indentation - the indentation passed to JSON.serialize\n * @returns {String} - JSON.stringify string for the map\n */\nmodule.exports.stringify = function stringify(map, indentation) {\n  return JSON.stringify(map, FormatUtils.mapReplacer, indentation);\n};\n\n/**\n * Converts a map to an object\n * \n * For example, say we have a Map:\n * \n * ```\n * const targetMap = new Map([['first', 1], ['second', 2], ['third', 3]]);\n * ```\n * \n * We can convert it to an Object as follows:\n * \n * ```\n * const targetMap = utils.hashMap.toObject(targetObject)\n * // { first: 1, second: 2, third: 3 };\n * ```\n * \n * @param {Map} target - map to be converted\n * @returns {Object} - object with the properties as the target map's keys.\n * @see {@link hashMap.fromObject} - to reverse the process\n */\nmodule.exports.toObject = function toObject(target) {\n  const results = {};\n  if (!target) {// eslint-disable-line no-empty\n  } else if (!(target instanceof Map)) {\n    throw Error('hashMap.toObject(map): must be passed a Map');\n  } else {\n    [...target.keys()].forEach(key => {\n      results[key] = target.get(key);\n    });\n  }\n  return results;\n};\n\n/**\n * Creates a Map from the properties of an Object\n * \n * For example, say we have an object:\n * \n * ```\n * const targetObject = { first: 1, second: 2, third: 3 };\n * ```\n * \n * We can convert it to a Map as follows:\n * \n * ```\n * const targetMap = utils.hashMap.fromObject(targetObject)\n * // new Map([['first', 1], ['second', 2], ['third', 3]]);\n * ```\n * \n * @param {Object} target - target object with properties that should be considered keys\n * @returns {Map<String,any>} - converted properties as keys in a new map\n * @see {@link hashMap.toObject} - to reverse the process\n */\nmodule.exports.fromObject = function fromObject(target) {\n  if (!(typeof target === 'object')) {\n    throw Error('hashMap.fromObject(object): must be passed an object');\n  }\n  if (target.dataType === 'Map' && Array.isArray(target.value)) {\n    return new Map(target.value);\n  }\n  return [...Object.keys(target)].reduce((result, key) => HashMapUtil.add(result, key, target[key]), new Map());\n};\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./src/hashMap.js?");

/***/ }),

/***/ "./src/ijs.js":
/*!********************!*\
  !*** ./src/ijs.js ***!
  \********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint-disable no-use-before-define, function-paren-newline, no-param-reassign */\n\nconst uuid = (__webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-browser/index.js\").v4);\n__webpack_require__(/*! ./_types/global */ \"./src/_types/global.js\");\n\n/**\n * Simple library to support working within the [iJavaScript kernel within Jupyter](https://github.com/n-riesco/ijavascript)\n * \n * Note that this is available as `ijs` from within the\n * [jupyter-ijavascript-utils module](./index.html)\n * \n * * Asynchronous Methods\n *   * {@link module:ijs.await|ijs.await} - Helper function to support Await / Async functions in iJavaScript\n *   * {@link module:ijs.asyncConsole|ijs.asyncConsole} - Utility function for consoling a value in a .then() clause\n *   * {@link module:ijs.asyncWait|ijs.asyncWait} - Utility function for waiting x seconds between promise resolutions\n * * iJavaScript Context Detection\n *   * {@link module:ijs.detectIJS|ijs.detectIJS} - Detect if we are within iJavaScript context\n *   * {@link module:ijs.detectContext|ijs.detectContext} - Identify the $$ and console variables of the current cell\n * * Introspection\n *   * {@link module:ijs.listGlobals|ijs.listGlobals} - List global variables\n *   * {@link module:ijs.listStatic|ijs.listStatic} - List the static values on a class\n * * Rendering\n *   * {@link module:ijs.markdown|ijs.markdown} - Render output as markdown\n *   * {@link module:ijs.htmlScript|ijs.htmlScript} - Leverage external libraries like D3, Leaflet, etc.\n * \n * For example:\n * \n * ```\n * //-- get the data\n * //-- fetch the data\n * //-- and do not execute the next cell until received.\n * utils.ijs.await(async ($$, console) => {\n *  barley = await utils.datasets.fetch('barley.json');\n * })\n * ```\n * \n * ```\n * //-- use the data as though it was synchronously received\n * \n * //-- get the min max of the types of barley\n * barleyByVarietySite = d3.group(barley, d => d.variety, d => d.site)\n * //-- now group by variety and year\n * barleyByVarietyYear = d3.group(barley, d => d.variety, d => d.year)\n * ```\n * \n * then later\n * \n * ```\n * utils.ijs.listGlobals();\n * // ['barley','d3','barleyByVariety','barleyByVarietySite',...]\n * ```\n * \n * Or passing NodeJS variables to JavaScript\n * \n * ({@link module:ijs.htmlScript|See ijs.htmlScript for more})\n * ```\n * utils.ijs.htmlScript({\n *     scripts: ['https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js'],\n *     height: '100%',\n *     onReady: ({rootEl}) => {\n *         new QRCode(rootEl, \"https://jupyter-ijavascript-utils.onrender.com/\");\n *     }\n * });\n * ```\n * \n * ![Screenshot of QR Code](img/htmlScript_qrCode.png)\n * \n * @module ijs\n * @exports ijs\n */\nmodule.exports = {};\nconst IJSUtils = module.exports;\n\n/**\n * Set with names of common global variables that aren't needed to be listed.\n * @see #.listGlobals\n * @private\n */\nmodule.exports.COMMON_GLOBALS = new Set(['global', 'clearInterval', 'clearTimeout', 'setInterval', 'setTimeout', 'queueMicrotask', 'clearImmediate', 'setImmediate', 'module', 'exports', 'require', '$$mimer$$', '$$done$$']);\n\n/**\n * Set with names of static methods that often belong to a class.\n * @see #.listStatic\n * @private\n */\nmodule.exports.COMMON_STATIC = new Set(['length', 'prototype', 'name']);\n\n/**\n * Allow for asynchronous programming within iJavaScript nodes.\n * \n * * see [iJavaScript Async option docs](https://n-riesco.github.io/ijavascript/doc/async.ipynb.html)\n * * see [iJavaScript issue #73](https://github.com/n-riesco/ijavascript/issues/73)\n * * see [iJavaScript issue #173](https://github.com/n-riesco/ijavascript/issues/173)\n * \n * ![Screenshot](img/IJS_awaitBarley.png)\n * @example\n * \n * utils.ijs.await(async ($$, console) => {\n *    //-- $$ is the display for the current cell\n *    //-- console is the console for the current cell\n *    \n *    barley = await utils.datasets.fetch('barley.json');\n *    \n *    console.log(`retrieved:${barley.length} nodes`);\n * \n *    // return will be the value sent to $$.sendResults()\n *    // and shown alongside console\n *    return barley.slice(0,1)\n * })\n * \n * //-- outputs\n * \n * retrieved:120 nodes\n * \n * [\n *  {\n *    yield: 27,\n *    variety: 'Manchuria',\n *    year: 1931,\n *    site: 'University Farm'\n *  }\n * ]\n */\nmodule.exports[\"await\"] = async function ijsAsync(fn) {\n  const context = IJSUtils.detectContext();\n  if (!context) {\n    throw Error('IJSUtils.async must be run within iJavaScript. Otherwise, use normal async methods');\n  }\n  context.$$.async();\n  try {\n    const results = await fn(context.$$, context.console);\n    context.$$.sendResult(results);\n  } catch (err) {\n    context.console.error('error occurred');\n    context.console.error(err);\n    context.$$.sendResult(err);\n  }\n};\n\n/**\n * Simple promise chain for sending a console message\n * @param {String} message - the message to be sent to console\n * @returns {Function} - (results) => results passthrough\n * \n * @example\n * \n * Promise.resolve(200)\n *  .then(utils.ijs.asyncWait(2))\n *  .then(utils.ijs.asyncConsole('after waiting for 2 seconds'))\n *  .then((results) => console.log('results passed through: ${results}`));\n * \n * //--\n * after waiting for 2 seconds\n * results passed through: 200\n */\nmodule.exports.asyncConsole = (...messages) => results => {\n  console.log.apply(module.exports, messages);\n  return results;\n};\n\n/**\n * Simple promise chain for waiting N seconds.\n * @param {Number} seconds - the number of seconds to wait\n * @returns {Function} - (results) => results passthrough\n * \n * @example\n * \n * Promise.resolve(200)\n *  .then(utils.ijs.asyncConsole('before waiting for 2 seconds'))\n *  .then(utils.ijs.asyncWait(2))\n *  .then(utils.ijs.asyncConsole('after waiting for 2 seconds'))\n *  .then((results) => console.log('results passed through: ${results}`));\n * \n * //--\n * before waiting for 2 seconds\n * after waiting for 2 seconds\n * results passed through: 200\n */\nmodule.exports.asyncWait = seconds => results => new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(results);\n  }, seconds * 1000);\n});\n\n/**\n * Determines the current global display and console from iJavaScript\n * (or null if not within iJavaScript)\n * @returns {IJavaScriptContext} - ({ display, console }) or null if not within iJavaScript\n */\nmodule.exports.detectContext = function detectContext() {\n  if (typeof __webpack_require__.g.$$ === 'undefined' || typeof __webpack_require__.g.console === 'undefined') {\n    return null;\n  }\n  return {\n    $$: __webpack_require__.g.$$,\n    display: __webpack_require__.g.$$,\n    console: __webpack_require__.g.console\n  };\n};\n\n/**\n * Determines if we are currently within the iJavaScript context\n * @returns {Boolean} - true if the code is running within an iJavaScript kernel\n */\nmodule.exports.detectIJS = function detectIJS() {\n  return IJSUtils.detectContext() ? true : false;\n};\n\n/**\n * Prints markdown if in the context of iJavaScript.\n * \n * This can be deceptively helpful, as it allows your text to be data driven:\n * \n * ![Screenshot of markdown](img/ijsMarkdown.png)\n * \n * @param {String} markdownText - The markdown to be rendered\n * @example\n * \n * utils.ijs.markdown(`# Overview\n * This is markdown rendered in a cell.`);\n */\nmodule.exports.markdown = function markdown(markdownText, display) {\n  if (!IJSUtils.detectIJS()) return;\n  const displayToUse = display || __webpack_require__.g.$$;\n  displayToUse.mime({\n    'text/markdown': markdownText\n  });\n};\n\n/**\n * List the globals currently defined.\n * \n * This can be very useful when keeping track of values after a few cells.\n * \n * For example:\n * \n * ```\n * cars = utils.datasets.fetch('cars.json').then(data => global.cars = data);\n * ```\n * \n * then later\n * \n * ```\n * utils.ijs.listGlobals();\n * // cars\n * ```\n * \n * @returns {String[]} - list of the global variables\n * @see #.COMMON_GLOBALS\n */\nmodule.exports.listGlobals = function listGlobals() {\n  return Object.keys(__webpack_require__.g).filter(key => !IJSUtils.COMMON_GLOBALS.has(key));\n};\n\n/**\n * List the static members and functions of a class.\n * \n * @param {class} target - the target class\n * @returns {StaticMember[]} \n * @see #.COMMON_STATIC\n * \n * @example\n * \n * utils.ijs.listStatic(utils.ijs)\n * // [{type:'function', constructor:'Function', isMethod:true, name:'listStatic'}, ...]\n */\nmodule.exports.listStatic = function listStatic(target) {\n  if (!target) return [];\n  return Object.getOwnPropertyNames(target).filter(prop => !IJSUtils.COMMON_STATIC.has(prop)).map(prop => {\n    const propType = typeof target[prop];\n    const constructor = target[prop].constructor.name;\n    const isMethod = propType === 'function';\n    return {\n      type: propType,\n      constructor,\n      isMethod,\n      name: prop\n    };\n  });\n};\n\n/**\n * Generates and renders an html block that loads external css and javascript.\n * \n * **For example, allows running browser side {@link https://d3js.org/|d3js} in a Jupyter cell, {@link https://leafletjs.com/|Leaflet}, etc.**\n * \n * Remember, your cells in Jupyter are running in NodeJS.\n * \n * Once all the files have loaded, then `onReady` will execute in JavaScript.\n * \n * Note that only the function in onReady is executed in JavaScript\n * (i.e. Data from other cells in Jupyter would normally not be available).\n * \n * If data is needed from jupyter, pass them through `options.data`. (ex: airportData example below)\n * \n * **For More - See the {@tutorial htmlScript} tutorial.**\n * \n * # Example\n * \n * For example {@link https://github.com/davidshimjs/qrcodejs|using a cdn library for qr codes}\n * \n * ```\n * utils.ijs.htmlScript({\n *     scripts: ['https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js'],\n *     height: '100%',\n *     onReady: ({rootEl}) => {\n *         new QRCode(rootEl, \"https://jupyter-ijavascript-utils.onrender.com/\");\n *     }\n * });\n * ```\n * \n * ![Screenshot of QR Code](img/htmlScript_qrCode.png)\n * \n * Or working with {@link https://leafletjs.com/|Leaflet - to show maps}\n * \n * ```\n * //-- nodeJS Variable\n * airportData = { ohareORD: { lat: 41.975813, lon: -87.909428, title: \"O'Hare Intl Airport\" } };\n * //-- render out html\n * utils.ijs.htmlScript({\n *     scripts: ['https://unpkg.com/leaflet@1.6.0/dist/leaflet.js',\n *               'https://unpkg.com/leaflet-providers@1.13.0/leaflet-providers.js'],\n *     css: ['https://unpkg.com/leaflet@1.6.0/dist/leaflet.css'],\n *     data: airportData,\n *     height: 150,\n *     //-- function will be executed in javaScript\n *     onReady: ({rootEl, data}) => {\n *         // L is globally available from the leaflet.js script.\n *         \n *         //-- capture the nodeJS data and use in JavaScript. Neat!\n *         ohareORD = data.ohareORD;\n * \n *         map = L.map(rootEl);\n *         map.setView([ohareORD.lat, ohareORD.lon], 14);\n *         \n *         new L.marker([ohareORD.lat, ohareORD.lon]).bindPopup(ohareORD.title).addTo(map);\n *         \n *         L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n *            attribution: '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors'\n *         }).addTo(map);\n *     }\n * });\n * ```\n * \n * ![Screenshot of Leaflet](img/htmlScript_leaflet.png)\n * \n * @param {Object} options - additional options available during rendering\n * @param {String | Function} options.onReady - JavaScript to run once all files have loaded\n * @param {Element} options.onReady.rootEl - results div container\n * @param {any} [options.onReady.data] - the options.data parameter\n * @param {Object} options.onReady.utilityFunctions - the options.utilityFunctions object\n * @param {Object} options.onReady.options - the options object passed\n * @param {Object} options.onReady.animate - alias to requestAnimationFrame with additional checks to avoid leaks\n * @param {String[]} [options.scripts = []] - Array of JavaScript file addresses to load\n * @param {String[]} [options.css = []] - Array of CSS file addresses to load\n * @param {any} [options.data = undefined] - any nodejs data you would like available in javaScript\n * @param {String} [options.html = ''] - html elements to include within the result\n * @param {String | Number} [options.width = '100%'] - width of the div container (ex: 400 or '400px')\n * @param {String | Number} [options.height = '200px'] - height of the div container (ex: 200 or '200px')\n * @param {Boolean} [options.debug = false] - whether to incude a `debugger` breakpoint (once scripts are loaded)\n * @param {Boolean} [options.console = true] - whether to include console statements\n */\nmodule.exports.htmlScript = function htmlScripts(options) {\n  //-- you must be in iJavaScript container to rendeer\n  const context = IJSUtils.detectContext();\n  if (!context) {\n    throw new Error('ijsUtils.htmlScript: Must be in iJavaScript context to render html');\n  }\n  if (!options) options = {};\n  const {\n    debug: renderDebug = false,\n    console: renderConsole = true,\n    html = '',\n    data,\n    utilityFunctions = {}\n  } = options;\n  let {\n    width,\n    height,\n    uuid: rootUUID,\n    scripts: scriptAddresses,\n    css: stylesheetAddresses,\n    onReady: onReadyCode\n  } = options;\n\n  //-- verify the options sent are expected\n  const validKeys = new Set(['debug', 'console', 'width', 'height', 'uuid', 'scripts', 'css', 'html', 'data', 'onReady', 'utilityFunctions']);\n  const sentOptions = Object.keys(options);\n  const invalidOptions = sentOptions.filter(k => !validKeys.has(k));\n  if (invalidOptions.length > 0) {\n    throw Error(`ijsUtils.htmlScript: invalid options: ${invalidOptions}, must be within: ${[...validKeys].join(', ')}`);\n  }\n\n  //-- check that utilityFunctions are properly set.\n  let utilityFunctionStr = '';\n  if (utilityFunctions) {\n    if (typeof utilityFunctions !== 'object') {\n      throw Error('ijsUtils.htmlScript: utilityFunctions is an object that has only functions');\n    }\n    Object.keys(utilityFunctions).forEach(key => {\n      if (typeof utilityFunctions[key] !== 'function') {\n        throw Error(`ijsUtils.htmlScript: utilityFunctions must have only functions:${key}`);\n      }\n      utilityFunctionStr += `utilityFunctions.${key} = ${utilityFunctions[key].toString()};\\n`;\n    });\n  }\n  if (!width) {\n    width = '100%';\n  } else if (typeof width === 'number') {\n    width = `${width}px`;\n  }\n  if (!height) {\n    height = '200px';\n  } else if (typeof height === 'number') {\n    height = `${height}px`;\n  }\n  if (!scriptAddresses) {\n    scriptAddresses = [];\n  }\n  if (!stylesheetAddresses) {\n    stylesheetAddresses = [];\n  }\n\n  //-- allow this as there is some value over html now.\n  // if (scriptAddresses.length + stylesheetAddresses.length < 1) {\n  //   throw Error('ijsUtils.htmlScript: options have no `css` or `scripts`. If none are needed, use $$.html()');\n  // }\n\n  if (!onReadyCode) {\n    throw Error('ijsUtils.htmlScript: onReadyCode is required');\n  } else if (typeof onReadyCode === 'function') {\n    onReadyCode = `(${onReadyCode.toString()})({rootEl, data, utilityFunctions, options, animate})`;\n  } else if (typeof onReadyCode === 'string') {\n    onReadyCode = onReadyCode.trim();\n    if (!onReadyCode.endsWith(';')) {\n      onReadyCode += ';';\n    }\n  } else {\n    throw Error('ijsUtils.htmlScript: onReadyCode must be a string or function');\n  }\n\n  //-- the unique identifier for this run\n  //-- (corrects race conditions)\n  if (!rootUUID) rootUUID = uuid();\n  const generateCSS = (address, rootElementUUID, onloadFn) => `\n<link\n  rel=\"stylesheet\"\n  href=\"${address}\"\n  crossorigin=\"\"\n  uuid=\"${rootElementUUID}\"\n/>`;\n\n  // const scriptCode = scriptAddresses.map(\n  //   (addr) => generateScript(addr, rootUUID, 'externalScriptLoaded')\n  // ).join('\\n');\n\n  const cssCode = stylesheetAddresses.map(addr => generateCSS(addr, rootUUID, 'externalScriptLoaded')).join('\\n');\n\n  /* eslint-disable quotes, indent */\n\n  let results = `<html><body>\n  <div uuid=\"${rootUUID}\" style=\"width:${width}; height: ${height}\">${html}</div>\n  <div scriptUUID=\"${rootUUID}\" ></div>\n  <script>\n    if (typeof globalThis.uuidCountdown === 'undefined') {\n      globalThis.uuidCountdown = new Map();\n    }\n\n    globalThis.uuidCountdown.set('${rootUUID}', {\n      scriptIndex: -1,\n      scriptsToLoad: ${JSON.stringify(scriptAddresses)},\n      onReady: (rootUUID) => {\n        ${!renderConsole ? '' : `console.log('IJSUtils.htmlScript:' + rootUUID + ' starting render');`}\n  \n        ${!renderDebug ? '' : 'debugger;'}\n  \n        const rootEl = document.querySelector('div[uuid=\"${rootUUID}\"]');\n\n        const options = {\n          uuid: '${rootUUID}',\n          width: '${width}',\n          height: '${height}',\n          scripts: ${JSON.stringify(scriptAddresses)},\n          css: ${JSON.stringify(scriptAddresses)},\n        };\n\n        const animate = function (requestAnimationFrameTarget) {\n          requestAnimationFrame((...passThroughArgs) => {\n            if (!document.contains(rootEl)) {\n              console.log('old animation stopping. rootEl has been removed from DOM');\n              return;\n            }\n            requestAnimationFrameTarget.apply(globalThis, passThroughArgs);\n          })\n        }\n\n        //-- ijsUtils.htmlScipt options.data\n        const data = ${JSON.stringify(data)};\n\n        //-- ijsUtils.htmlScript options.utilityFunctions start\n        const utilityFunctions = {};\n        ${utilityFunctionStr}\n        //-- ijsUtils.htmlScript options.utiiltyFunctions end\n\n        //-- ijsUtils.htmlScript options.onRender start\n        ${onReadyCode}\n        //-- ijsUtils.htmlScript options.onRender end\n  \n        ${!renderConsole ? '' : `console.log('IJSUtils.htmlScript:' + rootUUID + ' ending render');`}\n      }\n    });\n\n    //-- script tags created dynamically have race conditions, load sequentially\n    function externalScriptLoaded(rootUUID) {\n      const result = globalThis.uuidCountdown.get(rootUUID);\n      result.scriptIndex += 1;\n      if (result.scriptIndex >= result.scriptsToLoad.length) {\n        result.onReady(rootUUID);\n        globalThis.uuidCountdown.delete(rootUUID);\n      } else {\n        const newScript = document.createElement('script');\n        newScript.src = result.scriptsToLoad[result.scriptIndex];\n        newScript.crossorigin='';\n        newScript.uuid=rootUUID;\n        newScript.onload = () => externalScriptLoaded(rootUUID);\n\n        const scriptRoot = document.querySelector('div[scriptUUID=\"' + rootUUID + '\"]');\n        scriptRoot.append(newScript);\n      }\n    }\n\n    externalScriptLoaded('${rootUUID}');\n  </script>\n  ${cssCode}\n</body></html>\n`;\n  results = results.replace(/\\n[ \\t]*\\n\\s*\\n/g, '\\n\\n').replace(/\\n[ \\t]*\\n/g, '\\n\\n');\n\n  /* eslint-enable quotes */\n\n  context.$$.html(results);\n  return results;\n};\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./src/ijs.js?");

/***/ }),

/***/ "./src/object.js":
/*!***********************!*\
  !*** ./src/object.js ***!
  \***********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint-disable no-param-reassign, max-len */\n\nconst schemaGenerator = __webpack_require__(/*! generate-schema */ \"./node_modules/generate-schema/src/index.js\");\nconst FormatUtils = __webpack_require__(/*! ./format */ \"./src/format.js\");\n\n/**\n * Utility for working with and massaging javascript objects.\n * \n * * Describe objects\n *   * {@link module:object.isObject|isObject()} - Determine if a given value is an Object and not a Number, String, Array or Date\n *   * {@link module:object.keys|keys()} - Safely get the keys of an object or list of objects\n *   * {@link module:object.getObjectPropertyTypes|getObjectPropertyTypes()} - describe the properties of a list of objects\n *   * {@link module:object.generateSchema|generateSchema()} - generate a schema / describe properties of a list of objects\n *   * {@link module:object.findWithoutProperties|findWithoutProperties()} - find objects without ALL the properties specified\n *   * {@link module:object.findWithoutProperties|findWithProperties()} - find objects with any of the properties specified\n *   * {@link module:object.propertyValueSample|propertyValueSample(collection)} - finds non-empty values for all properties found in the collection\n * * Fetch child properties from related objects\n *   * {@link module:object.fetchObjectProperty|fetchObjectProperty(object, string)} - use dot notation to bring a child property onto a parent\n *   * {@link module:object.fetchObjectProperties|fetchObjectProperties(object, string[])} - use dot notation to bring multiple child properties onto a parent\n *   * {@link module:object.join|join(array, index, map, fn)} - join a collection against a map by a given index\n *   * {@link module:object.joinProperties|join(array, index, map, ...fields)} - join a collection, and copy properties over from the mapped object.\n * * Fetch values safely\n *   * {@link module:object.propertyFromList|propertyFromList(array, propertyName)} - fetches a specific property from all objects in a list\n *   * {@link module:object.extractObjectProperty|extractObjectProperty(list, propertyNameOrFn)} - extracts a property or fn across all objects in list.\n *   * {@link module:object.extractObjectProperties|extractObjectProperties(list, propertyNameOrFnMap)} - extracts multiple propertie or fn across all objects in list.\n * * Apply deep values safely\n *   * {@link module:object.assign|objAssign(object, property, value)} - Applies properties to an object in functional programming style.\n *   * {@link module:object.augment|augment(object, augmentFn)} - Applies properties to an object similar to Map\n *   * {@link module:object.assignEntities|objAssignEntities(object, [property, value])} - Applies properties to an object using Array values - [key,value]\n *   * {@link module:object.setPropertyDefaults|setPropertyDefaults()} - sets values for objects that don't currently have the property\n *   * {@link module:object.applyPropertyValue|object.applyPropertyValue} - safely apply a value deeply and safely\n *   * {@link module:object.applyPropertyValues|object.applyPropertyValues} - apply an array of values safely and deeply against a list of objects.\n * * Manipulating objects\n *   * {@link module:object.augmentInherit|augmentInherit(object, augmentFn)} - Applies properties to a collection of objects, 'remembering' the last value - useful for 1d to *D lists.\n *   * {@link module:object.propertyInherit|object.propertyInherit(object, ...propertyName)} - Copies values from one record to the next if the current value is undefined.\n *   * {@link module:object.selectObjectProperties|selectObjectProperties()} - keep only specific properties\n *   * {@link module:object.filterObjectProperties|filterObjectProperties()} - remove specific properties\n *   * {@link module:object.mapProperties|mapProperties(collection, fn, ...properties)} - map multiple properties at once (like parseInt, or toString)\n *   * {@link module:object.formatProperties|formatProperties(collection, propertyTranslation)} - map specific properties (ex: toString, toNumber, etc)\n *   * {@link module:object.union|union(objectList1, objectList2)} - Unites the properties of two collections of objects.\n * * Rename properties\n *   * {@link module:object.cleanProperties|cleanProperties()} - correct inaccessible property names in a list of objects - in place\n *   * {@link module:object.cleanProperties2|cleanProperties2()} - correct inaccessible property names in a list of objects - on a cloned list\n *   * {@link module:object.cleanPropertyNames|cleanPropertyNames()} - create a translation of inaccessible names to accessible ones\n *   * {@link module:object.cleanPropertyName|cleanPropertyName()} - create a translation of a specific property name to be accessible.\n *   * {@link module:object.renameProperties|renameProperties()} - Use a translation from old property names to new ones\n * * Flatten object properties\n *   * {@link module:object.collapse|collapse()} - coalesce properties from all nested objects to the base object.\n *   * {@link module:object.flatten|flatten()} - creates dot notation properties (similar to arrow notation) of all child objects.\n *   * {@link module:object.expand|expand()}  - expands dot notation properties onto sub children (inverse of flatten)\n * * Create Map of objects by key\n *   * {@link module:object.mapByProperty|mapByProperty()} -\n *   * {@link module:group.by|group(collection, accessor)}\n * \n * @module object\n * @exports object\n */\nmodule.exports = {};\nconst ObjectUtils = module.exports;\n\n//-- private methods\n\n/**\n * Generates a function if a property or null or a function is sent\n * @param {Function | String} fnOrProp - \n * @return {Function}\n * @private\n */\nmodule.exports.evaluateFunctionOrProperty = function evaluateFunctionOrProperty(fnOrProp) {\n  if (!fnOrProp) {\n    return r => r;\n  } else if (typeof fnOrProp === 'string') {\n    if (fnOrProp.match(/[[.]/)) {\n      return r => ObjectUtils.fetchObjectProperty(r, fnOrProp, {\n        safeAccess: true\n      });\n    }\n    return r => r[fnOrProp];\n  } else if (typeof fnOrProp === 'function') {\n    return fnOrProp;\n  }\n  throw Error('Send either a Function or Property Name or null for a simple array');\n};\n\n/**\n * Identifies keys from an object, but handles null safely.\n * @param {Object} - object to get the keys from\n * @return {Array<String>} - collections of keys or [] if no keys are found.\n * @private\n */\nconst keysFromObject = obj => {\n  if (!obj) {\n    return [];\n  }\n  return Object.keys(obj);\n};\n\n/**\n * Adds all items into a set\n */\nconst setAddAll = (iteratable, targetSet) => {\n  iteratable.forEach(value => targetSet.add(value));\n  return targetSet;\n};\n\n//-- continued\n\n/**\n * The maximum depth that a collapse will go to \n * @type {Number}\n * @see {@link module:object.collapse|collapse()} - used with collapse\n */\nmodule.exports.MAX_COLLAPSE_DEPTH = 50;\n\n/**\n * Assign a property to an object and return object\n * (allowing for functional programming assignments)\n * @example objAssign({}, 'name', 'john').name === 'john'\n * @param {Object} [obj={}] - object to assign the value to (or null for a new one)\n * @param {String} propertyName -\n * @param {any} value -\n * @returns {Object}\n */\nmodule.exports.assign = function objAssign(obj, propertyName, value, ...propertyNameValues) {\n  if (propertyName === null || propertyName === undefined) {\n    throw Error('Expecting at least one property name to be passed');\n  } else if (typeof propertyName !== 'string') {\n    throw Error(`Property must be a string:${propertyName}`);\n  }\n  if (!obj) obj = {};\n  obj[propertyName] = value; //eslint-disable-line no-param-reassign\n\n  if (propertyNameValues.length > 0) {\n    ObjectUtils.objAssign.apply(ObjectUtils, [obj, ...propertyNameValues]);\n  }\n  return obj;\n};\nmodule.exports.objAssign = module.exports.assign;\n\n/**\n * Assigns multiple object entities [[property, value], [property, value], ...];\n * \n * @param {Object} [obj={}] - object to assign the values to\n * @param {Array} entities - 2d array [[property, value], ...]\n * @returns {Object}\n */\nmodule.exports.assignEntities = function objAssignEntities(obj, entities) {\n  if (!obj) obj = {};\n  if (!Array.isArray(entities)) {\n    throw Error('objAssignEntities: entities must be an array [[property, value]]');\n  } else if (entities.length < 1) {\n    throw Error('objAssignEntities: at least one entity must be sent');\n  }\n  entities.forEach(([property, value]) => {\n    obj[property] = value;\n  });\n  return obj;\n};\nmodule.exports.objAssignEntities = module.exports.assignEntities;\n\n/**\n * Runs a map over a collection, and adds properties the the objects.\n * \n * @param {Object | Array<Object>} objCollection - object or collection of objects to augment\n * @param {Function | Object} mappingFn - (record) => {Object} mapping function <br />\n *            or object with properties to create \n * @param {Boolean} [inPlace=false] - whether to update the collection in place (true) or cloned (false)\n * @returns {Array<Object>} - collection of records with the fields merged\n * @example\n * data = [{ source: 'A', value: 5 }, { source: 'B', value: 11 },\n *        { source: 'A', value: 6 }, { source: 'B', value: 13 },\n *        { source: 'A', value: 5 }, { source: 'B', value: 12 }];\n * utils.object.augment(data, (record) => ({ origin: 's_' + record.source }));\n * // returns\n * [{ source: 'A', value: 5, origin: 's_A' }, { source: 'B', value: 11, origin: 's_B' },\n *  { source: 'A', value: 6, origin: 's_A' }, { source: 'B', value: 13, origin: 's_B' },\n *  { source: 'A', value: 5, origin: 's_A' }, { source: 'B', value: 12, origin: 's_B' }];\n * \n * // by default `inPlace = false`, and data is not updated\n * data[0] // { source: 'A', value: 5 }\n * \n * // if `inPlace = true`, then data would be updated\n * data[0] // { source: 'A', value: 5, origin: 's_A' }\n */\nmodule.exports.augment = function augment(objCollection, mappingFn, inPlace = false) {\n  const collection = Array.isArray(objCollection) ? objCollection : [objCollection];\n  let results;\n  if (inPlace) {\n    collection.forEach(record => {\n      Object.assign(record, mappingFn(record));\n    });\n    results = collection;\n  } else {\n    results = collection.map(record => ({\n      ...record,\n      ...mappingFn(record)\n    }));\n  }\n  return results;\n};\n\n/**\n * Creates a map of a list of objects based on a specific property\n * @param {Object[]} collection - collection of objects\n * @param {Function | String} propertyOrFn - Name of the property or Function to return a value\n * @returns {Map<String, Object>} - map using the propertyName as the key\n * @see {@link module:group.by|group(collection, propertyOrFn)} - if there is a possibility the records are not unique\n * @example\n * const data = [{ id: '123', name: 'jim' },\n *    { id: '456', name: 'mary' },\n *    { id: '789', name: 'sue' }];\n * mapByProperty(data, 'id');\n * // Map(\n * //      '123': { id: '123', name: 'jim' },\n * //      '456': { id: '456', name: 'mary' },\n * //      '789': { id: '789', name: 'sue' });\n */\nmodule.exports.mapByProperty = function mapByProperty(collection, propertyOrFn) {\n  if (!propertyOrFn) throw new Error('object.mapByProperty: expects a propertyName');\n  const cleanedFunc = ObjectUtils.evaluateFunctionOrProperty(propertyOrFn);\n  return (collection || []).reduce((result, entry) => {\n    result.set(cleanedFunc(entry), entry);\n    return result;\n  }, new Map());\n};\n\n/**\n * Safely gets the keys from an object or array of objects\n * NOTE: much faster on object, as it will assume it needs to check all items in the array.\n * \n * This can be quite helpful to understand a list of objects that are not uniform in properties.\n * @param {(Object|Array)} objOrArray - a collection of objects (or a single object)\n * @param {Number} [maxRows=-1] - optional param - maximum number of rows to investigate\n *  for new keys if array passed. (ex: 2 means only investigate the first two rows)\n * @returns {String[]} - array of all the keys found\n * @see {@link module:describe.describeObjects}\n * @example\n * \n * //-- finding all properties from a heterogeneous list\n * collection = [{ name: 'john', age: 23 }, { name: 'jane', age: 24, score: 4.0 }];\n * utils.object.keys(collection); // ['name', 'age', 'score']\n * \n * //-- or using map on those keys\n * result = { name: 'john', age: 23, score: 4.0 };\n * utils.object.keys(result)\n *    .map(key => `${key}:${result[key]}`);  //-- you can now run map methods on those keys\n */\nmodule.exports.keys = function keys(objOrArray = {}, maxRows = -1) {\n  if (!Array.isArray(objOrArray)) {\n    return keysFromObject(objOrArray);\n  }\n  const result = new Set();\n  if (maxRows < 1) {\n    objOrArray.every((item, index) => setAddAll(keysFromObject(item), result));\n  } else {\n    //-- check \n    objOrArray.every((item, index) => {\n      if (index >= maxRows) {\n        return false;\n      }\n      setAddAll(keysFromObject(item), result);\n      return true;\n    });\n  }\n  return Array.from(result);\n};\n\n/**\n * Cleans all the properties of the array of objects in place (does not make Copies)\n * \n * **NOTE: This is faster than {@link module:ObjectUtils.cleanProperties2|cleanProperties2},\n * but the standard order of the properties (using Object.keys) will be altered.**\n * \n * @param {Object[]} objectsToBeCleaned -\n * @return {Object[]} - cleaned objects\n */\nmodule.exports.cleanProperties = function cleanProperties(objectsToBeCleaned) {\n  return ObjectUtils.renameProperties(objectsToBeCleaned, ObjectUtils.cleanPropertyNames(objectsToBeCleaned));\n};\n\n/**\n * Labels and Values from {@link module:object.cleanProperties2|object.cleanProperties2}\n * \n * ```\n * {\n *   labels: { date: 'date', kind: 'kind', num: 'num' },\n *   values: [\n *     { date: ' 2021-07-11T22:23:07+0100', kind: ' s', num: '192' },\n *     { date: ' 2021-07-09T19:54:48+0100', kind: ' c', num: '190' },\n *     { date: ' 2021-07-08T17:00:32+0100', kind: ' s', num: '190' }\n *   ]\n * };\n * ```\n * \n * @typedef {Object} CleanedProperties\n * @property {Object} labels - an object with translations of the fields and labels\n * @property {String} labels.property - for each translated property, stores the original property name\n * @property {Object[]} values - cleaned values\n \n */\n\n/**\n * Cleans properties on clones of objects.\n * \n * Additionally, this returns a mapping of what the properties used to be named,\n * as this can be helpful for rendering out tables.\n * \n * @param {Object[]} objectsToBeCleaned - collection of objects to be cleaned\n * @returns {CleanedProperties} - { labels: Object - propertyName:originalProperty, values: cleaned collection }\n * @see {@link module:object~CleanedProperties}\n * @example\nconst badData = [\n  { '\"name\"': 'john', num: '192', ' kind': ' s', '1st date': ' 2021-07-11T22:23:07+0100' },\n  { '\"name\"': 'jane', num: '190', ' kind': ' c', '1st date': ' 2021-07-09T19:54:48+0100' },\n  { '\"name\"': 'ringo', num: '190', ' kind': ' s', '1st date': ' 2021-07-08T17:00:32+0100' }\n];\nconst cleaned = objectUtils.cleanProperties2(badData);\n// {\n//   labels: { 1st_date: '1st date', kind: 'kind', num: 'num' },\n//   values: [\n//     { name: 'john', num: '192', kind: ' s', '1st_date': ' 2021-07-11T22:23:07+0100' },\n//     { name: 'jane', num: '190', kind: ' c', '1st_date': ' 2021-07-09T19:54:48+0100' },\n//     { name: 'ringo', num: '190', kind: ' s', '1st_date': ' 2021-07-08T17:00:32+0100' }\n//   ]\n// }\n */\nmodule.exports.cleanProperties2 = function cleanProperties2(objectsToBeCleaned) {\n  const cleanedPropertyNames = ObjectUtils.cleanPropertyNames(objectsToBeCleaned);\n  const keys = ObjectUtils.keys(cleanedPropertyNames);\n  const translation = keys.reduce((result, key) => ObjectUtils.objAssign(result, cleanedPropertyNames[key], ObjectUtils.lightlyCleanProperty(key)), {});\n  const values = (objectsToBeCleaned || []).map(obj => keys.reduce((result, key) => ObjectUtils.objAssign(result, cleanedPropertyNames[key], obj[key]), {}));\n  return {\n    labels: translation,\n    values\n  };\n};\n\n/**\n * cleans properties so they are still legible\n * @private\n * @param {String} propertyName - property name to be cleaned\n * @returns {String}\n */\nmodule.exports.lightlyCleanProperty = function lightlyCleanProperty(propertyName) {\n  //-- assume property name is a string\n  return propertyName.trim().replace(/^[\"']/, '').replace(/['\"]$/, '');\n};\n\n/**\n * Cleans the list of object keys - likely from a CSV\n * @param {(Object| String[])} objectKeys -\n * @return {Object} - object with key:value as original:new\n */\nmodule.exports.cleanPropertyNames = function cleanPropertyNames(target) {\n  let originalKeys;\n  if (!target) {\n    return {};\n  } else if (Array.isArray(target)) {\n    if (typeof target[0] === 'string') {\n      originalKeys = target;\n    } else {\n      originalKeys = ObjectUtils.keys(target);\n    }\n  } else {\n    originalKeys = Object.keys(target);\n  }\n  const result = {};\n  originalKeys.forEach(key => {\n    result[key] = ObjectUtils.cleanPropertyName(key);\n  });\n  return result;\n};\n\n/**\n * Cleans an individual property\n * @param {String} property -\n * @returns {String}\n */\nmodule.exports.cleanPropertyName = function cleanPropertyName(property) {\n  const cleanProperty = property.trim().replace(/[^a-zA-Z0-9]/g, ' ').trim().replace(/\\s+/g, '_');\n  return cleanProperty;\n};\nconst renameObjectProperties = function renameObjectProperties(object, originalKeys, targetKeys) {\n  const result = {\n    ...object\n  };\n  originalKeys.forEach((originalKey, index) => {\n    const targetKey = targetKeys[index];\n    if (targetKey !== originalKey) {\n      result[targetKey] = result[originalKey];\n      delete result[originalKey];\n    }\n  });\n  return result;\n};\n\n/**\n   * Property Reassign - either against a single object or an array of objects\n   * @example renameProperties(\n   *  { '\"first name\"': 'john', '\"last name\"': 'doe' }, {'\"first name\"':'first_name'}\n   *  ).deepEquals({first_name: 'john', '\"last name\"': 'doe'})\n   * @param {Object[]} objects - objects to reassign - likely from a CSV\n   * @param {Object} propertyTranslations - where property:value is original:new\n   * @returns {Object[]}\n   */\nmodule.exports.renameProperties = function renameProperties(objects, propertyTranslations) {\n  const originalKeys = Object.keys(propertyTranslations);\n  const targetKeys = Object.values(propertyTranslations);\n  if (Array.isArray(objects)) {\n    return objects.map(object => renameObjectProperties(object, originalKeys, targetKeys));\n  }\n  return renameObjectProperties(objects, originalKeys, targetKeys);\n};\nconst collapseSpecificObject = function collapseSpecificObject(sourceObj, targetObj, depth) {\n  if (depth > ObjectUtils.MAX_COLLAPSE_DEPTH) return;\n  if (targetObj) {\n    const targetObjProperties = Object.getOwnPropertyNames(targetObj);\n    targetObjProperties.forEach(prop => {\n      const propType = typeof targetObj[prop];\n      if (propType === 'object') {\n        collapseSpecificObject(sourceObj, targetObj[prop], depth + 1);\n      } else {\n        sourceObj[prop] = targetObj[prop];\n      }\n    });\n  }\n  return sourceObj;\n};\n\n/**\n * Collapse an object tree into a single object with all the properties.\n * @example\n * const targetObj = { make: 'Ford', model: 'F150', driver: {firstName:'John', lastName:'doe'}};\n * const collapsed - utils.collapse(targetObj);\n * console.log(`Hi ${collapsed.firstName}, how do you like your ${collapsed.model}?`);\n * // 'Hi John, how do you like your F150?\n * @param {Object} objectTree\n * @returns {Object} - object with all the properties added\n * @see #MAX_COLLAPSE_DEPTH - library property that defines how far to collapse\n */\nmodule.exports.collapse = function collapse(targetObj) {\n  return collapseSpecificObject({}, targetObj, 0);\n};\n\n/**\n * Determines whether a value is an Object and not an Array or a Date\n * @param {any} testValue - value to be tested\n * @returns {Boolean} - whether the testValue is an Object and not an Array or a Date.\n */\nmodule.exports.isObject = o => o != null && typeof o === 'object' && !Array.isArray(o) && !(o instanceof Date);\n\n/**\n * While originally intended as a sub-implementation for Flatten,\n * this was exposed in case additional cases ever arose.\n * \n * Example:\n * \n * ```\n * student = { first: 'john', last: 'doe' };\n * friend = { first: 'jane', last: 'doe' };\n * course = { id: 'econ-101', professor: { id: 10101, first: 'jim', last: 'gifford' }};\n * flattenedObj = {};\n * flattenedObj = utils.object.flattenObjectOntoAnother(student, flattenedObj);\n * // { first: 'john', last: 'doe' }\n * flattenedObj = utils.object.flattenObjectOntoAnother(friend, flattenedObj, 'friend.');\n * // { first: 'john', last: 'doe', 'friend.first': 'jane', 'friend.last': 'doe' };\n * flattenedObj = utils.object.flattenObjectOntoAnother(course, flattenedObj, 'course.');\n * // { first: 'john', last: 'doe', 'friend.first': 'jane', 'friend.last': 'doe', 'course.id': 'econ-101',\n * //   'course.professor.id': 10101, 'course.professor.first': 'jim', 'course.professor.last': 'gifford' };\n * ```\n * \n * See flatten for a an alternative to achieve the same result.\n * \n * @param {Object} sourceObj - The object to review for source values / properties\n * @param {Object} [targetObj={}] - The object to apply the dot notation properties onto\n * @param {String} [prefix=''] - the string prefix of any properties found on source, to apply onto target\n * @returns {Object} - the targetObj with the properties applied (in place)\n */\nmodule.exports.flattenObjectOntoAnother = function flattenObjectOntoAnother(sourceObj, targetObj, prefix) {\n  const cleanTarget = targetObj || {};\n  const cleanPrefix = prefix || '';\n  if (!ObjectUtils.isObject(sourceObj)) {\n    return sourceObj;\n  }\n  const sourceKeys = ObjectUtils.keys(sourceObj);\n  sourceKeys.forEach(key => {\n    const prefixedKey = `${cleanPrefix}${key}`;\n    const keyValue = sourceObj[key];\n    if (ObjectUtils.isObject(keyValue)) {\n      ObjectUtils.flattenObjectOntoAnother(keyValue, cleanTarget, `${prefixedKey}.`);\n    } else {\n      cleanTarget[prefixedKey] = keyValue;\n    }\n  });\n  return cleanTarget;\n};\n\n/**\n * Flattens an object and sub-objects into dot notation - to have easier time understanding schemas and explainations.\n * \n * example:\n * \n * ```\n * student = {\n *  first: 'john', last: 'doe',\n *  friend: { first: 'jane', last: 'doe' },\n *  course: { id: 'econ-101', professor: { id: 10101, first: 'jim', last: 'gifford' }}\n * };\n * \n * flattenedObj = utils.object.flatten(student);\n * // {\n * //   first: 'john', last: 'doe',\n * //   'friend.first': 'jane', 'friend.last': 'doe',\n * //   'course.id': 'econ-101',\n * //     'course.professor.id': 10101, 'course.professor.first': 'jim', 'course.professor.last': 'gifford'\n * // };\n * ```\n * @param {Object} targetObj - Object with all properties and sub-objects to flatten.\n * @returns {Object} - New object with dot notation properties\n * @see {@link module:object.expand|expand()} - as the inverse\n * @see {@link module:describe.describeObjects|describeObjects(collection, options)} - as a way to describe the values provided\n */\nmodule.exports.flatten = function flatten(targetObj) {\n  return ObjectUtils.flattenObjectOntoAnother(targetObj);\n};\n\n/**\n * The inverse of Flatten - this takes an object with dot notation properties,\n * and creates the sub-objects as necessary to contain the properties defined.\n * \n * Example:\n * \n * ```\n * flattenedObj = {\n *   first: 'john', last: 'doe',\n *   'friend.first': 'jane', 'friend.last': 'doe',\n *   'course.id': 'econ-101',\n *     'course.professor.id': 10101, 'course.professor.first': 'jim', 'course.professor.last': 'gifford'\n * };\n * \n * expandedObj = utils.object.expand(flattenedObj);\n * // {\n * //  first: 'john', last: 'doe',\n * //  friend: { first: 'jane', last: 'doe' },\n * //  course: { id: 'econ-101', professor: { id: 10101, first: 'jim', last: 'gifford' }}\n * // };\n * ```\n * \n * @param {Object} targetObj - a flattened object (with dot notation properties) to be expanded\n * @returns {Object} - a new object with sub-objects for each of the dot-notation entries\n * @see {@link module:object.flatten|flatten()} - as the inverse\n */\nmodule.exports.expand = function expand(targetObj) {\n  if (!ObjectUtils.isObject(targetObj)) return targetObj;\n  const result = {};\n  const keys = ObjectUtils.keys(targetObj);\n  keys.forEach(key => {\n    ObjectUtils.applyPropertyValue(result, key, targetObj[key]);\n  });\n  return result;\n};\n\n/**\n * Keeps only specific properties on an object or list of objects\n * @param {Object | Object[]} list - collection of objects to filter\n * @param {String[]} propertyNames - list of the only properties to keep\n * @returns {Object[]}\n */\nmodule.exports.selectObjectProperties = function selectObjectProperties(list, ...propertyNames) {\n  const cleanPropertyNames = propertyNames.length > 0 && Array.isArray(propertyNames[0]) ? propertyNames[0] : propertyNames;\n  if (!list) return [];\n  const targetList = Array.isArray(list) ? list : [list];\n  return targetList.map(record => cleanPropertyNames.reduce((result, prop) => ObjectUtils.objAssign(result, prop, record[prop]), {}));\n};\n\n/**\n * Removes specific properties on an object or list of objects\n * @param {Object | Object[]} list - collection of objects to filter\n * @param {String[]} propertyNames - list of the only properties to keep\n * @returns {Object[]}\n */\nmodule.exports.filterObjectProperties = function filterObjectProperties(list, propertyNames) {\n  if (!list) return [];\n  const targetList = Array.isArray(list) ? list : [list];\n  return targetList.map(obj => {\n    const clone = {\n      ...obj\n    };\n    propertyNames.forEach(propertyToRemove => delete clone[propertyToRemove]);\n    return clone;\n  });\n};\n\n/**\n * Similar to a transpose, this finds all the values of a particular property\n * within a list of objects.\n * \n * ```\n * weather = [\n *   { id: 1, city: 'Seattle',  month: 'Aug', precip: 0.87 },\n *   null,\n *   { id: 3, city: 'New York', month: 'Apr', precip: 3.94 },\n *   { id: 6, city: 'Chicago',  month: 'Apr', precip: 3.62 }\n * ];\n * \n * utils.object.extractObjectProperty(weather, 'city');\n * // [ 'Seattle', 'New York', 'Chicago'];\n * ```\n * \n * However, this can be helpful to extract values safely from deeply nested values\n * \n * ```\n * data = [{\n *    category_id: 'c884a636628bca341e', menu_item_id: 'mi88dc7bb31bc6104f1',\n *    item_sizes: [{ id: 'mio882f48820281cf4b6', price: 16.09 }]\n * },\n * {\n *    category_id: 'c884a636628bca341e', menu_item_id: 'mi8802b942e737df40d',\n *    item_sizes: [{ id: 'mio88b60bcd7dd202481', price: 17.09 }]\n * },\n * {\n *    category_id: 'c884a636628bca341e', menu_item_id: 'mi88ff22662b0c0644a',\n *    item_sizes: [{ id: 'mio88645e98cd8ffc42e', price: 14.99 }]\n * }];\n * \n * utils.object.extractObjectProperty(data, 'item_sizes[0].price');\n * // [ 16.09, 17.09, 14.99 ]\n * ```\n * \n * @param {Object|Object[]} objectList - list of objects to extract the property from\n * @param {Function | String} propertyOrFn - Name of the property or accessor function\n * @returns {Array} - single array the values stored in propertyOrFn across all objects in objectList.\n * @see {@link module:aggregate.unique|unique()} to see all the unique values stored\n * @see {@link module:object.extractObjectProperties|object.extractObjectProperties} - to extract into array vectors \n * @see {@link module:object.fetchObjectProperty|object.fetchObjectProperty} - to extract a deep value and optionally throw if not found\n * @see {@link module:object.applyPropertyValue|object.applyPropertyValue} - to apply a single value to a single object using dot notation safely\n */\nmodule.exports.extractObjectProperty = function extractObjectProperty(list, propertyOrFn) {\n  let cleanList = !list ? [] : Array.isArray(list) ? list : [list];\n  cleanList = cleanList.filter(r => r);\n  const fn = ObjectUtils.evaluateFunctionOrProperty(propertyOrFn);\n  return cleanList.map(fn);\n};\n\n/**\n * Similar to {@link module:object:extractObjectProperty|object.extractObjectProperty} -\n * this extracts out multiple property/vectors at a time.\n * \n * Note that unlike numpy, there is a key preserved in the result - to better\n * keep track of what the values were intended to represent.\n * \n * ```\n * weather = [\n *   { id: 1, city: 'Seattle',  month: 'Aug', precip: 0.87 },\n *   null,\n *   { id: 3, city: 'New York', month: 'Apr', precip: 3.94 },\n *   { id: 6, city: 'Chicago',  month: 'Apr', precip: 3.62 }\n * ];\n * \n * utils.object.extractObjectProperties(weather, ['city', 'month']);\n * // { \n * //   city: [ 'Seattle', 'New York', 'Chicago'],\n * //   month: ['Aug', 'Apr', 'Apr']\n * // }\n * ```\n * \n * Keys will be the the dot notation of the path used `ex: prop[index].value`\n * or can be explicitly set through a `[key, accessor]` pair\n * \n * ```\n * utils.object.extractObjectProperties(weather, ['city', ['Month', 'month'], ['precipitation', r => r.precip]]);\n * // { \n * //   city: [ 'Seattle', 'New York', 'Chicago'],\n * //   month: ['Aug', 'Apr', 'Apr'],\n * //   precipitation: [0.87, 3.94, 3.62]\n * // }\n * ```\n * \n * However, this can be helpful to extract values safely from deeply nested values\n * \n * ```\n * data = [{\n *    category_id: 'c884a636628bca341e', menu_item_id: 'mi88dc7bb31bc6104f1',\n *    item_sizes: [{ id: 'mio882f48820281cf4b6', price: 16.09 }]\n * },\n * {\n *    category_id: 'c884a636628bca341e', menu_item_id: 'mi8802b942e737df40d',\n *    item_sizes: [{ id: 'mio88b60bcd7dd202481', price: 17.09 }]\n * },\n * {\n *    category_id: 'c884a636628bca341e', menu_item_id: 'mi88ff22662b0c0644a',\n *    item_sizes: [{ id: 'mio88645e98cd8ffc42e', price: 14.99 }]\n * }];\n * \n * utils.object.extractObjectProperty(data, ['menu_item_id', 'item_sizes[0].price']);\n * // {\n * //   menu_item_id: ['mi88dc7bb31bc6104f1', 'mi8802b942e737df40d', 'mi88ff22662b0c0644a'],\n * //   'item_sizes[0].price': [ 16.09, 17.09, 14.99 ]\n * // }\n * ```\n * \n * Note that this can also work with maps of properties / paths or functions\n * \n * ```\n * // note you can also pass maps with property name strings, or functions.\n * extractionMap = new Map();\n * extractionMap.set('city', null); // default the property by the key name\n * extractionMap.set('city2', 'city'); // specify the property to use\n * extractionMap.set('city3', (r) => r.city); // specify a function\n * \n * utils.object.extractObjectProperties(weather, extractionMap);\n * // {\n * //   city: ['Seattle', 'New York', 'Chicago'],\n * //   city2: ['Seattle', 'New York', 'Chicago'],\n * //   city3: ['Seattle', 'New York', 'Chicago']\n * // };\n * ```\n * \n * @param {Object|Object[]} objectList - list of objects to extract the property from\n * @param {Map<Function | String>} propertyOrFnMap - Name of the property or accessor function\n * @returns {Object} - Object with the keys in the map as properties - extracting the values across all in list.\n * @see {@link module:object.extractObjectProperty|extractObjectProperty(list, propertyNameOrFn)} to see all the values stored for a single property.\n * @see {@link module:object.applyPropertyValues|object.applyPropertyValues} - to safely and deeply apply the list of values extracted to a list of objects.\n * @see {@link module:object.fetchObjectProperties} - to fetch multiple properties at once into objects\n */\nmodule.exports.extractObjectProperties = function extractObjectProperties(list, propertyOrFnMap) {\n  let propertyEntries = [];\n  const signature = 'object.extractObjectProperties(list:Object[], propertyOrFnMap:Map<String, stringOrFn>)';\n  if (!propertyOrFnMap) {\n    return [];\n  } else if (Array.isArray(propertyOrFnMap)) {\n    for (let i = 0; i < propertyOrFnMap.length; i += 1) {\n      const propertyOrFnKey = propertyOrFnMap[i];\n\n      //-- only string properties are accepted as an array\n      if (typeof propertyOrFnKey === 'string') {\n        propertyEntries.push([propertyOrFnKey, propertyOrFnKey]);\n      } else if (Array.isArray(propertyOrFnKey)) {\n        propertyEntries.push(propertyOrFnKey);\n      }\n    }\n  } else if (propertyOrFnMap instanceof Map) {\n    propertyEntries = [...propertyOrFnMap.entries()];\n  } else {\n    throw Error(`${signature}: propertyOrFnMap must be a map of propertyName keys, with a function or property name as the value`);\n  }\n  const results = {};\n  propertyEntries.forEach(([propertyName, propertyOrFn]) => {\n    results[propertyName] = ObjectUtils.extractObjectProperty(list, propertyOrFn || propertyName);\n  });\n  return results;\n};\n\n/**\n * Options for fetching object properties\n * @typedef {Object} FetchObjectOptions\n * @property {Boolean} safeAccess - whether to safely access, even if the path cannot be found\n */\n\n/**\n * Fetches multiple properties from an object or list of objects.\n * \n * ```\n * testObj = {\n *  name: 'john',\n *  courses: [{ name: 'econ-101' }]\n * }\n * utils.object.fetchObjectProperty(testObj,\n *  { 'courseName': 'courses[0].?name', personName: 'name' });\n * // { courseName: 'econ-101', personName: 'john' }\n * ```\n * \n * @param {Object | Object[]} list - collection of objects to reduce\n * @param {Object<String,any>} propertyNames - Object with the keys as as properties to return,\n *    and the values using dot notation to access related records and properties\n *    (ex: {parentName: 'somePropertyObject.parent.parent.name', childName: 'child.Name'})\n * @param {FetchObjectOptions} options - {@link module:object~FetchObjectOptions|See FetchObjectOptions} \n * @returns {Object[]} - objects with the properties resolved\n *    (ex: {parentname, childName, etc.})\n * @see {@link module:object.fetchObjectProperty|object.fetchObjectProperty} - to safely fetch  a single value\n * @see {@link module:object.applyPropertyValues|object.applyPropertyValues} - to safely and deeply apply the list of values extracted to a list of objects.\n * @see {@link module:object.extractObjectProperties|object.extractObjectProperties} - to extract into array vectors instead of objects\n */\nmodule.exports.fetchObjectProperties = function fetchObjectProperties(list, propertyNames, options = {}) {\n  if (!list) return [];\n  const targetList = Array.isArray(list) ? list : [list];\n  const {\n    //-- whether to fetch only those specific properties, or append to the object\n    append = false\n  } = options;\n  const props = Object.getOwnPropertyNames(propertyNames);\n  return targetList.map(obj => {\n    const result = append ? {\n      ...obj\n    } : {};\n    props.forEach(prop => {\n      result[prop] = ObjectUtils.fetchObjectProperty(obj, propertyNames[prop], options);\n    });\n    return result;\n  });\n};\n\n/**\n * Accesses a property using a string\n * \n * ```\n * testObj = {\n *  name: 'john',\n *  courses: [{ name: 'econ-101' }]\n * }\n * utils.object.fetchObjectProperty(testObj, 'courses[0].?name');\n * // 'econ-101'\n * ```\n * \n * note that the options allow for safe property access\n * \n * ```\n * testObj = {\n *  name: 'john',\n *  courses: [{ name: 'econ-101' }]\n * }\n * utils.object.fetchObjectProperty(testObj, 'courses[0].courseId');\n * // throws an error\n * \n * utils.object.fetchObjectProperty(testObj, 'courses[0].?courseId');\n * // null - because of optional condition operator\n * \n * utils.object.fetchObjectProperty(testObj, 'courses[0].courseId', { safeAccess: true });\n * // null - because of the safe access option\n * ```\n * \n * @param {Object} obj - object to access the properties on\n * @param {String} propertyAccess - dot notation for the property to access\n *    (ex: `parent.obj.Name`)\n * @param {FetchObjectOptions} options - {@link module:object~FetchObjectOptions|See FetchObjectOptions}\n * @returns {any} - the value accessed at the end ofthe property chain\n * @see {@link module:object.fetchObjectProperties} - to fetch multiple properties at once into objects\n * @see {@link module:object.extractObjectProperty|object.extractObjectProperty} - to safely extract a deep value without options\n * @see {@link module:object.applyPropertyValue|object.applyPropertyValue} - to apply a single value to a single object using dot notation safely\n */\nmodule.exports.fetchObjectProperty = function fetchObjectProperty(obj, propertyAccess, options = {}) {\n  if (!obj || !propertyAccess) return null;\n  const {\n    //-- whether to safely access even if object path cannot be found\n    safeAccess = false\n  } = options;\n  const cleanPropertyAccess = String(propertyAccess).replace(/\\[/g, '.').replace(/\\]/g, '.').replace(/[.]+/g, '.').replace(/^[.]+/, '').replace(/[.]$/, '');\n  return cleanPropertyAccess.split('.').reduce((currentVal, prop) => {\n    let isElvis = false;\n    let cleanProp = prop;\n    if (prop && prop.length > 0 && prop[0] === '?') {\n      isElvis = true;\n      cleanProp = prop.slice(1);\n    }\n    if (currentVal) {\n      return currentVal[cleanProp];\n    } else if (safeAccess || isElvis) {\n      return null;\n    }\n    throw Error(`Invalid property ${propertyAccess} [${prop}] does not exist - safeAccess:${safeAccess}`);\n  }, obj);\n};\n\n/**\n * Applies a target value onto a source object in-place safely - using dot-notation paths.\n * \n * This can be as simple as safely applying a value even if targetObj may be null\n * ```\n * targetObj = { id: 1, city: 'Seattle',  month: 'Aug', precip: 0.87 };\n * utils.object.applyPropertyValue(targetObj, 'state', 'WA');\n * // { id: 1, city: 'Seattle',  month: 'Aug', precip: 0.87, state: 'WA };\n * ```\n * \n * working with deeply nested objects\n * ```\n * targetObj = { name: 'john smith', class: { name: 'ECON_101', professor: { last_name: 'Winklemeyer' }} };\n * utils.object.applyPropertyValue(targetObj, 'class.professor.first_name', 'RenÃ©');\n * // { name: 'john smith', class: { name: 'ECON_101', professor: { last_name: 'Winklemeyer', first_name: 'RenÃ©' }} };\n * ```\n * \n * or safely working with arrays of values\n * ```\n * targetObj = { name: 'john smith', classes: [{ name: 'ECON_101' }] };\n * utils.object.applyPropertyValue(targetObj, 'classes[0].grade', 'A');\n * // { name: 'john smith', classes: [{ name: 'ECON_101', grade: 'A' }] };\n * ```\n * \n * @param {Object} obj - object to apply the value to\n * @param {string} path - dot notation path to set the value, ex: 'geo', or 'states[0].prop'\n * @param {any} value - value to set\n * @returns {Object} - the object the value was applied to\n * @see {@link module:object.applyPropertyValues|object.applyPropertyValues} - to safely and deeply apply the list of values extracted to a list of objects.\n * @see {@link module:object.extractObjectProperty|object.extractObjectProperty} - to safely extract a deep value\n * @see {@link module:object.fetchObjectProperty|object.fetchObjectProperty} - to extract a deep value and optionally throw if not found\n */\nmodule.exports.applyPropertyValue = function applyPropertyValue(obj, path, value) {\n  // const signature = 'applyPropertyValue(obj, path, value)';\n\n  if (!obj) return obj;\n  if (!path) return obj;\n  const cleanPath = String(path).replace(/\\[/g, '.').replace(/\\]/g, '.').replace(/[.]+/g, '.').replace(/^[.]+/, '').replace(/[.]$/, '');\n  const splitPath = cleanPath.split('.');\n  const terminalIndex = splitPath.length - 1;\n  return splitPath.reduce((currentVal, prop, currentIndex) => {\n    //-- can no longer occur\n    // if (!prop) throw Error(`${signature}:Unable to set value with path:${path}`);\n\n    const isLeaf = currentIndex === terminalIndex;\n    if (isLeaf) {\n      // eslint-disable-next-line no-param-reassign\n      currentVal[prop] = value;\n      // if (value === undefined) {\n      //   delete currentVal[prop];\n      // } else {\n      //   currentVal[prop] = value;\n      // }\n      return obj;\n    }\n    //-- not a leaf\n    if (!currentVal[prop]) {\n      // eslint-disable-next-line no-param-reassign\n      currentVal[prop] = {};\n    }\n    return currentVal[prop];\n  }, obj);\n};\n\n/**\n * Opposite of the extractObjectProperty, this takes a value / set of values\n * and applies them along a given path on each of the target objects.\n * \n * for example:\n * \n * ```\n * weather = [{ id: 1, city: 'Seattle',  month: 'Aug', precip: 0.87 },\n *   { id: 3, city: 'New York', month: 'Apr', precip: 3.94 },\n *   { id: 6, city: 'Chicago',  month: 'Apr', precip: 3.62 }];\n * \n * cities = utils.object.extractObjectProperty('city');\n * // ['Seattle', 'New York', 'Chicago'];\n * \n * //-- async process to geocode\n * geocodedCities = geocodeCity(cities);\n * // [{ city: 'Seattle', state: 'WA', country: 'USA' },\n * // { city: 'New York', state: 'NY', country: 'USA' },\n * // { city: 'Chicago', state: 'IL', country: 'USA' }]\n * \n * utils.applyPropertyValues(weather, 'geo', geocodedCities);\n *  [{ id: 1, city: 'Seattle',  month: 'Aug', precip: 0.87, geo: { city: 'Seattle', state: 'WA', country: 'USA' } },\n *   { id: 3, city: 'New York', month: 'Apr', precip: 3.94, geo: { city: 'New York', state: 'NY', country: 'USA' } },\n *   { id: 6, city: 'Chicago',  month: 'Apr', precip: 3.62, geo: { city: 'Chicago', state: 'IL', country: 'USA' } }];\n * \n * Note that traditional [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\n * works best for if you are working with objects completely in memory.\n * \n * But this helps quite a bit if the action of mapping / transforming values\n * needs to be separate from the extraction / application of values back.\n * \n * @param {Object} obj - object to apply the value to\n * @param {string} path - dot notation path to set the value, ex: 'geo', or 'states[0].prop'\n * @param {any} value - the value that should be set at that path.\n * @returns {Object}\n * @see {@link module:object.applyPropertyValue} - to apply a single value to a single object\n * @see {@link module:object.fetchObjectProperties} - to fetch multiple properties at once into objects\n * @see {@link module:object.extractObjectProperties|object.extractObjectProperties} - to extract properties into array vectors instead of objects\n */\nmodule.exports.applyPropertyValues = function applyPropertyValues(objectList, path, valueList) {\n  // const signature = 'applyPropertyValues(objectList, path, valueList)';\n  if (!objectList || !path) {\n    //-- do nothing\n    return objectList;\n  }\n  const cleanObjectList = Array.isArray(objectList) ? objectList : [objectList];\n  const cleanValueList = Array.isArray(valueList) ? valueList : Array(cleanObjectList.length).fill(valueList);\n\n  // if (cleanObjectList.length !== cleanValueList) throw Error(\n  //   `${signature}: objectList.length[${cleanObjectList.length}] does not match valueList.length[${cleanValueList.length}]`\n  // );\n  const minLength = Math.min(cleanObjectList.length, cleanValueList.length);\n  for (let i = 0; i < minLength; i += 1) {\n    const obj = cleanObjectList[i];\n    const val = cleanValueList[i];\n    ObjectUtils.applyPropertyValue(obj, path, val);\n  }\n  return objectList;\n};\n\n/**\n * Translates specific properties to a new value on an object, or collection of objects.\n * \n * The properties defined in the `propertyTranslations` argument is then the property to be updated. (All other properties remain the same)\n * \n * You can either provide a function accepting the current value and returning the new value (any) => any\n * \n * Or you can provide one of the common shorthands:\n * \n * * 'string'\n * * 'float' or 'number'\n * * 'int' or 'integer'\n * * 'boolean'\n * \n * ```\n * data = [\n *   {station: 'A', isFahreinheit: 'true', offset: '0', temp: 98, type: 'F', descr: '0123'},\n *   {station: 'A', isFahreinheit: 'TRUE', offset: '2', temp: 99, type: 'F', descr: '0123456'},\n *   {station: 'A', isFahreinheit: 'false', offset: '3', temp: 100, type: 'F', descr: '0123456789'}\n * ];\n * \n * utils.object.format(data, ({\n *   //-- to a literal value\n *   type: 'C',\n *   //-- convert it to 'string', 'number' || 'float', 'int' || 'integer', 'boolean'\n *   offset: 'number',\n *   isFahreinheit: 'boolean',\n *   //-- or convert the value with a function accepting the current value\n *   //-- and returning the new value\n *   temp: (val) => (val - 32) * 0.5556\n * }));\n * \n * // [\n * //   { station: 'A', isFahreinheit: true, offset: 0, temp: 36.669599999999996, type: 'C', descr: '0123' },\n * //   { station: 'A', isFahreinheit: true, offset: 2, temp: 37.2252, type: 'C', descr: '0123456' },\n * //   { station: 'A', isFahreinheit: false, offset: 3, temp: 37.7808, type: 'C', descr: '0123456789' }\n * // ];\n * ```\n * \n * **Please note, you can pass a single object to be cleaned**,<br /> but it will be returned as an array of one object.\n * \n * ```\n * data = [{station: 'A', isFahreinheit: 'TRUE', offset: '2', temp: 99, type: 'F', descr: '0123456'}];\n * \n * utils.object.format(data, ({\n *   //-- convert it to 'string', 'number' || 'float', 'int' || 'integer', 'boolean'\n *   offset: 'number',\n *   isFahreinheit: 'boolean'\n * }));\n * \n * // [{station: 'A', isFahreinheit: true, offset: 2, temp: 99, type: 'F', descr: '0123456'}];\n * ```\n * \n * @param {Object} collection - the list of objects to update specific properties\n * @param {Object} propertyTranslations - An object with property names as the properties to update <br />\n *      and the values as a function ((any) => any) accepting the current value, returning the new value.\n * @returns {Object[]} - collection of objects transformed\n * @see {@link module:object.augment|augment(collection, fn)} - to add in new properties\n * @see {@link TableGenerator#formatter} - for other examples\n */\nmodule.exports.formatProperties = function formatProperties(collection, propertyTranslations) {\n  const cleanCollection = !collection ? [] : Array.isArray(collection) ? collection : [collection];\n  propertyTranslations = FormatUtils.prepareFormatterObject(propertyTranslations);\n  const translationKeys = Array.from(Object.keys(propertyTranslations));\n  return cleanCollection.map(obj => {\n    const clone = {\n      ...obj\n    };\n    translationKeys.forEach(key => {\n      clone[key] = propertyTranslations[key](clone[key]);\n    });\n    return clone;\n  });\n};\n\n/**\n * returns a map of the types of fields stored\n * @see generateSchema\n * @param {Object | Object[]} list - collection of objects to check\n * @returns {Map<String, Set<String>>} - collection of the types and the fields of those types\n */\nmodule.exports.getObjectPropertyTypes = function getObjectPropertyTypes(list) {\n  const targetList = !list ? [] : Array.isArray(list) ? list : [list];\n  const results = new Map();\n  let type;\n  targetList.forEach(r => {\n    if (r) {\n      Object.keys(r).forEach(key => {\n        type = typeof r[key];\n        if (r[key] === null || r[key] === undefined) {\n          //-- do nothing\n        } else if (!results.has(type)) {\n          results.set(type, new Set([key]));\n        } else {\n          results.get(type).add(key);\n        }\n      });\n    }\n  });\n  return results;\n};\n\n/**\n * Generates a JSON schema for an object\n * @see https://github.com/Nijikokun/generate-schema\n * @param {any} targetObj - object or array of objects\n * @returns {Object} - JSON Schema\n */\nmodule.exports.generateSchema = function generateSchema(targetObj) {\n  return schemaGenerator.json(targetObj);\n};\n\n/**\n * Join values from an objectArray to a JavaScript Map.\n * \n * For example:\n * \n * ```\n * weather = [\n *   { id: 1, city: 'Seattle',  month: 'Aug', precip: 0.87 },\n *   null,\n *   { id: 3, city: 'New York', month: 'Apr', precip: 3.94 },\n *   { id: 6, city: 'Chicago',  month: 'Apr', precip: 3.62 }\n * ];\n * \n * cityLocations = new Map([\n *   ['Chicago', { locationId: 1, city: 'Chicago', lat: 41.8781, lon: 87.6298 }],\n *   ['New York', { locationId: 2, city: 'New York', lat: 40.7128, lon: 74.0060 }],\n *   ['Seattle', { locationId: 3, city: 'Seattle', lat: 47.6062, lon: 122.3321 }]\n * ]);\n * \n * utils.object.join(weather, 'city', cityLocations, (weather, city) => ({...weather, ...city}));\n * // [\n * //    {id:1, city:'Seattle',  month:'Aug', precip:0.87, locationId:3, lat:47.6062, lon:122.3321 },\n * //    null,\n * //    {id:3, city:'New York', month:'Apr', precip:3.94, locationId:2, lat:40.7128, lon:74.006 },\n * //    {id:6, city:'Chicago',  month:'Apr', precip:3.62, locationId:1, lat:41.8781, lon:87.6298 }\n * // ]\n * ```\n * \n * or join by lookup:\n * \n * ```\n * utils.object.join(weather, 'city', cityLocations, (weather, city) => ({...weather, city}));\n * [\n *   { id: 1, city: 'Seattle',  month: 'Aug', precip: 0.87, city:\n *     { city: 'Seattle', locationId: 3, lat: 47.6062, lon: 122.3321 }\n *   },\n *   null,\n *   { id: 3, city: 'New York', month: 'Apr', precip: 3.94, city:\n *     { city: 'New York', locationId: 2, lat: 40.7128, lon: 74.006 }\n *   },\n *   { id: 6, city: 'Chicago',  month: 'Apr', precip: 3.62, city:\n *     { city: 'Chicago', locationId: 1, lat: 41.8781, lon: 87.6298 }\n *   }\n * ];\n * ```\n * \n * or performing a translation / calculate the index instead of a property:\n * \n * ```\n * const indexingFn = (weather) => `${weather.country}_${weather.city}`;\n * utils.object.join(weather, indexingFn, cityLocations, (weather, city) => ({...weather, ...city}));\n * // ...\n * ```\n * \n * The signature for the indexingFunction is `(sourceObj:Object): {any}` - providing the index to use against the map.\n * \n * The signature for the mapping function is `(sourceObj:Object, mappedObject:Object) => {Object}`.\n * \n * If the mappedObject could not be found by that index (left join), then mappedObject will be `null`.\n * \n * As the results of the functions are mapped, you can either modify in-line (directly on the object),\n * or on a clone of the object (ex: {...sourceObj})\n * \n * Note, performing a JavaScript .map() call may be more performant in some cases,\n * so consider it for more complex options.\n * \n * **Note: indexField can be either a string name of the field to join,\n * or a function to be passed the object and generate the index**\n * \n * @param {Array<Object>} objectArray - collection of objects to join based on the target map\n * @param {Function | String} indexField - property on each object in array to lookup against target map <br />\n *      Signature if a function: `(sourceObj:Object): {any}`\n * @param {Map} targetMap - Map with keys mapping to values to pass\n * @param {Function} joinFn - function to call each time an objectArray object, has an indexField found in targetMap <br />\n *      Signature: `(sourceObj:Object, mappedObject:Object) => {Object}`\n * @returns {Array<Object>} - Array of results returned from `joinFn`\n */\nmodule.exports.join = function join(objectArray, indexField, targetMap, joinFn) {\n  const cleanArray = !objectArray ? [] : Array.isArray(objectArray) ? objectArray : [objectArray];\n  const indexFn = ObjectUtils.evaluateFunctionOrProperty(indexField);\n  if (!targetMap) {\n    throw Error('object.join(objectArray, indexField, targetMap, joinFn): targetMap cannot be null');\n  }\n  if (!joinFn || typeof joinFn !== 'function') {\n    throw Error('object.join(objectArray, indexField, targetMap, joinFn): joinFn is required');\n  }\n  const results = cleanArray.map(entry => {\n    if (!entry) return entry;\n    const index = indexFn(entry);\n    const target = targetMap.has(index) ? targetMap.get(index) : null;\n    const result = joinFn(entry, target);\n    return result;\n  });\n  return results;\n};\n\n/**\n * For cases where we simply want to pull values from one object to another.\n * \n * For example:\n * \n * ```\n * weather = [\n *   { id: 1, city: 'Seattle',  month: 'Aug', precip: 0.87 },\n *   null,\n *   { id: 3, city: 'New York', month: 'Apr', precip: 3.94 },\n *   { id: 6, city: 'Chicago',  month: 'Apr', precip: 3.62 }\n * ];\n * \n * cityLocations = new Map([\n *   ['Chicago', { locationId: 1, city: 'Chicago', lat: 41.8781, lon: 87.6298 }],\n *   ['New York', { locationId: 2, city: 'New York', lat: 40.7128, lon: 74.0060 }],\n *   ['Seattle', { locationId: 3, city: 'Seattle', lat: 47.6062, lon: 122.3321 }]\n * ]);\n * \n * utils.object.joinProperties(weather, 'city', cityLocations, 'lat', 'lon'));\n * // [\n * //    {id:1, city:'Seattle',  month:'Aug', precip:0.87, lat:47.6062, lon:122.3321 },\n * //    null,\n * //    {id:3, city:'New York', month:'Apr', precip:3.94, lat:40.7128, lon:74.006 },\n * //    {id:6, city:'Chicago',  month:'Apr', precip:3.62, lat:41.8781, lon:87.6298 }\n * // ]\n * ```\n * \n * @param {Array<Object>} objectArray - collection of objects to join based on the target map\n * @param {Function | String} indexField - property on each object in array to lookup against target map <br />\n *      Signature if a function: `(sourceObj:Object): {any}`\n * @param {Map<any,Object>} targetMap - Map with keys mapping to values to pass\n * @param {...String} fields - List of fields to add to the objectArray in-place against values from targetMap\n * @returns {Array<Object>} - The modified objectArray with the fields applied.\n */\nmodule.exports.joinProperties = function join(objectArray, indexField, targetMap, ...fields) {\n  const cleanFields = fields.filter(f => f);\n  if (cleanFields.length < 1) {\n    throw Error('object.joinProperties(objectArray, indexField, targetMap, ...fields): at least one property passed to join');\n  }\n  const joinFn = (sourceObj, targetObj) => {\n    const cleanTarget = targetObj || {};\n    //-- allow for direct manipulation for speed\n    const result = sourceObj; // { ...sourceObj };\n\n    cleanFields.forEach(field => {\n      result[field] = cleanTarget[field];\n    });\n    return result;\n  };\n  return ObjectUtils.join(objectArray, indexField, targetMap, joinFn);\n};\n\n/**\n * Maps an array of values to a single property.\n * \n * For example:\n * \n * ```\n * const data = [{ record: 'jobA', val: 1 }, { record: 'jobA', val: 2 },\n *  { record: 'jobA', val: 3 }, { record: 'jobA', val: 4 },\n *  { record: 'jobA', val: 5 }, { record: 'jobA', val: 6 },\n *  { record: 'jobA', val: 7 }, { record: 'jobA', val: 8 },\n *  { record: 'jobA', val: 9 }, { record: 'jobA', val: 10 }\n * ];\n * \n * utils.object.propertyFromList(data, 'val')\n * //-- [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n * \n * utils.object.propertyFromList(data, (r) => r.val);\n * //-- [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n * ```\n * \n * @param {Object[]} objectArray - Array of Objects to be mapped to a single property / value\n * @param {Function | String} propertyOrFn - Name of the property or Function to return a value\n * @returns {Array} - Array of values\n */\nmodule.exports.propertyFromList = function propertyFromList(objectArray, propertyOrFn) {\n  const cleanArray = Array.isArray(objectArray) ? objectArray : [];\n  const fn = ObjectUtils.evaluateFunctionOrProperty(propertyOrFn);\n  return cleanArray.map(fn);\n};\n\n/**\n * Finds objects that do not have ALL the properties specified.\n *\n * This can be very helpful in ensuring all objects actually meet a specification and are not missing values.\n * \n * ```\n * const students = [\n *   { first: 'john', last: 'doe', age: 23 }, { first: 'jane', last: 'doe', age: 23 }, { first: 'jack', last: 'white', failure: 401 }\n * ];\n *\n * utils.findWithoutProperties(students, 'first', 'last', 'age');\n * // [{ first: 'jack', last: 'white', failure: 401 }]\n * \n * utils.findWithoutProperties(students, 'failure');\n * // [{ first: 'john', last: 'doe', age: 23 }, { first: 'jane', last: 'doe', age: 23 }] \n * ```\n *\n * Please note, that we can check a single object:\n *\n * ```\n * utils.findWithoutProperties(students[0], 'failure');\n * // []\n * ```\n * \n * @param {Object[]} objectsToCheck - the array of objects to check for the properties.\n * @param {...String} propertiesToFind - the list of properties to find within the collection.\n * @returns {Object[]} - Array of objects that are missing at least one of those properties\n * @see {@link module:file.findWithProperties|findWithProperties} - if you want objects that do not have all properties\n **/\nmodule.exports.findWithoutProperties = function findWithoutProperties(targetObj, ...propertiesToFind) {\n  const cleanProperties = propertiesToFind.length > 0 && Array.isArray(propertiesToFind[0]) ? propertiesToFind[0] : propertiesToFind;\n  const cleanTargets = Array.isArray(targetObj) ? targetObj : [targetObj];\n  const results = [];\n  cleanTargets.forEach(target => {\n    if (cleanProperties.find(prop => typeof target[prop] === 'undefined')) {\n      results.push(target);\n    }\n  });\n  return results;\n};\n\n/**\n * Finds objects that have any of the properties specified.\n * \n * This can be very helpful when working with datasets that include mixed data (such as JSON)\n * \n * ```\n * const students = [\n *   { first: 'john', last: 'doe' }, { first: 'jane', last: 'doe' }, { first: 'jack', last: 'white', failure: 401 }\n * ];\n *\n * utils.findWithProperties(students, 'failure');\n * // { first: 'jack', last: 'white', failure: 401 }\n * ```\n *\n * Please note, that we can check a single object:\n *\n * ```\n * utils.findWithProperties({ first: 'john', last: 'doe' }, 'failure');\n * // []\n * ```\n * \n * @param {Object[]} objectsToCheck - the array of objects to check for the properties.\n * @param {...String} propertiesToFind - the list of properties to find within the collection.\n * @returns {Object[]} - Array of objects that have at least one of those properties\n * @see {@link module:file.findWithoutProperties|findWithoutProperties} - if you want objects that do not have all properties\n **/\nmodule.exports.findWithProperties = function findWithProperties(targetObj, ...propertiesToFind) {\n  const cleanProperties = propertiesToFind.length > 0 && Array.isArray(propertiesToFind[0]) ? propertiesToFind[0] : propertiesToFind;\n  const cleanTargets = Array.isArray(targetObj) ? targetObj : [targetObj];\n  const results = [];\n  cleanTargets.forEach(target => {\n    if (cleanProperties.find(prop => typeof target[prop] !== 'undefined')) {\n      results.push(target);\n    }\n  });\n  return results;\n};\n\n/**\n * Sets values for objects that don't currently have the property\n * \n * This is very helpful for ensuring that all objects have a property,\n * or setting a value to make it easier to identify that it is 'N/A'\n * \n * Note, that only the {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty|ownProperties}\n * on the default object are checked.\n * \n * And values are applied to the target object, only if the property is not on the object (property is undefined)\n * \n * @param {Object[] | Object} targetObject - Object to apply the properties to <br />\n *              but ONLY if the object does not have that property (ex: undefined)\n * @param {Object} defaultObj - Object with the properties and defaults applied\n * @param {any} defaultObj.property - the property to check, with the default value assigned\n * @see {@link module:file.findWithoutProperties|findWithoutProperties} - to determine if any objects do not have a set of properties\n * @see {@link module:file.keys|keys} - to get a list of unique properties of all objects in a list.\n * @example\n * const students = [\n *   { first: 'john', last: 'doe', birthday: '2002-04-01' },\n *   { first: 'jane', last: 'doe', birthday: '2003-05-01' },\n *   { first: 'jack', last: 'white', failure: 401 }\n * ];\n * \n * utils.object.setPropertyDefaults(students, {\n *  first: '',\n *  last: '',\n *  birthday: ''\n * });\n * \n * // [\n * //   { first: 'john', last: 'doe', birthday: '2002-04-01' },\n * //   { first: 'jane', last: 'doe', birthday: '2003-05-01' },\n * //   { first: 'jack', last: 'white', birthday: '', failure: 401 }\n * // ];\n */\nmodule.exports.setPropertyDefaults = function setPropertyDefaults(targetObject, defaultObj) {\n  const cleanTargets = Array.isArray(targetObject) ? targetObject : [targetObject];\n  if (!defaultObj || typeof defaultObj !== 'object') {\n    throw Error('object.setPropertyDefaults(targetObject, defaultObject): defaultObject is expected to be an object with properties set to the defaults to apply');\n  }\n  const defaultKeys = Object.getOwnPropertyNames(defaultObj);\n  cleanTargets.forEach(target => {\n    defaultKeys.forEach(prop => {\n      if (typeof target[prop] === 'undefined') {\n        target[prop] = defaultObj[prop];\n      }\n    });\n  });\n};\n\n/**\n * Applies a function to a set of properties on an object, or collection.\n * \n * This is shorthand for a mapping function,\n * but useful if doing the same operation (like converting to compactNumbers, converting to string, etc)\n * \n * For example, the two are equivalent:\n * \n * ```\n * const list = [\n *  { id: '100', age: '21', name: 'p1' },\n *  { id: '200', age: '22', name: 'p2' },\n *  { id: '300', age: '23', name: 'p3' },\n *  { id: '400', age: '24', name: 'p4' },\n *  { id: '500', age: '25', name: 'p5' }\n * ];\n * \n * const numToString = (val) => String(val);\n * \n * const listMapProperties = utils.object.mapProperties(list, numToString, 'id', 'val');\n * \n * const listMap = list.map((obj) => ({\n *  ...obj,\n *  id: numToString(obj.val),\n *  age: numToString(obj.val)\n * }));\n * ```\n * \n * @param {Object[]} objCollection - object or multiple objects that should have properties formatted\n * @param {Function} formattingFn - function to apply to all the properties specified\n * @param  {...any} propertiesToFormat - list of properties to apply the formatting function\n * @returns {Object[] - clone of objCollection with properties mapped\n */\nmodule.exports.mapProperties = function mapProperties(objCollection, formattingFn, ...propertiesToFormat) {\n  const cleanCollection = !Array.isArray(objCollection) ? [objCollection] : objCollection;\n  const cleanProperties = propertiesToFormat.length === 0 ? ObjectUtils.keys(objCollection) : propertiesToFormat.length > 0 && Array.isArray(propertiesToFormat[0]) ? propertiesToFormat[0] : propertiesToFormat;\n  if (typeof formattingFn !== 'function') {\n    throw Error('object.mapProperties(collection, formattingFn, ...propertiesToFormat): formattingFn must be provided');\n  }\n  return cleanCollection.map(obj => {\n    const clone = {\n      ...obj\n    };\n    cleanProperties.forEach(prop => {\n      clone[prop] = formattingFn(obj[prop]);\n    });\n    return clone;\n  });\n};\n\n/**\n * Finds all the properties for objects in a collection,\n * and provides the first 'non-empty' value found of each property.\n * \n * Non-Empty means:\n * \n * * not null\n * * not undefined\n * * not an empty string\n * * not an empty array\n * \n * This can be especially helpful for heterogeneous collections\n * and can be much faster than something like {@link https://danfo.jsdata.org/api-reference/dataframe/danfo.dataframe.describe|danfojs.describe}\n * \n * @param {Object[]} objCollection - Array of objects that we want to understand\n * @returns {Map<String,any>} - Collection of all properties and the first 'non-empty' value found\n * @example\n * let collection = [\n *  { first: 'jane', age: 23 },\n *  { first: 'john', last: 'doe', age: 21 }\n * ];\n * \n * utils.object.propertyValueSample(collection);\n * // { first: 'jane', last: 'doe', age: 23 }\n */\nmodule.exports.propertyValueSample = function propertyValueSample(objCollection) {\n  if (!objCollection) {\n    throw new Error('propertyValueSample(objectCollection): objectCollection is required');\n  }\n  const collection = Array.isArray(objCollection) ? objCollection : [objCollection];\n  const result = new Map();\n  let entryValue;\n  collection.forEach(entry => {\n    if (entry && typeof entry === 'object') {\n      for (const entryProperty of Object.keys(entry)) {\n        entryValue = entry[entryProperty];\n        if (!FormatUtils.isEmptyValue(entryValue) && !result.has(entryProperty)) {\n          result.set(entryProperty, entryValue);\n        }\n      }\n    }\n  });\n  return result;\n};\n\n/**\n * Appends values to a collection of objects,\n * where if the value `undefined` is provided, \n * then it \"remembers\" or \"inherits\" the value previously used.\n * \n * This is VERY useful for converting a 1 dimensional list, into a hierarchical tree structure.\n * \n * For example, say we got this from a previous successful scrape:\n * \n * ```\n * source = [\n *   { text: '# Overview' },\n *   { text: 'This entire list is a hierarchy of data.' },\n *   { text: '# Section A' },\n *   { text: 'This describes section A' },\n *   { text: '## SubSection 1' },\n *   { text: 'With a subsection belonging to Section A' },\n *   { text: '# Section B' },\n *   { text: 'With an entirely unrelated section B, that is sibling to Section A' }\n * ];\n * ```\n * \n * We would like to know which heading1 and heading2 the texts belong to:\n * \n * ```\n * \n * const isHeader1 = (str) => str.startsWith('# ');\n * const isHeader2 = (str) => str.startsWith('## ');\n * \n * //-- note, return undefined for any property you don't want to have inherited.\n * inheritFn = (entry) => ({\n *   section: isHeader1(entry.text) ? entry.text.replace(/#+\\s+/, '') : undefined,\n *   subSection: isHeader2(entry.text) ? entry.text.replace(/#+\\s+/, '') : undefined\n * });\n * \n * results = utils.object.augmentInherit(source, inheritFn);\n * ```\n * \n * text                                                              |section  |subSection  \n * --                                                                |--       |--          \n * Overview                                                          |Overview |undefined            \n * This entire list is a hierarchy of data.                          |Overview |undefined   \n * Section A                                                         |Section A|undefined   \n * This describes section A                                          |Section A|undefined   \n * SubSection 1                                                      |Section A|SubSection 1\n * With a subsection belonging to Section A                          |Section A|SubSection 1\n * Section B                                                         |Section B|undefined   \n * With an entirely unrelated section B, that is sibling to Section A|Section B|undefined   \n * SubSection 1                                                      |Section B|SubSection 1\n * And another subsection 1, but this time related to Section B.     |Section B|SubSection 1\n * \n * So we pass the collection of results as the source, and an augment function,\n * that returns the heading 1 value - that is then kept until the next heading 1.\n * (Similar for subSection using heading 2)\n * \n * @param {Object[]} source - the collection of objects to check and augment.\n * @param {Function} augmentFn - function accepting each entry, and returning the properties to \"inherit\" <br /> or a property with a value of undefined - if it should not be preserved.\n * @returns {Object[]} - new version of the source objects with the properties applied.\n * @see {@link module:object.propertyInherit|object.propertyInherit} - if you want to use values already on the object\n * @see {@link module:object.augment|augment()} - Applies properties to an object similar to Map\n */\nmodule.exports.augmentInherit = function augmentInherit(source, augmentFn) {\n  const signature = 'augmentInherit(source, augmentFn)';\n  if (!Array.isArray(source)) {\n    throw new Error(`${signature}: source must be an array`);\n  } else if (typeof augmentFn !== 'function') {\n    throw new Error(`${signature}: augmentFn must be a function of signature: (entry, lastValue) => obj`);\n  }\n  let keys;\n  let lastValue = {};\n  return source.map((entry, index) => {\n    const fnResult = augmentFn(entry, lastValue);\n\n    //-- ignore all values that are undefined\n    const newValue = {\n      ...lastValue\n    };\n    let isFlipped = false;\n    keys = Object.keys(fnResult || {});\n    keys.forEach(key => {\n      if (isFlipped) {\n        newValue[key] = undefined;\n      } else if (fnResult[key] !== undefined) {\n        newValue[key] = fnResult[key];\n        isFlipped = true;\n      }\n    });\n\n    // console.log(`index:${index}: entry:${JSON.stringify(entry)}, newValue:${JSON.stringify(newValue)}, lastValue:${JSON.stringify(lastValue)}`)\n    const result = {\n      ...entry,\n      ...newValue\n    };\n    lastValue = newValue;\n    return result;\n  });\n};\n\n/**\n * Copies values from one record to the next\n * or \"inherits\" the value previously used\n * if the current value is undefined.\n * \n * For example:\n * \n * ```\n * source = [\n *  { header: 'Section 1', text: 'A' },\n *  { header: undefined, text: 'B' },\n *  { header: undefined, text: 'C' },\n *  { header: 'Section 2', text: 'D' },\n *  { header: undefined, text: 'E' },\n *  { header: undefined, text: 'F' }\n * ];\n * utils.object.propertyInherit(source, 'header');\n * // [\n * //  { header: 'Section 1', text: 'A' },\n * //  { header: 'Section 1', text: 'B' },\n * //  { header: 'Section 1', text: 'C' },\n * //  { header: 'Section 2', text: 'D' },\n * //  { header: 'Section 2', text: 'E' },\n * //  { header: 'Section 2', text: 'F' }\n * // ];\n * ```\n * \n * @param {Object[]} source - Collection of objects to inherit values\n * @param  {...string} properties - properties that should use the previous value if the current value is undefined\n * @returns {Object[]} - collection of results\n * @see {@link module:object.augmentInherit|object.augmentInherit} - to create new properties to inherit\n */\nmodule.exports.propertyInherit = function propertyInherit(source, ...properties) {\n  const signature = 'propertyInherit(source, ...properties)';\n  if (!Array.isArray(source)) {\n    throw new Error(`${signature}: source must be an array`);\n  }\n  if (properties.length < 1) {\n    return source;\n  }\n  const fn = obj => properties.reduce((result, propertyName) => ObjectUtils.objAssign(result, propertyName, obj[propertyName]), {});\n  return ObjectUtils.augmentInherit(source, fn);\n};\n\n/**\n * Unites the properties of two collections of objects.\n * \n * For example:\n * \n * ```\n * source1 = [\n *  { first: 'john' },\n *  { first: 'jane' }\n * ];\n * source2 = [\n *  { last: 'doe' },\n *  { last: 'dough' }\n * ];\n * utils.object.union(source1, source2);\n * // [{ first: 'john', last: 'doe' },\n * //  { first: 'jane', last: 'dough' }];\n * ```\n * \n * Note that you can also pass a single object, to have it union to multiple.\n * \n * ```\n * source1 = [\n *  { first: 'john' },\n *  { first: 'jane' }\n * ];\n * //-- same object to be applied to all\n * source2 = { last: 'doe' };\n * \n * utils.object.union(source1, source2);\n * // [{ first: 'john', last: 'doe' },\n * //  { first: 'jane', last: 'doe' }];\n * ```\n * \n * @param {Object[]|Object} source1 - object or array of objects to union\n * @param {Object[]|Object} source2 - object or array of objects to union\n * @returns {Object[]} - collection of objects merging the values between the two sources\n * \n * @see {@link module:object.join|join} - to instead join based on a value instead of index\n * @see {@link module:object.filterObjectProperties|filterObjectProperties} - to remove properties from collection of objects.\n */\nmodule.exports.union = function union(source1, source2) {\n  const signature = 'union(source1:object[], source2:object[])';\n  let s1Iterator;\n  let s1Entry;\n  let s1Length;\n  let s2Iterator;\n  let s2Entry;\n  let s2Length;\n  if (Array.isArray(source1)) {\n    s1Iterator = source1.entries();\n    s1Length = source1.length;\n  } else if (typeof source1 === 'object') {\n    s1Iterator = {\n      next: () => ({\n        done: false,\n        value: [0, source1]\n      })\n    };\n    s1Length = 1;\n  } else {\n    throw new Error(`${signature}: source1 must be a collection of objects, or a single object`);\n  }\n  if (Array.isArray(source2)) {\n    s2Iterator = source2.entries();\n    s2Length = source2.length;\n  } else if (typeof source2 === 'object') {\n    s2Iterator = {\n      next: () => ({\n        done: false,\n        value: [0, source2]\n      })\n    };\n    s2Length = 1;\n  } else {\n    throw new Error(`${signature}: source2 must be a collection of objects, or a single object`);\n  }\n  const len = Math.max(s1Length, s2Length);\n  const results = new Array(len);\n  for (let i = 0; i < len; i += 1) {\n    s1Entry = s1Iterator.next();\n    s1Entry = s1Entry.done ? {} : s1Entry.value[1];\n    s2Entry = s2Iterator.next();\n    s2Entry = s2Entry.done ? {} : s2Entry.value[1];\n\n    //console.log(`s1Entry: ${JSON.stringify(s1Entry)}, s2Entry: ${JSON.stringify(s2Entry)}`);\n    results[i] = {\n      ...s1Entry,\n      ...s2Entry\n    };\n  }\n  return results;\n};\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./src/object.js?");

/***/ }),

/***/ "./src/random.js":
/*!***********************!*\
  !*** ./src/random.js ***!
  \***********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("//-- we are not using objects, and avoid constant Garbage Collection - if we allow modification of the numbers.\n/* eslint-disable no-param-reassign */\n\nconst SimplexModule = __webpack_require__(/*! ./random_simplex */ \"./src/random_simplex.js\");\n\n/**\n * Generating and picking random values.\n * \n * * Managing Seed Values\n *     * {@link module:random.seed|seed(number)} - specifies the seed that all following random calls will use\n * * Generating Random Numbers\n *     * {@link module:random.randomInteger|randomInteger(min, max)} - inclusive integer between min and max values\n *     * {@link module:random.random|randomInteger(min, max)} - inclusive float between min and max values\n * * Working with Arrays\n *     * {@link module:random.pickRandom|pickRandom(array)} - picks a value at random from the list\n *     * {@link module:random.randomArray|randomArray(size, fn)} - creates an array of size length, with each value generated from fn\n * * Simplex Noise\n *     * {@link module:random.simplexGenerator|simplexGenerator(seed)} - Number generator between -1 and 1 given an x/y/z coordinate\n * \n * If leveraging \n * \n * While generating a simple number between two values is common, it is very important - and useful in generating fake data.\n * \n * ```\n * const firstNames = ['jane', 'john', 'paul', 'ringo'];\n * const lastNames = ['do', 'doe', 'dough', 'doh'];\n * fakeName = `${utils.random.pickRandom(firstNames)} ${utils.random.pickRandom(lastNames)}`;\n * // 'john dough'\n * ```\n * \n * Additionally, there are so many different ways of generating visualizations\n * based on simplex noise.\n * \n * From straight (red - negative / green - positive)\n * \n * ![Screenshot of animation](img/simplexNoiseAnim.gif)\n * \n * To indicators with length, and rotation (negative ccw / positive cw)\n * \n * ![Screenshot of animation](img/noiseFinal.gif)\n * \n * The possibilities are endless.\n * \n * <hr />\n * \n * <b>This library is meant to provide simple use cases.</b>\n * Please use Standard libraries\n * - like [d3-random](https://observablehq.com/@d3/d3-random) for additional alternatives\n * \n * see {@link module:format.mapArrayDomain|format.mapArrayDomain} - as it projects a value\n * from between a range a value, and picks the corresponding value from an array.\n * \n * For example:\n * \n * ```\n * require('esm-hook');\n * d3 = require('d3');\n * utils = require('jupyter-ijavascript-utils');\n * \n * //-- create a number generator using Normal / Gaussian distribution\n * randomGenerator = d3.randomNormal(\n *  0.5, // mu - or centerline\n *  0.1 // sigma - or spread of values\n * );\n * \n * randomValue = randomGenerator();\n * // randomValue - 0.4\n * \n * randomDataset = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'];\n * \n * numPicks = 3; // increase to a larger number (ex: 1000) to better see distributions\n * \n * //-- create an array of 3 items, each with the results from randomGenerator\n * results = utils.array.size(numPicks, () => randomGenerator());\n * // [ 0.6235937672428706, 0.4991359903898883, 0.4279365561645624 ]\n * \n * //-- map those values to the randomDataset\n * resultPicks = results.map(val => ({ pick: utils.format.mapArrayDomain(val, randomDataset) }));\n * // [ { pick: 'g' }, { pick: 'e' }, { pick: 'e' } ]\n * \n * //-- group them by the pick field\n * //-- then add a new property called count - using the # of records with the same value\n * groupedResults = utils.group.by(resultPicks, 'pick')\n *     .reduce((list) => ({ count: list.length }));\n * // [ { pick: 'g', count: 1 }, { pick: 'e', count: 2 } ]\n * \n * //-- make a bar chart (only with 10k results)\n * utils.vega.embed((vl) => {\n *     return vl\n *       .markBar()\n *       .title('Distribution')\n *       .data(groupedResults)\n *       .encode(\n *         vl.x().fieldN('pick'),\n *         vl.y().fieldQ('count').scale({type: 'log'})\n *       );\n * });\n * ```\n * ![Screenshot of the chart above](img/randomMap_normalDistribution.png)\n * \n * @module random\n */\nconst RandomUtil = module.exports;\nmodule.exports.seedValue = Date.now() % 10000;\n\n/**\n * Specifies a new seed to be used in upcoming random calls.\n * @param {Number} newSeedValue - new seed to use in following random calls\n * @example\n * utils.random.seed(12345);\n * utils.random.randomInteger(); // 55\n */\nmodule.exports.seed = function seed(newSeedValue) {\n  RandomUtil.seedValue = newSeedValue;\n};\n\n/**\n * Used only for testing\n * @private\n */\nmodule.exports.getSeed = function getSeed() {\n  return RandomUtil.seedValue;\n};\n\n/**\n * Generate a random integer (with uniform distribution)\n * @param {Number} [min = 0] - Minimum integer (inclusive) that could be generated\n * @param {Number} [max = 100] - Maximum integer (inclusive) number that could be generated\n * @returns {Number} - number between (and including) min and max\n * @example\n * utils.random.randomInteger(0, 100) // 40\n * utils.random.randomInteger(0, 100) // 96\n * @see [d3-random](https://observablehq.com/@d3/d3-random) for additional alternatives\n */\nmodule.exports.randomInteger = function randomInteger(min = 0, max = 100) {\n  //-- can only occur if the user exports to htmlScript\n  /* istanbul ignore next */\n  const seed = typeof RandomUtil !== 'undefined' ? RandomUtil.seedValue : undefined;\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random(seed) * (max - min + 1) + min); //The maximum is inclusive and the minimum is inclusive\n};\n\n/**\n * Generates a random floating point number (with uniform distribution)\n * @param {Number} [min = 0] - Minimum float (inclusive) that could be generated\n * @param {Number} [max = 100] - Maximum float (inclusive) number that the value will be less than\n * @returns {Number} - number between (and including) min and max\n * utils.random.randomInteger(0, 1) // 0.224223\n * @see [d3-random](https://observablehq.com/@d3/d3-random) for additional alternatives\n */\nmodule.exports.random = function random(min = 0, max = 1) {\n  //-- can only occur if the user exports to htmlScript\n  /* istanbul ignore next */\n  const seed = typeof RandomUtil !== 'undefined' ? RandomUtil.seedValue : undefined;\n  if (min === 0 && max === 1) {\n    return Math.random(seed);\n  }\n  return Math.random(seed) * (max - min) + min;\n};\n\n/**\n * Picks a random value from an array of values (with uniform distribution)\n * @param {Array} targetArray - Array of values to pick from\n * @returns {any} - one of the values picked at random from the target array\n * @example\n * utils.random.pickRandom(['apple', 'orange', 'pear']); // 'pear'\n * @see [d3-random](https://observablehq.com/@d3/d3-random) for additional alternatives\n */\nmodule.exports.pickRandom = function pickRandom(targetArray) {\n  if (!targetArray || !Array.isArray(targetArray)) {\n    throw Error('utils.random.pickRandom(targetArray): targetArray must be an array');\n  }\n\n  //-- can only occur if the user exports to htmlScript\n  /* istanbul ignore next */\n  const seed = typeof RandomUtil !== 'undefined' ? RandomUtil.seedValue : undefined;\n\n  //-- short circuit if array is null\n  if (targetArray.length < 1) {\n    return null;\n  } else if (targetArray.length === 1) {\n    return targetArray[0];\n  }\n\n  //-- do not use RandomUtils to allow it to be exportable to javaScript\n  const min = 0;\n  const max = targetArray.length;\n  return targetArray[Math.floor(Math.random(seed) * (max - min) + min)];\n};\n\n/**\n * Generates an array of random values\n * @param {Number} arraySize - length of the array to return\n * @param {Function} [generatingFunction = null] - function to use to generate or number 0-1\n * @returns {Array} - array of size arraysize\n * @example\n * utils.random.randomArray(4); // [0.23, 0.56, 0.87, 0.77];\n * utils.random.randomArray(4, () => utils.random.randomInteger(1, 100)); // [22, 11, 99, 32]\n */\nmodule.exports.randomArray = function randomArray(arraySize, generatingFunction) {\n  if (arraySize < 0) {\n    throw Error('random.randomArray(size, fn): array size cannot be less than 1');\n  }\n\n  //-- can only occur if the user exports to htmlScript\n  /* istanbul ignore next */\n  const seed = typeof RandomUtil !== 'undefined' ? RandomUtil.seedValue : undefined;\n  const cleanFn = generatingFunction || (() => Math.random(seed));\n  return Array(arraySize).fill(undefined).map((val, index) => cleanFn());\n};\n\n// {[import('./random_simplex')]}\n\n/**\n * Returns a new Simplex Generator\n * @function simplexGenerator\n * @static\n * @param {Number} [seed] - seed to use for the generator (or null for random)\n * @returns {SimplexGenerator} - Simplex Generator that can generate in multiple dimensions\n */\nmodule.exports.simplexGenerator = SimplexModule;\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./src/random.js?");

/***/ }),

/***/ "./src/random_simplex.js":
/*!*******************************!*\
  !*** ./src/random_simplex.js ***!
  \*******************************/
/***/ ((module) => {

eval("/* eslint-disable no-param-reassign, no-bitwise, no-multi-assign, one-var, one-var-declaration-per-line, prefer-const,\n no-lonely-if, computed-property-spacing, brace-style */\n\n/* istanbul ignore file */\n\n//-- source: xixiao - https://github.com/xixixao/noisejs\n//-- brought under a unified function to allow for use in htmlScript\n\n//-- https://raw.githubusercontent.com/xixixao/noisejs/master/index.js\n//  A speed-improved perlin and simplex noise algorithms for 2D.\n// \n//  Based on example code by Stefan Gustavson (stegu@itn.liu.se).\n//  Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).\n//  Better rank ordering method by Stefan Gustavson in 2012.\n//  Converted to Javascript by Joseph Gentle.\n// \n//  Version 2012-03-09\n// \n//  This code was placed in the public domain by its original author,\n//  Stefan Gustavson. You may use it as you see fit, but\n//  attribution is appreciated.\n\n//-- license:\n//-- https://github.com/josephg/noisejs/blob/master/LICENSE\n\n// full code below\n\nfunction generateSimplexInstance(seedValue) {\n  //-- placed within a single function to allow for use in JavaScript\n\n  // Skewing and unskewing factors for 2, 3, and 4 dimensions\n  const F2 = 0.5 * (Math.sqrt(3) - 1);\n  const G2 = (3 - Math.sqrt(3)) / 6;\n  const F3 = 1 / 3;\n  const G3 = 1 / 6;\n\n  /**\n   * Simplex Generator that can generate random numbers\n   * in multiple dimensions with zero \"jutter\" between intervals.\n   * \n   * It works very similar to [Perlin Noise](https://en.wikipedia.org/wiki/Perlin_noise)\n   * but has much less complexity (O(N^2)) and easier to work in higher dimensions.\n   * \n   * For more please see the {@tutorial noiseVisualization} tutorial.\n   * \n   * ---\n   * \n   * Simple example:\n   * \n   * ```\n   * const generator = utils.random.simplexGenerator();\n   * generator.simplex(0.1, 0.2); // (some number between -1 and 1)\n   * ```\n   * \n   * More Complex Example:\n   * \n   * ![screenshot](img/simplexNoiseAnim.gif)\n   * \n   * ```\n   * utils.ijs.htmlScript({\n   *     width: 400,\n   *     height: 400,\n   *     data: { cellSize: 150 },\n   *     utilityFunctions: ({ simplex: utils.random.simplexGenerator }),\n   *     html: '<canvas id=\"draw-target\" />',\n   *     onReady: ({ rootEl, options, utilityFunctions, data }) => {\n   *         const canvas = rootEl.querySelector('canvas#draw-target');\n   *         \n   *         const noise = utilityFunctions.simplex();\n   *         \n   *         canvas.width = parseInt(options.width);\n   *         canvas.height = parseInt(options.height);\n   * \n   *         var ctx = canvas.getContext('2d');\n   * \n   *         var image = ctx.createImageData(canvas.width, canvas.height);\n   *         var imageData = image.data;\n   *         \n   *         function setCanvasColor(index, { red, green, blue, alpha }) {\n   *             imageData[index + 0] = red;\n   *             imageData[index + 1] = green;\n   *             imageData[index + 2] = blue;\n   *             imageData[index + 3] = alpha;\n   *         }\n   * \n   *         for (var x = 0; x < canvas.width; x++) {\n   *           for (var y = 0; y < canvas.height; y++) {\n   *             var value = noise.simplex2d(x / data.cellSize, y / data.cellSize) * 256;\n   *               \n   *             var cell = (x + y * canvas.width) * 4;\n   * \n   *             //-- cells are for each pixel\n   *             //-- and in sets of 4: [red, green, blue, alpha]\n   *             setCanvasColor(\n   *               cell,\n   *               {\n   *                 red: value < 0 ? Math.abs(value) : 0,\n   *                 green: value > 0 ? value : 0,\n   *                 blue: 0,\n   *                 alpha: 255\n   *               }\n   *             );\n   *           }\n   *         }\n   *         \n   *         ctx.fillColor = 'black';\n   *         ctx.fillRect(0, 0, 100, 100);\n   *         ctx.putImageData(image, 0, 0);\n   *     }\n   * });\n   * ```\n   * \n   * @class SimplexGenerator\n   * @param {Number} innerSeed - seed to use from now on\n   * @name SimplexGenerator\n   * @see {@link SimplexGenerator.seed}\n   */\n  function SimplexGenerator(innerSeed) {\n    function Grad(x, y, z) {\n      this.x = x;\n      this.y = y;\n      this.z = z;\n    }\n    Grad.prototype.dot2 = function dot2(x, y) {\n      return this.x * x + this.y * y;\n    };\n    Grad.prototype.dot3 = function dot3(x, y, z) {\n      return this.x * x + this.y * y + this.z * z;\n    };\n    this.grad3 = [new Grad(1, 1, 0), new Grad(-1, 1, 0), new Grad(1, -1, 0), new Grad(-1, -1, 0), new Grad(1, 0, 1), new Grad(-1, 0, 1), new Grad(1, 0, -1), new Grad(-1, 0, -1), new Grad(0, 1, 1), new Grad(0, -1, 1), new Grad(0, 1, -1), new Grad(0, -1, -1)];\n    this.p = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180];\n    // To remove the need for index wrapping, double the permutation table length\n    this.perm = new Array(512);\n    this.gradP = new Array(512);\n    this.seed(innerSeed || 0);\n  }\n\n  // This isn't a very good seeding function, but it works ok. It supports 2^16\n  // different seed values. Write something better if you need more seeds.\n\n  /**\n   * Specifies a new seed to use.\n   * \n   * Note, that this currently supports 2^16 different seed values,\n   * but repeats seeds above and below based on a pattern.\n   * \n   * @param {Number} innerSeed - integer seed to use\n   * @method seed\n   * @instance\n   * @memberof SimplexGenerator\n   * @example\n   * const generator = utils.random.simplexGenerator(2);\n   * generator.seed(4);\n   * //-- will now use that seed from now on.\n   */\n  SimplexGenerator.prototype.seed = function seed(newSeed) {\n    if (newSeed > 0 && newSeed < 1) {\n      // Scale the newSeed out\n      newSeed *= 65536;\n    }\n    newSeed = Math.floor(newSeed);\n    if (newSeed < 256) {\n      newSeed |= newSeed << 8;\n    }\n    for (let i = 0; i < 256; i += 1) {\n      let v;\n      if (i & 1) {\n        v = this.p[i] ^ newSeed & 255;\n      } else {\n        v = this.p[i] ^ newSeed >> 8 & 255;\n      }\n      this.perm[i] = this.perm[i + 256] = v;\n      this.gradP[i] = this.gradP[i + 256] = this.grad3[v % 12];\n    }\n  };\n\n  /**\n   * 2d Simplex Noise value\n   * @param {Number} xin - position along the x axis\n   * @param {Number} yin - position along the y axis\n   * @returns {Number} - [0-1] exclusive \n   * @method simplex2d\n   * @memberof SimplexGenerator\n   * @example\n   * const generator = utils.random.simplexGenerator();\n   */\n  SimplexGenerator.prototype.simplex2d = function simplex2d(xin, yin) {\n    let n0, n1, n2; // Noise contributions from the three corners\n    // Skew the input space to determine which simplex cell we're in\n    let s = (xin + yin) * F2; // Hairy factor for 2D\n    let i = Math.floor(xin + s);\n    let j = Math.floor(yin + s);\n    let t = (i + j) * G2;\n    let x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.\n    let y0 = yin - j + t;\n    // For the 2D case, the simplex shape is an equilateral triangle.\n    // Determine which simplex we are in.\n    let i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n    if (x0 > y0) {\n      // lower triangle, XY order: (0,0) - >(1,0) - >(1,1)\n      i1 = 1;\n      j1 = 0;\n    } else {\n      // upper triangle, YX order: (0,0) - >(0,1) - >(1,1)\n      i1 = 0;\n      j1 = 1;\n    }\n    // A step of (1,0) in (i,j) means a step of (1 - c, - c) in (x,y), and\n    // a step of (0,1) in (i,j) means a step of ( - c,1 - c) in (x,y), where\n    // c = (3 - sqrt(3))/6\n    let x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n    let y1 = y0 - j1 + G2;\n    let x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords\n    let y2 = y0 - 1 + 2 * G2;\n    // Work out the hashed gradient indices of the three simplex corners\n    i &= 255;\n    j &= 255;\n    let gi0 = this.gradP[i + this.perm[j]];\n    let gi1 = this.gradP[i + i1 + this.perm[j + j1]];\n    let gi2 = this.gradP[i + 1 + this.perm[j + 1]];\n    // Calculate the contribution from the three corners\n    let t0 = 0.5 - x0 * x0 - y0 * y0;\n    if (t0 < 0) {\n      n0 = 0;\n    } else {\n      t0 *= t0;\n      n0 = t0 * t0 * gi0.dot2(x0, y0); // (x,y) of grad3 used for 2D gradient\n    }\n    let t1 = 0.5 - x1 * x1 - y1 * y1;\n    if (t1 < 0) {\n      n1 = 0;\n    } else {\n      t1 *= t1;\n      n1 = t1 * t1 * gi1.dot2(x1, y1);\n    }\n    let t2 = 0.5 - x2 * x2 - y2 * y2;\n    if (t2 < 0) {\n      n2 = 0;\n    } else {\n      t2 *= t2;\n      n2 = t2 * t2 * gi2.dot2(x2, y2);\n    }\n    // Add contributions from each corner to get the final noise value.\n    // The result is scaled to return values in the interval [ - 1,1].\n    return 70 * (n0 + n1 + n2);\n  };\n\n  /**\n   * 3d Simplex Noise value\n   * @param {Number} xin - position along the x axis\n   * @param {Number} yin - position along the y axis\n   * @param {Number} zin - position along the z axis\n   * @returns {Number} - [0-1] exclusive \n   * @method simplex3d\n   * @memberof SimplexGenerator\n   */\n  SimplexGenerator.prototype.simplex3d = function simplex3d(xin, yin, zin) {\n    let n0, n1, n2, n3; // Noise contributions from the four corners\n\n    // Skew the input space to determine which simplex cell we're in\n    let s = (xin + yin + zin) * F3; // Hairy factor for 2D\n    let i = Math.floor(xin + s);\n    let j = Math.floor(yin + s);\n    let k = Math.floor(zin + s);\n    let t = (i + j + k) * G3;\n    let x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.\n    let y0 = yin - j + t;\n    let z0 = zin - k + t;\n\n    // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n    // Determine which simplex we are in.\n    let i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\n    let i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\n    if (x0 >= y0) {\n      if (y0 >= z0) {\n        i1 = 1;\n        j1 = 0;\n        k1 = 0;\n        i2 = 1;\n        j2 = 1;\n        k2 = 0;\n      } else if (x0 >= z0) {\n        i1 = 1;\n        j1 = 0;\n        k1 = 0;\n        i2 = 1;\n        j2 = 0;\n        k2 = 1;\n      } else {\n        i1 = 0;\n        j1 = 0;\n        k1 = 1;\n        i2 = 1;\n        j2 = 0;\n        k2 = 1;\n      }\n    } else {\n      if (y0 < z0) {\n        i1 = 0;\n        j1 = 0;\n        k1 = 1;\n        i2 = 0;\n        j2 = 1;\n        k2 = 1;\n      } else if (x0 < z0) {\n        i1 = 0;\n        j1 = 1;\n        k1 = 0;\n        i2 = 0;\n        j2 = 1;\n        k2 = 1;\n      } else {\n        i1 = 0;\n        j1 = 1;\n        k1 = 0;\n        i2 = 1;\n        j2 = 1;\n        k2 = 0;\n      }\n    }\n    // A step of (1,0,0) in (i,j,k) means a step of (1 - c, - c, - c) in (x,y,z),\n    // a step of (0,1,0) in (i,j,k) means a step of ( - c,1 - c, - c) in (x,y,z), and\n    // a step of (0,0,1) in (i,j,k) means a step of ( - c, - c,1 - c) in (x,y,z), where\n    // c = 1/6.\n    let x1 = x0 - i1 + G3; // Offsets for second corner\n    let y1 = y0 - j1 + G3;\n    let z1 = z0 - k1 + G3;\n    let x2 = x0 - i2 + 2 * G3; // Offsets for third corner\n    let y2 = y0 - j2 + 2 * G3;\n    let z2 = z0 - k2 + 2 * G3;\n    let x3 = x0 - 1 + 3 * G3; // Offsets for fourth corner\n    let y3 = y0 - 1 + 3 * G3;\n    let z3 = z0 - 1 + 3 * G3;\n\n    // Work out the hashed gradient indices of the four simplex corners\n    i &= 255;\n    j &= 255;\n    k &= 255;\n    let gi0 = this.gradP[i + this.perm[j + this.perm[k]]];\n    let gi1 = this.gradP[i + i1 + this.perm[j + j1 + this.perm[k + k1]]];\n    let gi2 = this.gradP[i + i2 + this.perm[j + j2 + this.perm[k + k2]]];\n    let gi3 = this.gradP[i + 1 + this.perm[j + 1 + this.perm[k + 1]]];\n\n    // Calculate the contribution from the four corners\n    let t0 = 0.5 - x0 * x0 - y0 * y0 - z0 * z0;\n    if (t0 < 0) {\n      n0 = 0;\n    } else {\n      t0 *= t0;\n      n0 = t0 * t0 * gi0.dot3(x0, y0, z0); // (x,y) of grad3 used for 2D gradient\n    }\n    let t1 = 0.5 - x1 * x1 - y1 * y1 - z1 * z1;\n    if (t1 < 0) {\n      n1 = 0;\n    } else {\n      t1 *= t1;\n      n1 = t1 * t1 * gi1.dot3(x1, y1, z1);\n    }\n    let t2 = 0.5 - x2 * x2 - y2 * y2 - z2 * z2;\n    if (t2 < 0) {\n      n2 = 0;\n    } else {\n      t2 *= t2;\n      n2 = t2 * t2 * gi2.dot3(x2, y2, z2);\n    }\n    let t3 = 0.5 - x3 * x3 - y3 * y3 - z3 * z3;\n    if (t3 < 0) {\n      n3 = 0;\n    } else {\n      t3 *= t3;\n      n3 = t3 * t3 * gi3.dot3(x3, y3, z3);\n    }\n    // Add contributions from each corner to get the final noise value.\n    // The result is scaled to return values in the interval [ - 1,1].\n    return 32 * (n0 + n1 + n2 + n3);\n  };\n  return new SimplexGenerator(seedValue);\n}\nmodule.exports = generateSimplexInstance;\n\n/*\n//-- https://raw.githubusercontent.com/xixixao/noisejs/master/index.js\n//  A speed-improved perlin and simplex noise algorithms for 2D.\n// \n//  Based on example code by Stefan Gustavson (stegu@itn.liu.se).\n//  Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).\n//  Better rank ordering method by Stefan Gustavson in 2012.\n//  Converted to Javascript by Joseph Gentle.\n// \n//  Version 2012-03-09\n// \n//  This code was placed in the public domain by its original author,\n//  Stefan Gustavson. You may use it as you see fit, but\n//  attribution is appreciated.\n\n//-- license:\n//-- https://github.com/josephg/noisejs/blob/master/LICENSE\n\n(function(global){\n\n  // Passing in seed will seed this Noise instance\n  function Noise(seed) {\n    function Grad(x, y, z) {\n      this.x = x; this.y = y; this.z = z;\n    }\n\n    Grad.prototype.dot2 = function(x, y) {\n      return this.x*x + this.y*y;\n    };\n\n    Grad.prototype.dot3 = function(x, y, z) {\n      return this.x*x + this.y*y + this.z*z;\n    };\n\n    this.grad3 = [new Grad(1,1,0),new Grad(-1,1,0),new Grad(1,-1,0),new Grad(-1,-1,0),\n                 new Grad(1,0,1),new Grad(-1,0,1),new Grad(1,0,-1),new Grad(-1,0,-1),\n                 new Grad(0,1,1),new Grad(0,-1,1),new Grad(0,1,-1),new Grad(0,-1,-1)];\n\n    this.p = [151,160,137,91,90,15,\n    131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n    190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n    88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n    77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n    102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n    135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n    5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n    223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n    129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n    251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n    49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];\n    // To remove the need for index wrapping, double the permutation table length\n    this.perm = new Array(512);\n    this.gradP = new Array(512);\n\n    this.seed(seed || 0);\n  }\n\n  // This isn't a very good seeding function, but it works ok. It supports 2^16\n  // different seed values. Write something better if you need more seeds.\n  Noise.prototype.seed = function(seed) {\n    if(seed > 0 && seed < 1) {\n      // Scale the seed out\n      seed *= 65536;\n    }\n\n    seed = Math.floor(seed);\n    if(seed < 256) {\n      seed |= seed << 8;\n    }\n\n    var p = this.p;\n    for(var i = 0; i < 256; i++) {\n      var v;\n      if (i & 1) {\n        v = p[i] ^ (seed & 255);\n      } else {\n        v = p[i] ^ ((seed>>8) & 255);\n      }\n\n      var perm = this.perm;\n      var gradP = this.gradP;\n      perm[i] = perm[i + 256] = v;\n      gradP[i] = gradP[i + 256] = this.grad3[v % 12];\n    }\n  };\n\n  // for(var i=0; i<256; i++) {\n  //   perm[i] = perm[i + 256] = p[i];\n  //   gradP[i] = gradP[i + 256] = grad3[perm[i] % 12];\n  // }\n\n  // Skewing and unskewing factors for 2, 3, and 4 dimensions\n  var F2 = 0.5*(Math.sqrt(3)-1);\n  var G2 = (3-Math.sqrt(3))/6;\n\n  var F3 = 1/3;\n  var G3 = 1/6;\n\n  // 2D simplex noise\n  Noise.prototype.simplex2 = function(xin, yin) {\n    var n0, n1, n2; // Noise contributions from the three corners\n    // Skew the input space to determine which simplex cell we're in\n    var s = (xin+yin)*F2; // Hairy factor for 2D\n    var i = Math.floor(xin+s);\n    var j = Math.floor(yin+s);\n    var t = (i+j)*G2;\n    var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.\n    var y0 = yin-j+t;\n    // For the 2D case, the simplex shape is an equilateral triangle.\n    // Determine which simplex we are in.\n    var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n    if(x0>y0) { // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n      i1=1; j1=0;\n    } else {    // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n      i1=0; j1=1;\n    }\n    // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n    // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n    // c = (3-sqrt(3))/6\n    var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n    var y1 = y0 - j1 + G2;\n    var x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords\n    var y2 = y0 - 1 + 2 * G2;\n    // Work out the hashed gradient indices of the three simplex corners\n    i &= 255;\n    j &= 255;\n\n    var perm = this.perm;\n    var gradP = this.gradP;\n    var gi0 = gradP[i+perm[j]];\n    var gi1 = gradP[i+i1+perm[j+j1]];\n    var gi2 = gradP[i+1+perm[j+1]];\n    // Calculate the contribution from the three corners\n    var t0 = 0.5 - x0*x0-y0*y0;\n    if(t0<0) {\n      n0 = 0;\n    } else {\n      t0 *= t0;\n      n0 = t0 * t0 * gi0.dot2(x0, y0);  // (x,y) of grad3 used for 2D gradient\n    }\n    var t1 = 0.5 - x1*x1-y1*y1;\n    if(t1<0) {\n      n1 = 0;\n    } else {\n      t1 *= t1;\n      n1 = t1 * t1 * gi1.dot2(x1, y1);\n    }\n    var t2 = 0.5 - x2*x2-y2*y2;\n    if(t2<0) {\n      n2 = 0;\n    } else {\n      t2 *= t2;\n      n2 = t2 * t2 * gi2.dot2(x2, y2);\n    }\n    // Add contributions from each corner to get the final noise value.\n    // The result is scaled to return values in the interval [-1,1].\n    return 70 * (n0 + n1 + n2);\n  };\n\n  // 3D simplex noise\n  Noise.prototype.simplex3 = function(xin, yin, zin) {\n    var n0, n1, n2, n3; // Noise contributions from the four corners\n\n    // Skew the input space to determine which simplex cell we're in\n    var s = (xin+yin+zin)*F3; // Hairy factor for 2D\n    var i = Math.floor(xin+s);\n    var j = Math.floor(yin+s);\n    var k = Math.floor(zin+s);\n\n    var t = (i+j+k)*G3;\n    var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.\n    var y0 = yin-j+t;\n    var z0 = zin-k+t;\n\n    // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n    // Determine which simplex we are in.\n    var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\n    var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\n    if(x0 >= y0) {\n      if(y0 >= z0)      { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }\n      else if(x0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }\n      else              { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }\n    } else {\n      if(y0 < z0)      { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }\n      else if(x0 < z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }\n      else             { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }\n    }\n    // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n    // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n    // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n    // c = 1/6.\n    var x1 = x0 - i1 + G3; // Offsets for second corner\n    var y1 = y0 - j1 + G3;\n    var z1 = z0 - k1 + G3;\n\n    var x2 = x0 - i2 + 2 * G3; // Offsets for third corner\n    var y2 = y0 - j2 + 2 * G3;\n    var z2 = z0 - k2 + 2 * G3;\n\n    var x3 = x0 - 1 + 3 * G3; // Offsets for fourth corner\n    var y3 = y0 - 1 + 3 * G3;\n    var z3 = z0 - 1 + 3 * G3;\n\n    // Work out the hashed gradient indices of the four simplex corners\n    i &= 255;\n    j &= 255;\n    k &= 255;\n\n    var perm = this.perm;\n    var gradP = this.gradP;\n    var gi0 = gradP[i+   perm[j+   perm[k   ]]];\n    var gi1 = gradP[i+i1+perm[j+j1+perm[k+k1]]];\n    var gi2 = gradP[i+i2+perm[j+j2+perm[k+k2]]];\n    var gi3 = gradP[i+ 1+perm[j+ 1+perm[k+ 1]]];\n\n    // Calculate the contribution from the four corners\n    var t0 = 0.5 - x0*x0-y0*y0-z0*z0;\n    if(t0<0) {\n      n0 = 0;\n    } else {\n      t0 *= t0;\n      n0 = t0 * t0 * gi0.dot3(x0, y0, z0);  // (x,y) of grad3 used for 2D gradient\n    }\n    var t1 = 0.5 - x1*x1-y1*y1-z1*z1;\n    if(t1<0) {\n      n1 = 0;\n    } else {\n      t1 *= t1;\n      n1 = t1 * t1 * gi1.dot3(x1, y1, z1);\n    }\n    var t2 = 0.5 - x2*x2-y2*y2-z2*z2;\n    if(t2<0) {\n      n2 = 0;\n    } else {\n      t2 *= t2;\n      n2 = t2 * t2 * gi2.dot3(x2, y2, z2);\n    }\n    var t3 = 0.5 - x3*x3-y3*y3-z3*z3;\n    if(t3<0) {\n      n3 = 0;\n    } else {\n      t3 *= t3;\n      n3 = t3 * t3 * gi3.dot3(x3, y3, z3);\n    }\n    // Add contributions from each corner to get the final noise value.\n    // The result is scaled to return values in the interval [-1,1].\n    return 32 * (n0 + n1 + n2 + n3);\n\n  };\n\n  // ##### Perlin noise stuff\n\n  function fade(t) {\n    return t*t*t*(t*(t*6-15)+10);\n  }\n\n  function lerp(a, b, t) {\n    return (1-t)*a + t*b;\n  }\n\n  // 2D Perlin Noise\n  Noise.prototype.perlin2 = function(x, y) {\n    // Find unit grid cell containing point\n    var X = Math.floor(x), Y = Math.floor(y);\n    // Get relative xy coordinates of point within that cell\n    x = x - X; y = y - Y;\n    // Wrap the integer cells at 255 (smaller integer period can be introduced here)\n    X = X & 255; Y = Y & 255;\n\n    // Calculate noise contributions from each of the four corners\n    var perm = this.perm;\n    var gradP = this.gradP;\n    var n00 = gradP[X+perm[Y]].dot2(x, y);\n    var n01 = gradP[X+perm[Y+1]].dot2(x, y-1);\n    var n10 = gradP[X+1+perm[Y]].dot2(x-1, y);\n    var n11 = gradP[X+1+perm[Y+1]].dot2(x-1, y-1);\n\n    // Compute the fade curve value for x\n    var u = fade(x);\n\n    // Interpolate the four results\n    return lerp(\n        lerp(n00, n10, u),\n        lerp(n01, n11, u),\n       fade(y));\n  };\n\n  // 3D Perlin Noise\n  Noise.prototype.perlin3 = function(x, y, z) {\n    // Find unit grid cell containing point\n    var X = Math.floor(x), Y = Math.floor(y), Z = Math.floor(z);\n    // Get relative xyz coordinates of point within that cell\n    x = x - X; y = y - Y; z = z - Z;\n    // Wrap the integer cells at 255 (smaller integer period can be introduced here)\n    X = X & 255; Y = Y & 255; Z = Z & 255;\n\n    // Calculate noise contributions from each of the eight corners\n    var perm = this.perm;\n    var gradP = this.gradP;\n    var n000 = gradP[X+  perm[Y+  perm[Z  ]]].dot3(x,   y,     z);\n    var n001 = gradP[X+  perm[Y+  perm[Z+1]]].dot3(x,   y,   z-1);\n    var n010 = gradP[X+  perm[Y+1+perm[Z  ]]].dot3(x,   y-1,   z);\n    var n011 = gradP[X+  perm[Y+1+perm[Z+1]]].dot3(x,   y-1, z-1);\n    var n100 = gradP[X+1+perm[Y+  perm[Z  ]]].dot3(x-1,   y,   z);\n    var n101 = gradP[X+1+perm[Y+  perm[Z+1]]].dot3(x-1,   y, z-1);\n    var n110 = gradP[X+1+perm[Y+1+perm[Z  ]]].dot3(x-1, y-1,   z);\n    var n111 = gradP[X+1+perm[Y+1+perm[Z+1]]].dot3(x-1, y-1, z-1);\n\n    // Compute the fade curve value for x, y, z\n    var u = fade(x);\n    var v = fade(y);\n    var w = fade(z);\n\n    // Interpolate\n    return lerp(\n        lerp(\n          lerp(n000, n100, u),\n          lerp(n001, n101, u), w),\n        lerp(\n          lerp(n010, n110, u),\n          lerp(n011, n111, u), w),\n       v);\n  };\n\n  if (typeof module === \"object\" && module && typeof module.exports === \"object\") {\n    module.exports = Noise;\n  } else if (typeof define === \"function\" && define.amd) {\n    define([], function () { return Noise; } );\n  } else {\n    global.Noise = Noise;\n  }\n\n})(this);\n*/\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./src/random_simplex.js?");

/***/ }),

/***/ "./src/set.js":
/*!********************!*\
  !*** ./src/set.js ***!
  \********************/
/***/ ((module) => {

eval("/**\n * Utilities / Functional methods for manipulating JavaScript sets.\n * \n * * Add Values \n *   * {@link module:set.add|add(set?, value, ...)} - add specific values to a set\n *   * {@link module:set.union|union(set, list|set|iterable)} - combine two arrays\n * * common values\n *   * {@link module:set.intersection|intersection(set, list|set|iterable)} - items in both of the lists\n * * Remove values\n *   * {@link module:set.remove|remove(set, value, ...)} - remove specific values from set and return set\n *   * {@link module:set.difference|difference(set, list|set|iteratable)} - remove set values from another  \n * * unique\n *   * new Set([ ...utils.difference(setA, setB), ...utils.difference(setB, setA)])\n * \n * Note that the EcmaScript is catching up and union, difference, etc. will be supported soon.\n * \n * However, this library removes a value and returns the set - which can be very helpful for functional programming.\n * \n * @module set\n * @exports set\n */\nmodule.exports = {};\n\n// eslint-disable-next-line no-unused-vars\nconst SetUtils = module.exports;\n\n/**\n * Mutably adds a value to a set, and then returns the set. (Allowing Chaining)\n * \n * (If you wish to immutably, use ES6: `{...setA, value1, value2, ...setB, etc...}`<br />\n * or use the {@link module:set.union|union(set, list|set|iterable)} command below)\n * \n * @param {set} setTarget - set to add values to\n * @param {any} val - value to add to the set\n * @returns {set} setTarget\n * @see {@link module:set.union|union(set, list|set|iterable)}\n * @example\n * setA = new Set([1, 2, 3]);\n * utils.array.add(setA, 4, 5, 6); // Set([1, 2, 3, 4, 5, 6])\n */\nmodule.exports.add = function add(setTarget, ...rest) {\n  const target = SetUtils.union(setTarget, rest);\n  return target;\n};\n\n/**\n * Mutably Adds all the values from a target into a set. (Allowing Chaining)\n * \n * (If you wish to union immutably, use ES6: `{...setA, ...setB}`)\n * \n * **Note**: this works with Arrays and other things iteratable\n *\n * @param {set} setTarget - set to add values to\n * @param {iteratable} iteratable - iteratable that can be unioned into the set.\n * @param {...iteratable} rest - additional iteratables to add to the union\n * @returns {set} new set that contains values from all sources\n * @example\n * \n * setA = new Set([1, 2, 3]);\n * setB = new Set([4, 5, 6];\n * array.union(setA, setB) // Set([1, 2, 3, 4, 5, 6])\n * \n * setA = new Set([1, 2, 3]);\n * listB = [4, 5, 6];\n * array.union(setA, listB) // Set([1, 2, 3, 4, 5, 6])\n * \n * setC = new Set([7, 8, 9]);\n * array.union(setA, listB, setC);\n * // Set(1, 2, 3, 4, 5, 6, 7, 8, 9);\n * \n */\nmodule.exports.union = function union(setTarget, iteratable, ...rest) {\n  const target = setTarget instanceof Set ? setTarget : new Set(setTarget);\n  if (iteratable) {\n    // eslint-disable-next-line\n    for (let v of iteratable) {\n      target.add(v);\n    }\n  }\n  if (rest.length > 0) return SetUtils.union.apply(this, [target, ...rest]);\n  return target;\n};\n\n/**\n * Immutably identify all items that are common in two sets of iterable items\n * \n * **Note**: this works with Arrays and other things iteratable\n * \n * @param {Set} sourceA - the set to check for common items\n * @param {Set} sourceB - another set to check for common items\n * @param {...iteratable} rest - additional iteratables to verify\n * @returns {Set} - set of items that are in all sources\n * @example\n * setA = new Set([1, 2, 3, 4]);\n * setB = new Set([3, 4, 5, 6]);\n * utils.set.intersection(setA, setB); // Set([3, 4])\n * \n * // Note that you can use other iteratable things too\n * utils.set.intersection([1, 2, 3, 4], [3, 4, 5, 6]); // Set([3, 4])\n * \n * setC = new Set([3, 4, 9, 10]);\n * utils.set.intersection(setA, setB, setC); // Set([3, 4]);\n */\nmodule.exports.intersection = function intersection(sourceA, sourceB, ...rest) {\n  const targetA = sourceA instanceof Set ? sourceA : new Set(sourceA);\n  const results = new Set([...sourceB].filter(val => targetA.has(val)));\n  if (rest.length > 0) return SetUtils.intersection.apply(this, [results, ...rest]);\n  return results;\n};\n\n/**\n * Mutably removes a value to a set, and then returns the set. (Allowing for chaining)\n * \n * @param {set} setTarget - set to remove values from\n * @param {any} val - value to remove from the set\n * @returns {set} setTarget\n * @example\n * setA = new Set([1, 2, 3, 4, 5])\n * utils.set.remove(setA, 4, 5); // Set([1, 2, 3])\n */\nmodule.exports.remove = function remove(setTarget, ...rest) {\n  const target = SetUtils.difference(setTarget, rest);\n  return target;\n};\n\n/**\n * Mutably removes all the values from one set in another\n * \n * @param {set} setTarget - set to remove values from\n * @param {iteratable} iteratable - iteratable that can be removed from the set.\n * @returns {set} setTarget\n * @example\n * setA = new Set([1, 2, 3, 4, 5, 6])\n * setB = new Set([4, 5, 6])\n * utils.set.difference(setA, setB) // Set([1, 2, 3])\n */\nmodule.exports.difference = function difference(setTarget, iteratable) {\n  const target = setTarget instanceof Set ? setTarget : new Set(setTarget);\n  if (iteratable) {\n    // eslint-disable-next-line\n    for (let v of iteratable) {\n      target.delete(v);\n    }\n  }\n  return target;\n};\n\n/**\n * Immutably verifies the superset contains all items in iteratable,\n * and returns the set of items not found in the superset.\n * \n * @param {set} superSet - set to check it contains all iteratable items\n * @param {iteratable} iteratableWithAllValues - iteratable with all items\n * @returns {Set} - set with items not in setToCheck (or an empty set if all contained)\n * @example\n * \n * const possibeSuperSet = new Set([1,2,3,4,5,6]);\n * const subset = new Set([4,5,6,7]);\n * set.findItemsNotContained(possibleSuperSet, subset); // Set([7]);\n */\nmodule.exports.findItemsNotContained = function findItemsNotContained(superSet, iteratable) {\n  const target = superSet instanceof Set ? superSet : new Set(superSet);\n  const result = new Set();\n  if (iteratable) {\n    for (const v of iteratable) {\n      if (!target.has(v)) {\n        result.add(v);\n      }\n    }\n  }\n  return result;\n};\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./src/set.js?");

/***/ }),

/***/ "./src/webpack.js":
/*!************************!*\
  !*** ./src/webpack.js ***!
  \************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("const aggregate = __webpack_require__(/*! ./aggregate */ \"./src/aggregate.js\");\nconst array = __webpack_require__(/*! ./array */ \"./src/array.js\");\nconst base64 = __webpack_require__(/*! ./base64 */ \"./src/base64.js\");\nconst chain = __webpack_require__(/*! ./chain */ \"./src/chain.js\");\nconst datasets = __webpack_require__(/*! ./datasets */ \"./src/datasets.js\");\nconst describe = __webpack_require__(/*! ./describe */ \"./src/describe.js\");\nconst group = __webpack_require__(/*! ./group */ \"./src/group.js\");\nconst hashMap = __webpack_require__(/*! ./hashMap */ \"./src/hashMap.js\");\nconst ijsUtils = __webpack_require__(/*! ./ijs */ \"./src/ijs.js\");\nconst format = __webpack_require__(/*! ./format */ \"./src/format.js\");\nconst set = __webpack_require__(/*! ./set */ \"./src/set.js\");\nconst object = __webpack_require__(/*! ./object */ \"./src/object.js\");\nconst random = __webpack_require__(/*! ./random */ \"./src/random.js\");\nconst SourceMap = __webpack_require__(/*! ./SourceMap */ \"./src/SourceMap.js\");\nconst TableGenerator = __webpack_require__(/*! ./TableGenerator */ \"./src/TableGenerator.js\");\nconst table = function table(...rest) {\n  return new TableGenerator(...rest);\n};\n\n/**\n * Default module\n * @module index\n * @exports index\n * @private\n */\nconst mainResults = {\n  /** @see {@link module:aggregate} */\n  aggregate,\n  agg: aggregate,\n  /** @see {@link module:array} */\n  array,\n  /** @see {@link module:base64} */\n  base64,\n  /** @see {@link module:chain} */\n  chain,\n  /** @see {@link module:datasets} */\n  datasets,\n  dataset: datasets,\n  /** @see {@link module:describe} */\n  describe,\n  /** @see {@link module:group} */\n  group,\n  /** @see {@link module:hashMap} */\n  hashMap,\n  /** @see {@link module:format} */\n  format,\n  /** @see {@link module:object} */\n  object,\n  /** @see {@link module:random} */\n  random,\n  /** @see {@link module:set} */\n  set,\n  /** @see SourceMap */\n  SourceMap,\n  /** @see TableGenerator */\n  TableGenerator,\n  /** @see TableGenerator */\n  table\n};\nglobalThis.ijsUtils = mainResults;\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./src/webpack.js?");

/***/ }),

/***/ "./node_modules/generate-schema/src/index.js":
/*!***************************************************!*\
  !*** ./node_modules/generate-schema/src/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("exports.generic = __webpack_require__(/*! ./schemas/generic */ \"./node_modules/generate-schema/src/schemas/generic.js\")\nexports.mongoose = __webpack_require__(/*! ./schemas/mongoose */ \"./node_modules/generate-schema/src/schemas/mongoose.js\")\nexports.bigquery = __webpack_require__(/*! ./schemas/bigquery */ \"./node_modules/generate-schema/src/schemas/bigquery.js\")\nexports.mysql = __webpack_require__(/*! ./schemas/mysql */ \"./node_modules/generate-schema/src/schemas/mysql.js\")\nexports.json = __webpack_require__(/*! ./schemas/json */ \"./node_modules/generate-schema/src/schemas/json.js\")\nexports.clickhouse = __webpack_require__(/*! ./schemas/clickhouse */ \"./node_modules/generate-schema/src/schemas/clickhouse.js\")\n\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./node_modules/generate-schema/src/index.js?");

/***/ }),

/***/ "./node_modules/generate-schema/src/schemas/bigquery.js":
/*!**************************************************************!*\
  !*** ./node_modules/generate-schema/src/schemas/bigquery.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var utils = __webpack_require__(/*! ../utils */ \"./node_modules/generate-schema/src/utils.js\")\n\nfunction getPropertyMode (value) {\n  return Array.isArray(value) ? 'REPEATED' : 'NULLABLE'\n}\n\nfunction getPropertyType (value) {\n  if (Array.isArray(value)) {\n    return getPropertyType(value[0])\n  }\n\n  if (value instanceof Date) return 'TIMESTAMP'\n  if (typeof value === 'object') return 'RECORD'\n  if (typeof value === 'boolean') return 'BOOLEAN'\n  if (typeof value === 'string') {\n    if (utils.isDateString(value)) return 'DATE'\n    if (utils.isTimestamp(value)) return 'TIMESTAMP'\n  }\n\n  if (!isNaN(value)) {\n    return Number.isInteger(parseFloat(value)) ? 'INTEGER' : 'FLOAT'\n  }\n\n  return 'STRING'\n}\n\nfunction processFields (data) {\n  return Object.keys(data).map(function (key) {\n    var value = data[key]\n    var entry = {\n      name: key,\n      type: getPropertyType(data[key]),\n      mode: getPropertyMode(data[key])\n    }\n\n    if (entry.type === 'RECORD') {\n      entry.fields = processFields((entry.mode === 'REPEATED') ? value[0] : value)\n    }\n\n    return entry\n  })\n}\n\nmodule.exports = function Process (data) {\n  return processFields(data)\n}\n\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./node_modules/generate-schema/src/schemas/bigquery.js?");

/***/ }),

/***/ "./node_modules/generate-schema/src/schemas/clickhouse.js":
/*!****************************************************************!*\
  !*** ./node_modules/generate-schema/src/schemas/clickhouse.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Modules\nvar Type = __webpack_require__(/*! type-of-is */ \"./node_modules/type-of-is/index.js\")\nvar Utils = __webpack_require__(/*! ../utils */ \"./node_modules/generate-schema/src/utils.js\")\n\n// Type Mapping for Clickhouse\nvar types = {\n  boolean: 'String',\n  string: 'String',\n  number: 'Int32',\n  date: 'Date',\n  timestamp: 'DateTime',\n  object: 'Nested',\n  'regexp': 'String',\n  'undefined': 'String',\n  'null': 'String'\n}\n\nvar lang = {\n  create: function (name) {\n    return ['CREATE TABLE ', name, ' ('].join('')\n  },\n\n  close: function (id, dateField) {\n    if (!dateField) return [') ENGINE = Memory;'].join('')\n    else return [') ENGINE = MergeTree(', dateField, ', (', id, ', ', dateField, '), 8192);'].join('')\n  },\n\n  id: function (name, value) {\n    return ['  ', name, '_id ', value, ','].join('')\n  },\n\n  property: function (name, value) {\n    return ['  ', name, ' ', value, ','].join('')\n  },\n\n}\n\nfunction processObject (obj, options, dateField) {\n  var name = options.tableName\n  var parent = options.parentTableName\n  var parentId = options.parentTableId\n  var parentIdType = options.parentTableIdType\n\n  // In-memory storage\n  var keys = Object.keys(obj)\n  var output = []\n  var tables = []\n\n  // Table variables\n  var id = null\n  var idType = 'string'\n\n  // Initialize Table\n  output.push(lang.create(name))\n\n  if (parent) {\n    output.push(lang.property(parent + '_' + parentId, types[parentIdType]))\n  }\n\n  // Obtain ID\n  var nkey\n  for (var i = 0; i < keys.length; i++) {\n    if (keys[i].toLowerCase() === 'id' || keys[i].toLowerCase().indexOf('_id') > -1) {\n      nkey = keys[i]\n      obj[nkey] = obj[keys[i]]\n      keys[i] = nkey\n      id = keys[i]\n      idType = typeof obj[keys[i]]\n    }\n  }\n\n  if (!id) {\n    id = 'id'\n    idType = parentIdType || idType\n    output.push(lang.property(id, types[idType]))\n  }\n\n  // Create table properties\n  var key, value, type\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i]\n    value = obj[key]\n    type = value instanceof Date\n      ? 'date'\n      : Type.string(value).toLowerCase()\n\n    if (type == 'date' && !dateField) {\n\tvar dateField = key;\n    }\n\n    if (type !== 'undefined') {\n      type = Utils.isTimestamp(value) ? 'timestamp' : type\n    }\n\n    if (type === 'function') {\n      continue\n    }\n\n    // pojo\n    if (type === 'object' && !value.length) {\n      tables.push('')\n      tables.push(processObject(value, {\n        parentTableName: name,\n        parentTableId: id,\n        parentTableIdType: idType,\n        tableName: name + '_' + key\n      }).join(''))\n      continue\n    }\n\n    // array\n    if (type === 'object' || type === 'array') {\n      if (typeof value[0] === 'object') {\n        tables.push('')\n        tables.push(processObject(value[0], {\n          parentTableName: name,\n          parentTableId: id,\n          parentTableIdType: idType,\n          tableName: name + '_' + key\n        }).join(''))\n        continue\n      }\n\n      tables.push('')\n      tables.push(processObject({\n        value: typeof value[0]\n      }, {\n        parentTableName: name,\n        parentTableId: id,\n        parentTableIdType: idType,\n        tableName: name + '_' + key\n      }).join(''))\n\n      continue\n    }\n\n    output.push(lang.property(key, types[type]))\n  }\n\n  output[output.length - 1] = Utils.arrayLastItem(output)\n    .substr(0, Utils.arrayLastItem(output).length - 1)\n\n  output.push(lang.close(id, dateField))\n\n  return output.concat(tables)\n}\n\nmodule.exports = function Process (tableName, object, dateField) {\n  if (typeof tableName !== 'string') {\n    object = tableName\n    tableName = 'generic'\n  }\n  if (!dateField)\n    dateField = null\n\n  return processObject(object, {\n    tableName: tableName\n  }, dateField).join('')\n}\n\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./node_modules/generate-schema/src/schemas/clickhouse.js?");

/***/ }),

/***/ "./node_modules/generate-schema/src/schemas/generic.js":
/*!*************************************************************!*\
  !*** ./node_modules/generate-schema/src/schemas/generic.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Modules\nvar Type = __webpack_require__(/*! type-of-is */ \"./node_modules/type-of-is/index.js\")\nvar Utils = __webpack_require__(/*! ../utils */ \"./node_modules/generate-schema/src/utils.js\")\n\nmodule.exports = function Process (object, output) {\n  output = output || {}\n\n  for (var key in object) {\n    var value = object[key]\n    var type = Type.string(value).toLowerCase()\n\n    if (type === 'undefined') {\n      type = 'null'\n    }\n\n    if (type === 'string' && Utils.isDate(value)) {\n      type = 'date'\n    }\n\n    if (type !== 'object') {\n      output[key] = {\n        type: type\n      }\n    } else {\n      output[key] = Process(object[key])\n      output[key].type = type\n    }\n  }\n\n  return output\n}\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./node_modules/generate-schema/src/schemas/generic.js?");

/***/ }),

/***/ "./node_modules/generate-schema/src/schemas/json.js":
/*!**********************************************************!*\
  !*** ./node_modules/generate-schema/src/schemas/json.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Modules\nvar Type = __webpack_require__(/*! type-of-is */ \"./node_modules/type-of-is/index.js\")\n\n// Constants\nvar DRAFT = 'http://json-schema.org/draft-04/schema#'\n\nfunction getPropertyFormat(value) {\n  var type = Type.string(value).toLowerCase()\n\n  if (type === 'date') return 'date-time'\n\n  return null\n}\n\nfunction getPropertyType(value) {\n  var type = Type.string(value).toLowerCase()\n\n  if (type === 'date') return 'string'\n  if (type === 'regexp') return 'string'\n  if (type === 'function') return 'string'\n\n  return type\n}\n\nfunction getUniqueKeys(a, b, c) {\n  a = Object.keys(a)\n  b = Object.keys(b)\n  c = c || []\n\n  var value\n  var cIndex\n  var aIndex\n\n  for (var keyIndex = 0, keyLength = b.length; keyIndex < keyLength; keyIndex++) {\n    value = b[keyIndex]\n    aIndex = a.indexOf(value)\n    cIndex = c.indexOf(value)\n\n    if (aIndex === -1) {\n      if (cIndex !== -1) {\n        // Value is optional, it doesn't exist in A but exists in B(n)\n        c.splice(cIndex, 1)\n      }\n    } else if (cIndex === -1) {\n      // Value is required, it exists in both B and A, and is not yet present in C\n      c.push(value)\n    }\n  }\n\n  return c\n}\n\nfunction processArray(array, output, nested) {\n  var format\n  var oneOf\n  var type\n\n  if (nested && output) {\n    output = { items: output }\n  } else {\n    output = output || {}\n    output.type = getPropertyType(array)\n    output.items = output.items || {}\n    type = output.items.type || null\n  }\n\n  // Determine whether each item is different\n  for (var arrIndex = 0, arrLength = array.length; arrIndex < arrLength; arrIndex++) {\n    var elementType = getPropertyType(array[arrIndex])\n    var elementFormat = getPropertyFormat(array[arrIndex])\n\n    if (type && elementType !== type) {\n      output.items.oneOf = []\n      oneOf = true\n      break\n    } else {\n      type = elementType\n      format = elementFormat\n    }\n  }\n\n  // Setup type otherwise\n  if (!oneOf && type) {\n    output.items.type = type\n    if (format) {\n      output.items.format = format\n    }\n  } else if (oneOf && type !== 'object') {\n    output.items = {\n      oneOf: [{ type: type }],\n      required: output.items.required\n    }\n  }\n\n  // Process each item depending\n  if (typeof output.items.oneOf !== 'undefined' || type === 'object') {\n    for (var itemIndex = 0, itemLength = array.length; itemIndex < itemLength; itemIndex++) {\n      var value = array[itemIndex]\n      var itemType = getPropertyType(value)\n      var itemFormat = getPropertyFormat(value)\n      var arrayItem\n      if (itemType === 'object') {\n        if (output.items.properties) {\n          output.items.required = getUniqueKeys(output.items.properties, value, output.items.required)\n        }\n        arrayItem = processObject(value, oneOf ? {} : output.items.properties, true)\n      } else if (itemType === 'array') {\n        arrayItem = processArray(value, oneOf ? {} : output.items.properties, true)\n      } else {\n        arrayItem = {}\n        arrayItem.type = itemType\n        if (itemFormat) {\n          arrayItem.format = itemFormat\n        }\n      }\n      if (oneOf) {\n        var childType = Type.string(value).toLowerCase()\n        var tempObj = {}\n        if (!arrayItem.type && childType === 'object') {\n          tempObj.properties = arrayItem\n          tempObj.type = 'object'\n          arrayItem = tempObj\n        }\n        output.items.oneOf.push(arrayItem)\n      } else {\n        if (output.items.type !== 'object') {\n          continue;\n        }\n        output.items.properties = arrayItem\n      }\n    }\n  }\n  return nested ? output.items : output\n}\n\nfunction processObject(object, output, nested) {\n  if (nested && output) {\n    output = { properties: output }\n  } else {\n    output = output || {}\n    output.type = getPropertyType(object)\n    output.properties = output.properties || {}\n  }\n\n  for (var key in object) {\n    var value = object[key]\n    var type = getPropertyType(value)\n    var format = getPropertyFormat(value)\n\n    type = type === 'undefined' ? 'null' : type\n\n    if (type === 'object') {\n      output.properties[key] = processObject(value, output.properties[key])\n      continue\n    }\n\n    if (type === 'array') {\n      output.properties[key] = processArray(value, output.properties[key])\n      continue\n    }\n\n    if (output.properties[key]) {\n      var entry = output.properties[key]\n      var hasTypeArray = Array.isArray(entry.type)\n\n      // When an array already exists, we check the existing\n      // type array to see if it contains our current property\n      // type, if not, we add it to the array and continue\n      if (hasTypeArray && entry.type.indexOf(type) < 0) {\n        entry.type.push(type)\n      }\n\n      // When multiple fields of differing types occur,\n      // json schema states that the field must specify the\n      // primitive types the field allows in array format.\n      if (!hasTypeArray && entry.type !== type) {\n        entry.type = [entry.type, type]\n      }\n\n      continue\n    }\n\n    output.properties[key] = {}\n    output.properties[key].type = type\n\n    if (format) {\n      output.properties[key].format = format\n    }\n  }\n\n  return nested ? output.properties : output\n}\n\nmodule.exports = function Process (title, object) {\n  var processOutput\n  var output = {\n    $schema: DRAFT\n  }\n\n  // Determine title exists\n  if (typeof title !== 'string') {\n    object = title\n    title = undefined\n  } else {\n    output.title = title\n  }\n\n  // Set initial object type\n  output.type = Type.string(object).toLowerCase()\n\n  // Process object\n  if (output.type === 'object') {\n    processOutput = processObject(object)\n    output.type = processOutput.type\n    output.properties = processOutput.properties\n  }\n\n  if (output.type === 'array') {\n    processOutput = processArray(object)\n    output.type = processOutput.type\n    output.items = processOutput.items\n\n    if (output.title) {\n      output.items.title = output.title\n      output.title += ' Set'\n    }\n  }\n\n  // Output\n  return output\n}\n\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./node_modules/generate-schema/src/schemas/json.js?");

/***/ }),

/***/ "./node_modules/generate-schema/src/schemas/mongoose.js":
/*!**************************************************************!*\
  !*** ./node_modules/generate-schema/src/schemas/mongoose.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Modules\nvar Type = __webpack_require__(/*! type-of-is */ \"./node_modules/type-of-is/index.js\")\nvar Utils = __webpack_require__(/*! ../utils */ \"./node_modules/generate-schema/src/utils.js\")\n\nfunction getNativeType (string) {\n  switch (string) {\n    case \"array\":\n      return 'Array'\n\n    case \"buffer\":\n      return 'Buffer'\n\n    case \"boolean\":\n      return 'Boolean'\n\n    case \"date\":\n      return 'Date'\n\n    case \"number\":\n      return 'Number'\n\n    case \"string\":\n      return 'String'\n\n    case \"objectid\":\n      return 'ObjectId'\n\n    case \"null\":\n    case \"undefined\":\n    case \"regexp\":\n    default:\n      return 'Mixed'\n  }\n}\n\nmodule.exports = function Process (object, output) {\n  var output = output || {}\n\n  for (var key in object) {\n    var value = object[key]\n    var originalType = null\n    var elementType = null\n    var type = null\n\n    if (value instanceof Buffer) {\n      type = 'buffer'\n    }\n\n    if (value != null && typeof value.toString !== 'undefined' && value.toString().match(/^[0-9a-fA-F]{24}$/)) {\n      type = 'objectid'\n    }\n\n    if (!type) {\n      type = Type.string(value).toLowerCase()\n    }\n\n    if (type === 'string' && Utils.isDate(value)) {\n      type = 'date'\n    }\n\n    if (type === 'object') {\n      output[key] = Process(object[key])\n    } else {\n      if (type === 'undefined') {\n        type = 'null'\n      }\n\n      if (type === 'array' && value.length) {\n        originalType = type\n        type = undefined\n\n        for (var index = 0, length = value.length; index < length; index++) {\n          elementType = Type.string(value[index]).toLowerCase()\n\n          if (type && elementType !== type) {\n            type = 'mixed'\n            break\n          } else {\n            type = elementType\n          }\n        }\n      }\n\n      if (originalType && originalType === 'array') {\n        output[key] = { type: [getNativeType(type)] }\n      } else {\n        output[key] = { type: getNativeType(type) }\n      }\n    }\n  }\n\n  return output\n}\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./node_modules/generate-schema/src/schemas/mongoose.js?");

/***/ }),

/***/ "./node_modules/generate-schema/src/schemas/mysql.js":
/*!***********************************************************!*\
  !*** ./node_modules/generate-schema/src/schemas/mysql.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Modules\nvar Type = __webpack_require__(/*! type-of-is */ \"./node_modules/type-of-is/index.js\")\nvar Utils = __webpack_require__(/*! ../utils */ \"./node_modules/generate-schema/src/utils.js\")\n\n// Type Mapping\nvar types = {\n  boolean: 'BOOLEAN',\n  string: 'TEXT',\n  number: 'INT',\n  date: 'DATE',\n  timestamp: 'TIMESTAMP',\n  'regexp': 'TEXT',\n  'undefined': 'TEXT',\n  'null': 'TEXT'\n}\n\nvar lang = {\n  create: function (name) {\n    return ['CREATE TABLE ', name, ' ('].join('')\n  },\n\n  close: function () {\n    return ');'\n  },\n\n  id: function (name, value) {\n    return ['  ', name, '_id ', value, ','].join('')\n  },\n\n  property: function (name, value) {\n    return ['  ', name, ' ', value, ','].join('')\n  },\n\n  primary: function (id) {\n    return ['  PRIMARY KEY (', id, '),'].join('')\n  },\n\n  foreign: function (key1, table, key2) {\n    return ['  FOREIGN KEY (', key1, ') REFERENCES ', table, '(', key2, '),'].join('')\n  },\n}\n\nfunction processObject (obj, options) {\n  var name = options.tableName\n  var parent = options.parentTableName\n  var parentId = options.parentTableId\n  var parentIdType = options.parentTableIdType\n\n  // In-memory storage\n  var keys = Object.keys(obj)\n  var output = []\n  var tables = []\n\n  // Table variables\n  var id = null\n  var idType = 'string'\n\n  // Initialize Table\n  output.push(lang.create(name))\n\n  if (parent) {\n    output.push(lang.property(parent + '_' + parentId, types[parentIdType]))\n  }\n  \n  // Obtain ID\n  var nkey\n  for (var i = 0; i < keys.length; i++) {\n    if (keys[i].toLowerCase() === 'id' || keys[i].toLowerCase().indexOf('_id') > -1) {\n      nkey = keys[i]\n      obj[nkey] = obj[keys[i]]\n      keys[i] = nkey\n      id = keys[i]\n      idType = typeof obj[keys[i]]\n    }\n  }\n\n  if (!id) {\n    id = 'id'\n    idType = parentIdType || idType\n    output.push(lang.property(id, types[idType]))\n  }\n\n  // Create table properties\n  var key, value, type\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i]\n    value = obj[key]\n    type = value instanceof Date\n      ? 'date'\n      : Type.string(value).toLowerCase()\n\n    if (type !== 'undefined') {\n      type = Utils.isTimestamp(value) ? 'timestamp' : type\n    }\n\n    if (type === 'function') {\n      continue\n    }\n    \n    // pojo\n    if (type === 'object' && !value.length) {\n      tables.push('')\n      tables.push(processObject(value, {\n        parentTableName: name,\n        parentTableId: id,\n        parentTableIdType: idType,\n        tableName: name + '_' + key\n      }).join('\\n'))\n      continue\n    }\n\n    // array\n    if (type === 'object' || type === 'array') {\n      if (typeof value[0] === 'object') {\n        tables.push('')\n        tables.push(processObject(value[0], {\n          parentTableName: name,\n          parentTableId: id,\n          parentTableIdType: idType,\n          tableName: name + '_' + key\n        }).join('\\n'))\n        continue      \n      }\n      \n      tables.push('')\n      tables.push(processObject({ \n        value: typeof value[0]\n      }, {\n        parentTableName: name,\n        parentTableId: id,\n        parentTableIdType: idType,\n        tableName: name + '_' + key\n      }).join('\\n'))\n\n      continue\n    }\n\n    output.push(lang.property(key, types[type]))\n  }\n\n  // Handle table keys\n  output.push(lang.primary(id))\n  \n  if (parent) {\n    output.push(lang.foreign(parent + '_id', parent, parentId))\n  }\n\n  output[output.length - 1] = Utils.arrayLastItem(output)\n    .substr(0, Utils.arrayLastItem(output).length - 1)\n\n  output.push(lang.close())\n\n  return output.concat(tables)\n}\n\nmodule.exports = function Process (tableName, object) {\n  if (typeof tableName !== 'string') {\n    object = tableName\n    tableName = 'generic'\n  }\n\n  return processObject(object, {\n    tableName: tableName\n  }).join('\\n')\n}\n\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./node_modules/generate-schema/src/schemas/mysql.js?");

/***/ }),

/***/ "./node_modules/generate-schema/src/utils.js":
/*!***************************************************!*\
  !*** ./node_modules/generate-schema/src/utils.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("var DATE_REGEXP = /\\d{4}-\\d{2}-\\d{2}/\n\nexports.isNumber = function (value) {\n\treturn (typeof value === 'number' || Object.prototype.toString.call(value) === '[object Number]')\n}\n\nexports.isDate = function (date) {\n  return ((new Date(date).toString() !== 'Invalid Date' && !isNaN(new Date(date))))\n}\n\nexports.isTimestamp = function (string) {\n  return string.length > 18 && !isNaN((new Date(string)).getTime())\n}\n\nexports.isDateString = function (string) {\n  return string.match(DATE_REGEXP)\n}\n\nexports.arrayLastItem = function (arr) {\n  return arr[arr.length - 1]\n}\n\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./node_modules/generate-schema/src/utils.js?");

/***/ }),

/***/ "./node_modules/node-fetch/browser.js":
/*!********************************************!*\
  !*** ./node_modules/node-fetch/browser.js ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\n// ref: https://github.com/tc39/proposal-global\nvar getGlobal = function () {\n\t// the only reliable means to get the global object is\n\t// `Function('return this')()`\n\t// However, this causes CSP violations in Chrome apps.\n\tif (typeof self !== 'undefined') { return self; }\n\tif (typeof window !== 'undefined') { return window; }\n\tif (typeof __webpack_require__.g !== 'undefined') { return __webpack_require__.g; }\n\tthrow new Error('unable to locate global object');\n}\n\nvar globalObject = getGlobal();\n\nmodule.exports = exports = globalObject.fetch;\n\n// Needed for TypeScript and Webpack.\nif (globalObject.fetch) {\n\texports[\"default\"] = globalObject.fetch.bind(globalObject);\n}\n\nexports.Headers = globalObject.Headers;\nexports.Request = globalObject.Request;\nexports.Response = globalObject.Response;\n\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./node_modules/node-fetch/browser.js?");

/***/ }),

/***/ "./node_modules/percentile/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/percentile/lib/index.js ***!
  \**********************************************/
/***/ ((module) => {

eval("/**\n @typedef {(Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array)} TypedArray\n */\n\n/**\n * Error message for a case when percentile is less than 0.\n *\n * @param {Number} p\n *\n * @return {String}\n */\nfunction lessThanZeroError(p) {\n  return 'Expect percentile to be >= 0 but given \"' + p + '\" and its type is \"' + (typeof p) + '\".';\n}\n\n/**\n * Error message for a case when percentile is greater than 100.\n *\n * @param {Number} p\n *\n * @return {String}\n */\nfunction greaterThanHundredError(p) {\n  return 'Expect percentile to be <= 100 but given \"' + p + '\" and its type is \"' + (typeof p) + '\".';\n}\n\n/**\n * Error message for a case when percentile is not a number (NaN).\n *\n * @param {Number} p\n *\n * @return {String}\n */\nfunction nanError(p) {\n  return 'Expect percentile to be a number but given \"' + p + '\" and its type is \"' + (typeof p) + '\".';\n}\n\n/**\n * Checks that a list of percentiles are all numbers and they lie in range 0..100.\n *\n * @param {Array<Number>} ps - percentiles to calculate\n *\n * @return {Array} List of errors\n */\nfunction validateInput(ps) {\n  return ps.reduce(function (errors, p) {\n    if (isNaN(Number(p))) {\n      errors.push(nanError(p));\n    } else if (p < 0) {\n      errors.push(lessThanZeroError(p));\n    } else if (p > 100) {\n      errors.push(greaterThanHundredError(p));\n    }\n    return errors;\n  }, []);\n}\n\n/**\n * Get percentile value from an array.\n *\n * @param {Number} p - percentile\n * @param {Array|TypedArray} list - list of values\n *\n * @return {*}\n */\nfunction getPsValue(p, list) {\n  if (p === 0) return list[0];\n  var kIndex = Math.ceil(list.length * (p / 100)) - 1;\n  return list[kIndex];\n}\n\n/**\n * Calculate percentile for given array of values.\n *\n * @template T\n * @param {Number|Array<Number>} pOrPs - percentile or a list of percentiles\n * @param {Array<T>|Array<Number>|TypedArray} list - array of values\n * @param {function(T): Number} [fn] - optional function to extract a value from an array item\n *\n * @return {Number|T|Array<Number>|Array<T>}\n */\nfunction percentile(pOrPs, list, fn) {\n  var ps = Array.isArray(pOrPs) ? pOrPs : [pOrPs];\n  var validationErrors = validateInput(ps);\n\n  if (validationErrors.length) {\n    throw new Error(validationErrors.join(' '));\n  }\n\n  list = list.slice().sort(function (a, b) {\n    if (fn) {\n      a = fn(a);\n      b = fn(b);\n    }\n\n    a = Number.isNaN(a) ? Number.NEGATIVE_INFINITY : a;\n    b = Number.isNaN(b) ? Number.NEGATIVE_INFINITY : b;\n\n    if (a > b) return 1;\n    if (a < b) return -1;\n\n    return 0;\n  });\n\n  if (ps.length === 1) {\n    return getPsValue(ps[0], list);\n  }\n\n  return ps.map(function (p) {\n    return getPsValue(p, list);\n  });\n}\n\nmodule.exports = percentile;\n\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./node_modules/percentile/lib/index.js?");

/***/ }),

/***/ "./node_modules/type-of-is/index.js":
/*!******************************************!*\
  !*** ./node_modules/type-of-is/index.js ***!
  \******************************************/
/***/ ((module) => {

eval("(function (factory) {\n  if (true) {\n    module.exports = factory();\n  } else {}\n}(function () {\n\n  var isBuiltIn = (function () {\n    var built_ins = [\n      Object,\n      Function,\n      Array,\n      String,\n      Boolean,\n      Number,\n      Date,\n      RegExp,\n      Error\n    ];\n    var built_ins_length = built_ins.length;\n\n    return function (_constructor) {\n      for (var i = 0; i < built_ins_length; i++) {\n        if (built_ins[i] === _constructor) {\n          return true;\n        }\n      }\n      return false;\n    };\n  })();\n\n  var stringType = (function () {\n    var _toString = ({}).toString;\n\n    return function (obj) {\n      // [object Blah] -> Blah\n      var stype = _toString.call(obj).slice(8, -1);\n\n      if ((obj === null) || (obj === undefined)) {\n        return stype.toLowerCase();\n      }\n\n      var ctype = of(obj);\n\n      if (ctype && !isBuiltIn(ctype)) {\n        return ctype.name;\n      } else {\n        return stype;\n      }\n    };\n  })();\n\n  function of (obj) {\n    if ((obj === null) || (obj === undefined)) {\n      return obj;\n    } else {\n      return obj.constructor;\n    }\n  }\n\n  function is (obj, test) {\n    var typer = (of(test) === String) ? stringType : of;\n    return (typer(obj) === test);\n  }\n\n  function instance (obj, test) {\n    return (obj instanceof test);\n  }\n\n  function extension (_Extension, _Base) {\n    return instance(_Extension.prototype, _Base);\n  }\n\n  function any (obj, tests) {\n    if (!is(tests, Array)) {\n      throw (\"Second argument to .any() should be array\")\n    }\n    for (var i = 0; i < tests.length; i++) {\n      var test = tests[i];\n      if (is(obj, test)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  var exports = function (obj, type) {\n    if (arguments.length == 1) {\n      return of(obj);\n    } else {\n      if (is(type, Array)) {\n        return any(obj, type);\n      } else {\n        return is(obj, type);\n      }\n    }\n  }\n\n  exports.instance  = instance;\n  exports.string    = stringType;\n  exports.of        = of;\n  exports.is        = is;\n  exports.any       = any;\n  exports.extension = extension;\n  return exports;\n\n}));\n\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./node_modules/type-of-is/index.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NIL: () => (/* reexport safe */ _nil_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   parse: () => (/* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]),\n/* harmony export */   stringify: () => (/* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   v1: () => (/* reexport safe */ _v1_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   v3: () => (/* reexport safe */ _v3_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   v4: () => (/* reexport safe */ _v4_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   v5: () => (/* reexport safe */ _v5_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   validate: () => (/* reexport safe */ _validate_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   version: () => (/* reexport safe */ _version_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v1.js */ \"./node_modules/uuid/dist/esm-browser/v1.js\");\n/* harmony import */ var _v3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./v3.js */ \"./node_modules/uuid/dist/esm-browser/v3.js\");\n/* harmony import */ var _v4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./v4.js */ \"./node_modules/uuid/dist/esm-browser/v4.js\");\n/* harmony import */ var _v5_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./v5.js */ \"./node_modules/uuid/dist/esm-browser/v5.js\");\n/* harmony import */ var _nil_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nil.js */ \"./node_modules/uuid/dist/esm-browser/nil.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./version.js */ \"./node_modules/uuid/dist/esm-browser/version.js\");\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./validate.js */ \"./node_modules/uuid/dist/esm-browser/validate.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/esm-browser/stringify.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parse.js */ \"./node_modules/uuid/dist/esm-browser/parse.js\");\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./node_modules/uuid/dist/esm-browser/index.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/md5.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/md5.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*\n * Browser-compatible JavaScript MD5\n *\n * Modification of JavaScript MD5\n * https://github.com/blueimp/JavaScript-MD5\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n *\n * Based on\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\nfunction md5(bytes) {\n  if (typeof bytes === 'string') {\n    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = new Uint8Array(msg.length);\n\n    for (var i = 0; i < msg.length; ++i) {\n      bytes[i] = msg.charCodeAt(i);\n    }\n  }\n\n  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));\n}\n/*\n * Convert an array of little-endian words to an array of bytes\n */\n\n\nfunction md5ToHexEncodedArray(input) {\n  var output = [];\n  var length32 = input.length * 32;\n  var hexTab = '0123456789abcdef';\n\n  for (var i = 0; i < length32; i += 8) {\n    var x = input[i >> 5] >>> i % 32 & 0xff;\n    var hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);\n    output.push(hex);\n  }\n\n  return output;\n}\n/**\n * Calculate output length with padding and bit length\n */\n\n\nfunction getOutputLength(inputLength8) {\n  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;\n}\n/*\n * Calculate the MD5 of an array of little-endian words, and a bit length.\n */\n\n\nfunction wordsToMd5(x, len) {\n  /* append padding */\n  x[len >> 5] |= 0x80 << len % 32;\n  x[getOutputLength(len) - 1] = len;\n  var a = 1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d = 271733878;\n\n  for (var i = 0; i < x.length; i += 16) {\n    var olda = a;\n    var oldb = b;\n    var oldc = c;\n    var oldd = d;\n    a = md5ff(a, b, c, d, x[i], 7, -680876936);\n    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n    b = md5gg(b, c, d, a, x[i], 20, -373897302);\n    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n    d = md5hh(d, a, b, c, x[i], 11, -358537222);\n    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n    a = md5ii(a, b, c, d, x[i], 6, -198630844);\n    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n    a = safeAdd(a, olda);\n    b = safeAdd(b, oldb);\n    c = safeAdd(c, oldc);\n    d = safeAdd(d, oldd);\n  }\n\n  return [a, b, c, d];\n}\n/*\n * Convert an array bytes to an array of little-endian words\n * Characters >255 have their high-byte silently ignored.\n */\n\n\nfunction bytesToWords(input) {\n  if (input.length === 0) {\n    return [];\n  }\n\n  var length8 = input.length * 8;\n  var output = new Uint32Array(getOutputLength(length8));\n\n  for (var i = 0; i < length8; i += 8) {\n    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;\n  }\n\n  return output;\n}\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\n\n\nfunction safeAdd(x, y) {\n  var lsw = (x & 0xffff) + (y & 0xffff);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return msw << 16 | lsw & 0xffff;\n}\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\n\n\nfunction bitRotateLeft(num, cnt) {\n  return num << cnt | num >>> 32 - cnt;\n}\n/*\n * These functions implement the four basic operations the algorithm uses.\n */\n\n\nfunction md5cmn(q, a, b, x, s, t) {\n  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);\n}\n\nfunction md5ff(a, b, c, d, x, s, t) {\n  return md5cmn(b & c | ~b & d, a, b, x, s, t);\n}\n\nfunction md5gg(a, b, c, d, x, s, t) {\n  return md5cmn(b & d | c & ~d, a, b, x, s, t);\n}\n\nfunction md5hh(a, b, c, d, x, s, t) {\n  return md5cmn(b ^ c ^ d, a, b, x, s, t);\n}\n\nfunction md5ii(a, b, c, d, x, s, t) {\n  return md5cmn(c ^ (b | ~d), a, b, x, s, t);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (md5);\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./node_modules/uuid/dist/esm-browser/md5.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/nil.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/nil.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ('00000000-0000-0000-0000-000000000000');\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./node_modules/uuid/dist/esm-browser/nil.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/parse.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/parse.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"./node_modules/uuid/dist/esm-browser/validate.js\");\n\n\nfunction parse(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  var v;\n  var arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parse);\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./node_modules/uuid/dist/esm-browser/parse.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/regex.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/regex.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./node_modules/uuid/dist/esm-browser/regex.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/rng.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/rng.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rng)\n/* harmony export */ });\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nfunction rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./node_modules/uuid/dist/esm-browser/rng.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/sha1.js":
/*!****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/sha1.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// Adapted from Chris Veness' SHA1 code at\n// http://www.movable-type.co.uk/scripts/sha1.html\nfunction f(s, x, y, z) {\n  switch (s) {\n    case 0:\n      return x & y ^ ~x & z;\n\n    case 1:\n      return x ^ y ^ z;\n\n    case 2:\n      return x & y ^ x & z ^ y & z;\n\n    case 3:\n      return x ^ y ^ z;\n  }\n}\n\nfunction ROTL(x, n) {\n  return x << n | x >>> 32 - n;\n}\n\nfunction sha1(bytes) {\n  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n\n  if (typeof bytes === 'string') {\n    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = [];\n\n    for (var i = 0; i < msg.length; ++i) {\n      bytes.push(msg.charCodeAt(i));\n    }\n  } else if (!Array.isArray(bytes)) {\n    // Convert Array-like to Array\n    bytes = Array.prototype.slice.call(bytes);\n  }\n\n  bytes.push(0x80);\n  var l = bytes.length / 4 + 2;\n  var N = Math.ceil(l / 16);\n  var M = new Array(N);\n\n  for (var _i = 0; _i < N; ++_i) {\n    var arr = new Uint32Array(16);\n\n    for (var j = 0; j < 16; ++j) {\n      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];\n    }\n\n    M[_i] = arr;\n  }\n\n  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n  M[N - 1][14] = Math.floor(M[N - 1][14]);\n  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;\n\n  for (var _i2 = 0; _i2 < N; ++_i2) {\n    var W = new Uint32Array(80);\n\n    for (var t = 0; t < 16; ++t) {\n      W[t] = M[_i2][t];\n    }\n\n    for (var _t = 16; _t < 80; ++_t) {\n      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);\n    }\n\n    var a = H[0];\n    var b = H[1];\n    var c = H[2];\n    var d = H[3];\n    var e = H[4];\n\n    for (var _t2 = 0; _t2 < 80; ++_t2) {\n      var s = Math.floor(_t2 / 20);\n      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;\n      e = d;\n      d = c;\n      c = ROTL(b, 30) >>> 0;\n      b = a;\n      a = T;\n    }\n\n    H[0] = H[0] + a >>> 0;\n    H[1] = H[1] + b >>> 0;\n    H[2] = H[2] + c >>> 0;\n    H[3] = H[3] + d >>> 0;\n    H[4] = H[4] + e >>> 0;\n  }\n\n  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sha1);\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./node_modules/uuid/dist/esm-browser/sha1.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/stringify.js":
/*!*********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/stringify.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"./node_modules/uuid/dist/esm-browser/validate.js\");\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./node_modules/uuid/dist/esm-browser/stringify.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v1.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v1.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"./node_modules/uuid/dist/esm-browser/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/esm-browser/stringify.js\");\n\n // **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\n\nvar _clockseq; // Previous uuid creation time\n\n\nvar _lastMSecs = 0;\nvar _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || new Array(16);\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    var seedBytes = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  var msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(b);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v1);\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./node_modules/uuid/dist/esm-browser/v1.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v3.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v3.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"./node_modules/uuid/dist/esm-browser/v35.js\");\n/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./md5.js */ \"./node_modules/uuid/dist/esm-browser/md5.js\");\n\n\nvar v3 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v3', 0x30, _md5_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v3);\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./node_modules/uuid/dist/esm-browser/v3.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v35.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v35.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DNS: () => (/* binding */ DNS),\n/* harmony export */   URL: () => (/* binding */ URL),\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/esm-browser/stringify.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ \"./node_modules/uuid/dist/esm-browser/parse.js\");\n\n\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  var bytes = [];\n\n  for (var i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nvar DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nvar URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(namespace);\n    }\n\n    if (namespace.length !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    var bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (var i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./node_modules/uuid/dist/esm-browser/v35.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v4.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v4.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"./node_modules/uuid/dist/esm-browser/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/esm-browser/stringify.js\");\n\n\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(rnds);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./node_modules/uuid/dist/esm-browser/v4.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v5.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v5.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"./node_modules/uuid/dist/esm-browser/v35.js\");\n/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha1.js */ \"./node_modules/uuid/dist/esm-browser/sha1.js\");\n\n\nvar v5 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v5);\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./node_modules/uuid/dist/esm-browser/v5.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/validate.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/validate.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"./node_modules/uuid/dist/esm-browser/regex.js\");\n\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./node_modules/uuid/dist/esm-browser/validate.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/version.js":
/*!*******************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/version.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"./node_modules/uuid/dist/esm-browser/validate.js\");\n\n\nfunction version(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  return parseInt(uuid.substr(14, 1), 16);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (version);\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./node_modules/uuid/dist/esm-browser/version.js?");

/***/ }),

/***/ "./node_modules/vega-datasets/build/vega-datasets.js":
/*!***********************************************************!*\
  !*** ./node_modules/vega-datasets/build/vega-datasets.js ***!
  \***********************************************************/
/***/ (function(module) {

eval("(function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n}(this, (function () { 'use strict';\n\n  var EOL = {},\n      EOF = {},\n      QUOTE = 34,\n      NEWLINE = 10,\n      RETURN = 13;\n\n  function objectConverter(columns) {\n    return new Function(\"d\", \"return {\" + columns.map(function(name, i) {\n      return JSON.stringify(name) + \": d[\" + i + \"] || \\\"\\\"\";\n    }).join(\",\") + \"}\");\n  }\n\n  function customConverter(columns, f) {\n    var object = objectConverter(columns);\n    return function(row, i) {\n      return f(object(row), i, columns);\n    };\n  }\n\n  // Compute unique columns in order of discovery.\n  function inferColumns(rows) {\n    var columnSet = Object.create(null),\n        columns = [];\n\n    rows.forEach(function(row) {\n      for (var column in row) {\n        if (!(column in columnSet)) {\n          columns.push(columnSet[column] = column);\n        }\n      }\n    });\n\n    return columns;\n  }\n\n  function pad(value, width) {\n    var s = value + \"\", length = s.length;\n    return length < width ? new Array(width - length + 1).join(0) + s : s;\n  }\n\n  function formatYear(year) {\n    return year < 0 ? \"-\" + pad(-year, 6)\n      : year > 9999 ? \"+\" + pad(year, 6)\n      : pad(year, 4);\n  }\n\n  function formatDate(date) {\n    var hours = date.getUTCHours(),\n        minutes = date.getUTCMinutes(),\n        seconds = date.getUTCSeconds(),\n        milliseconds = date.getUTCMilliseconds();\n    return isNaN(date) ? \"Invalid Date\"\n        : formatYear(date.getUTCFullYear()) + \"-\" + pad(date.getUTCMonth() + 1, 2) + \"-\" + pad(date.getUTCDate(), 2)\n        + (milliseconds ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \":\" + pad(seconds, 2) + \".\" + pad(milliseconds, 3) + \"Z\"\n        : seconds ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \":\" + pad(seconds, 2) + \"Z\"\n        : minutes || hours ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \"Z\"\n        : \"\");\n  }\n\n  function dsv(delimiter) {\n    var reFormat = new RegExp(\"[\\\"\" + delimiter + \"\\n\\r]\"),\n        DELIMITER = delimiter.charCodeAt(0);\n\n    function parse(text, f) {\n      var convert, columns, rows = parseRows(text, function(row, i) {\n        if (convert) return convert(row, i - 1);\n        columns = row, convert = f ? customConverter(row, f) : objectConverter(row);\n      });\n      rows.columns = columns || [];\n      return rows;\n    }\n\n    function parseRows(text, f) {\n      var rows = [], // output rows\n          N = text.length,\n          I = 0, // current character index\n          n = 0, // current line number\n          t, // current token\n          eof = N <= 0, // current token followed by EOF?\n          eol = false; // current token followed by EOL?\n\n      // Strip the trailing newline.\n      if (text.charCodeAt(N - 1) === NEWLINE) --N;\n      if (text.charCodeAt(N - 1) === RETURN) --N;\n\n      function token() {\n        if (eof) return EOF;\n        if (eol) return eol = false, EOL;\n\n        // Unescape quotes.\n        var i, j = I, c;\n        if (text.charCodeAt(j) === QUOTE) {\n          while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);\n          if ((i = I) >= N) eof = true;\n          else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;\n          else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }\n          return text.slice(j + 1, i - 1).replace(/\"\"/g, \"\\\"\");\n        }\n\n        // Find next delimiter or newline.\n        while (I < N) {\n          if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;\n          else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }\n          else if (c !== DELIMITER) continue;\n          return text.slice(j, i);\n        }\n\n        // Return last token before EOF.\n        return eof = true, text.slice(j, N);\n      }\n\n      while ((t = token()) !== EOF) {\n        var row = [];\n        while (t !== EOL && t !== EOF) row.push(t), t = token();\n        if (f && (row = f(row, n++)) == null) continue;\n        rows.push(row);\n      }\n\n      return rows;\n    }\n\n    function preformatBody(rows, columns) {\n      return rows.map(function(row) {\n        return columns.map(function(column) {\n          return formatValue(row[column]);\n        }).join(delimiter);\n      });\n    }\n\n    function format(rows, columns) {\n      if (columns == null) columns = inferColumns(rows);\n      return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join(\"\\n\");\n    }\n\n    function formatBody(rows, columns) {\n      if (columns == null) columns = inferColumns(rows);\n      return preformatBody(rows, columns).join(\"\\n\");\n    }\n\n    function formatRows(rows) {\n      return rows.map(formatRow).join(\"\\n\");\n    }\n\n    function formatRow(row) {\n      return row.map(formatValue).join(delimiter);\n    }\n\n    function formatValue(value) {\n      return value == null ? \"\"\n          : value instanceof Date ? formatDate(value)\n          : reFormat.test(value += \"\") ? \"\\\"\" + value.replace(/\"/g, \"\\\"\\\"\") + \"\\\"\"\n          : value;\n    }\n\n    return {\n      parse: parse,\n      parseRows: parseRows,\n      format: format,\n      formatBody: formatBody,\n      formatRows: formatRows,\n      formatRow: formatRow,\n      formatValue: formatValue\n    };\n  }\n\n  var csv = dsv(\",\");\n\n  var csvParse = csv.parse;\n\n  function autoType(object) {\n    for (var key in object) {\n      var value = object[key].trim(), number, m;\n      if (!value) value = null;\n      else if (value === \"true\") value = true;\n      else if (value === \"false\") value = false;\n      else if (value === \"NaN\") value = NaN;\n      else if (!isNaN(number = +value)) value = number;\n      else if (m = value.match(/^([-+]\\d{2})?\\d{4}(-\\d{2}(-\\d{2})?)?(T\\d{2}:\\d{2}(:\\d{2}(\\.\\d{3})?)?(Z|[-+]\\d{2}:\\d{2})?)?$/)) {\n        if (fixtz && !!m[4] && !m[7]) value = value.replace(/-/g, \"/\").replace(/T/, \" \");\n        value = new Date(value);\n      }\n      else continue;\n      object[key] = value;\n    }\n    return object;\n  }\n\n  // https://github.com/d3/d3-dsv/issues/45\n  var fixtz = new Date(\"2019-01-01T00:00\").getHours() || new Date(\"2019-07-01T00:00\").getHours();\n\n  var version = \"2.0.0\";\n\n  var urls = {\n      'annual-precip.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/annual-precip.json`,\n      'anscombe.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/anscombe.json`,\n      'barley.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/barley.json`,\n      'budget.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/budget.json`,\n      'budgets.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/budgets.json`,\n      'burtin.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/burtin.json`,\n      'cars.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/cars.json`,\n      'countries.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/countries.json`,\n      'crimea.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/crimea.json`,\n      'driving.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/driving.json`,\n      'earthquakes.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/earthquakes.json`,\n      'flare-dependencies.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/flare-dependencies.json`,\n      'flare.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/flare.json`,\n      'flights-10k.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/flights-10k.json`,\n      'flights-200k.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/flights-200k.json`,\n      'flights-20k.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/flights-20k.json`,\n      'flights-2k.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/flights-2k.json`,\n      'flights-5k.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/flights-5k.json`,\n      'football.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/football.json`,\n      'gapminder.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/gapminder.json`,\n      'income.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/income.json`,\n      'jobs.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/jobs.json`,\n      'londonBoroughs.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/londonBoroughs.json`,\n      'londonCentroids.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/londonCentroids.json`,\n      'londonTubeLines.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/londonTubeLines.json`,\n      'miserables.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/miserables.json`,\n      'monarchs.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/monarchs.json`,\n      'movies.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/movies.json`,\n      'normal-2d.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/normal-2d.json`,\n      'obesity.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/obesity.json`,\n      'ohlc.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/ohlc.json`,\n      'penguins.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/penguins.json`,\n      'points.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/points.json`,\n      'political-contributions.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/political-contributions.json`,\n      'population.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/population.json`,\n      'udistrict.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/udistrict.json`,\n      'unemployment-across-industries.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/unemployment-across-industries.json`,\n      'uniform-2d.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/uniform-2d.json`,\n      'us-10m.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/us-10m.json`,\n      'us-state-capitals.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/us-state-capitals.json`,\n      'volcano.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/volcano.json`,\n      'weather.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/weather.json`,\n      'wheat.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/wheat.json`,\n      'world-110m.json': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/world-110m.json`,\n      'airports.csv': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/airports.csv`,\n      'birdstrikes.csv': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/birdstrikes.csv`,\n      'co2-concentration.csv': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/co2-concentration.csv`,\n      'disasters.csv': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/disasters.csv`,\n      'flights-3m.csv': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/flights-3m.csv`,\n      'flights-airport.csv': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/flights-airport.csv`,\n      'gapminder-health-income.csv': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/gapminder-health-income.csv`,\n      'github.csv': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/github.csv`,\n      'iowa-electricity.csv': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/iowa-electricity.csv`,\n      'la-riots.csv': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/la-riots.csv`,\n      'lookup_groups.csv': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/lookup_groups.csv`,\n      'lookup_people.csv': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/lookup_people.csv`,\n      'population_engineers_hurricanes.csv': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/population_engineers_hurricanes.csv`,\n      'seattle-weather-hourly-normals.csv': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/seattle-weather-hourly-normals.csv`,\n      'seattle-weather.csv': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/seattle-weather.csv`,\n      'sp500.csv': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/sp500.csv`,\n      'stocks.csv': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/stocks.csv`,\n      'us-employment.csv': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/us-employment.csv`,\n      'weather.csv': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/weather.csv`,\n      'windvectors.csv': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/windvectors.csv`,\n      'zipcodes.csv': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/zipcodes.csv`,\n      'unemployment.tsv': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/unemployment.tsv`,\n      'flights-200k.arrow': `https://cdn.jsdelivr.net/npm/vega-datasets@${version}/data/flights-200k.arrow`,\n  };\n\n  var __awaiter = ( false) || function (thisArg, _arguments, P, generator) {\n      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n      return new (P || (P = Promise))(function (resolve, reject) {\n          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n          function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n          step((generator = generator.apply(thisArg, _arguments || [])).next());\n      });\n  };\n  const data = { version };\n  for (const name of Object.keys(urls)) {\n      const url = urls[name];\n      const f = function () {\n          return __awaiter(this, void 0, void 0, function* () {\n              const result = yield fetch(url);\n              if (name.endsWith(\".json\")) {\n                  return yield result.json();\n              }\n              else if (name.endsWith(\".csv\")) {\n                  // TODO: remove \"as any\" once @types/d3-dsv has been updated\n                  return csvParse(yield result.text(), autoType);\n              }\n              else {\n                  return yield result.text();\n              }\n          });\n      };\n      f.url = url;\n      data[name] = f;\n  }\n\n  return data;\n\n})));\n//# sourceMappingURL=vega-datasets.js.map\n\n\n//# sourceURL=webpack://jupyter-ijavascript-utils/./node_modules/vega-datasets/build/vega-datasets.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/webpack.js");
/******/ 	
/******/ })()
;